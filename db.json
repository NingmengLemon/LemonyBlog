{"meta":{"version":1,"warehouse":"5.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-nexmoe/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/lax.min.js","path":"lib/lax.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/js/copy-codeblock.js","path":"js/copy-codeblock.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/preset/plain.styl","path":"preset/plain.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/demo.css","path":"lib/iconfont/demo.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/demo_index.html","path":"lib/iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.css","path":"lib/iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.eot","path":"lib/iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.js","path":"lib/iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.json","path":"lib/iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.svg","path":"lib/iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.ttf","path":"lib/iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.woff","path":"lib/iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.woff2","path":"lib/iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/fancybox/fancybox.umd.js","path":"lib/fancybox/fancybox.umd.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/fancybox/fancybox.css","path":"lib/fancybox/fancybox.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/mdui_043tiny/mdui.css","path":"lib/mdui_043tiny/mdui.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/mdui_043tiny/mdui.js","path":"lib/mdui_043tiny/mdui.js","modified":0,"renderable":1},{"_id":"source/assets/avatar.jpg","path":"assets/avatar.jpg","modified":0,"renderable":0},{"_id":"source/assets/bg.png","path":"assets/bg.png","modified":0,"renderable":0},{"_id":"source/assets/friends/yyx.jpg","path":"assets/friends/yyx.jpg","modified":0,"renderable":0},{"_id":"source/assets/blogs/Just-a-test/Cheshire_cat.png","path":"assets/blogs/Just-a-test/Cheshire_cat.png","modified":0,"renderable":0},{"_id":"source/assets/about/cover.png","path":"assets/about/cover.png","modified":0,"renderable":0},{"_id":"source/assets/favicon.png","path":"assets/favicon.png","modified":0,"renderable":0},{"_id":"source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":0},{"_id":"source/assets/friends/lyh.jpg","path":"assets/friends/lyh.jpg","modified":0,"renderable":0},{"_id":"source/assets/friends/qurser.jpg","path":"assets/friends/qurser.jpg","modified":0,"renderable":0},{"_id":"source/assets/blogs/BiliTools-introduction/plot_shower.png","path":"assets/blogs/BiliTools-introduction/plot_shower.png","modified":0,"renderable":0},{"_id":"source/assets/blogs/BiliTools-introduction/plot_shower_failed.png","path":"assets/blogs/BiliTools-introduction/plot_shower_failed.png","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/assets/blogs/discrete_math_graphs_algos/Bellman–Ford_algorithm_example.gif","path":"assets/blogs/discrete_math_graphs_algos/Bellman–Ford_algorithm_example.gif","modified":0,"renderable":0},{"_id":"source/assets/blogs/discrete_math_graphs_algos/Dijkstra_Animation.gif","path":"assets/blogs/discrete_math_graphs_algos/Dijkstra_Animation.gif","modified":0,"renderable":0}],"Cache":[{"_id":"source/archive.md","hash":"42587168715abac06e2b4200e4f9de2ed8a8a71d","modified":1703683703464},{"_id":"source/custom.css","hash":"a288847ce2bd87ab4101d0e0e25edefb05590228","modified":1703737935894},{"_id":"source/friends.md","hash":"5e53f3f7851277bda89478c97dd1abb6c9f99d90","modified":1703748603571},{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1703673904982},{"_id":"source/_posts/Just-a-test.md","hash":"e91fbcf6368a1da157008d95234bcfb5c80c69d9","modified":1717423589621},{"_id":"source/assets/avatar.jpg","hash":"ea162a5ead04cff7d16681398cf27e2ec1af9fe6","modified":1703681357673},{"_id":"source/assets/Just-a-test/Cheshire_cat.png","hash":"aeaa47778394fa2d283318fdb79fc1670d1f938f","modified":1701586518000},{"_id":"node_modules/hexo-theme-nexmoe/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1703680155538},{"_id":"node_modules/hexo-theme-nexmoe/.eslintignore","hash":"1d606028dff10b1a8c635142235182379dc3c64e","modified":1703680155464},{"_id":"node_modules/hexo-theme-nexmoe/.eslintrc.json","hash":"ca45d8e5d80ad6b7004cddacae7fc7d8040b2d6f","modified":1703680155917},{"_id":"node_modules/hexo-theme-nexmoe/crowdin.yml","hash":"f9f02a9cab975c7de721c5dc4179b77870019cc6","modified":1703680156033},{"_id":"node_modules/hexo-theme-nexmoe/index.js","hash":"f3d92ae5f32a9aee66f8b24083a2004d69a2b761","modified":1703680155888},{"_id":"node_modules/hexo-theme-nexmoe/package.json","hash":"5f5c79d7fdaa58fa87142085f1f010762afdd643","modified":1703680155937},{"_id":"node_modules/hexo-theme-nexmoe/.github/release-drafter.yml","hash":"9be21d7a486404050224d61415226e1ba321f169","modified":1703680156043},{"_id":"node_modules/hexo-theme-nexmoe/README.md","hash":"7e77fc64595bc4afe6a56ebe0fe525a874b4f017","modified":1703680155979},{"_id":"node_modules/hexo-theme-nexmoe/demo/_config.yml","hash":"f5a551599d83995e0dbc4719e7950fa889b3dc64","modified":1703680156031},{"_id":"node_modules/hexo-theme-nexmoe/demo/_config.nexmoe.yml","hash":"8f508665b4512954103e04e1e86f9ebfe30e7748","modified":1703680156029},{"_id":"node_modules/hexo-theme-nexmoe/renovate.json","hash":"767b077c7b615e20af3cf865813cd64674a9bea6","modified":1703680155938},{"_id":"node_modules/hexo-theme-nexmoe/demo/package.json","hash":"883603a5be41686e89c26519e5bfe097343edcc6","modified":1703680155935},{"_id":"node_modules/hexo-theme-nexmoe/include/config.js","hash":"f26ff9408ca6ce956ef40ac6c6996da36c9df67d","modified":1703680155854},{"_id":"node_modules/hexo-theme-nexmoe/include/dependency.js","hash":"ed975738b982c19565bc2869a51277723fd23e6b","modified":1703680155867},{"_id":"node_modules/hexo-theme-nexmoe/include/register.js","hash":"446119e7fbc44da8d0fc8c3628c14fadb225c558","modified":1703680155912},{"_id":"node_modules/hexo-theme-nexmoe/languages/en.yml","hash":"1a2ab324edb076988fa7a098d2b011d80738a047","modified":1703680156037},{"_id":"node_modules/hexo-theme-nexmoe/languages/default.yml","hash":"c76f93c3c0ac4582694e330647f2fe424930ec3a","modified":1703680156035},{"_id":"node_modules/hexo-theme-nexmoe/include/README.md","hash":"912c1a78db7138e3ff6e1ce622dd00e3bfb1afab","modified":1703680155978},{"_id":"node_modules/hexo-theme-nexmoe/languages/zh-HK.yml","hash":"6b6ada7b425c137cd51edc2f4890b96a21482558","modified":1703680156046},{"_id":"node_modules/hexo-theme-nexmoe/languages/it.yml","hash":"334afb6a7967d71ebd2fb32bdd1f8b20174c82bd","modified":1703680156037},{"_id":"node_modules/hexo-theme-nexmoe/languages/zh-CN.yml","hash":"b30de168c5bc226cdb9dbd7358b7b0d33a34e1d5","modified":1703680156045},{"_id":"node_modules/hexo-theme-nexmoe/languages/zh-TW.yml","hash":"e4ababddda52aa89f0fd51909c2211bcd10abb53","modified":1703680156047},{"_id":"node_modules/hexo-theme-nexmoe/layout/archives.ejs","hash":"2395fdfee67880c1c6b4796882c6fda67930f1f7","modified":1703680155716},{"_id":"node_modules/hexo-theme-nexmoe/languages/zh.yml","hash":"81aa48d1ada886cb10f5a195c3afb250f962f3ac","modified":1703680156049},{"_id":"node_modules/hexo-theme-nexmoe/languages/ja.yml","hash":"773c3b0464771c6d5149a2175bb9d7eaceb755ea","modified":1703680156038},{"_id":"node_modules/hexo-theme-nexmoe/layout/index.jsx","hash":"20373ddf76f6d59dde51833e754c9f70cc804f77","modified":1703680155954},{"_id":"node_modules/hexo-theme-nexmoe/layout/layout.jsx","hash":"e347c8e933b3e496add81502c1a2e229b0042f73","modified":1703680155956},{"_id":"node_modules/hexo-theme-nexmoe/layout/py.jsx","hash":"590216a1f66a2085d98544fe082c503ec3baa02e","modified":1703680155959},{"_id":"node_modules/hexo-theme-nexmoe/scripts/index.js","hash":"c00aba78d38330728dbbdbb0bae57f1b00a7de5e","modified":1703680155891},{"_id":"node_modules/hexo-theme-nexmoe/layout/post.ejs","hash":"a22ebd3ceec83722a0c2b1a5bc11688818ae25a7","modified":1703680155808},{"_id":"node_modules/hexo-theme-nexmoe/source/_config.yml","hash":"c09a5a5a10889ef15cbfad988474527ccad19546","modified":1703680156032},{"_id":"node_modules/hexo-theme-nexmoe/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"d6c77dbb2a3d638d748280fb37dd29375aebe98c","modified":1703680155965},{"_id":"node_modules/hexo-theme-nexmoe/.github/ISSUE_TEMPLATE/feature_request_en.md","hash":"803f6736473a122ed78867e64681defcd2edd954","modified":1703680155969},{"_id":"node_modules/hexo-theme-nexmoe/.github/ISSUE_TEMPLATE/bug_report_en.md","hash":"557484415c610222b16b58df470c2a768782c4fc","modified":1703680155963},{"_id":"node_modules/hexo-theme-nexmoe/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"843abf5e1d7b06cb1feddd75f7025150d46a91c2","modified":1703680155970},{"_id":"node_modules/hexo-theme-nexmoe/demo/.github/dependabot.yml","hash":"25b0257a0db2c5b6a5756d8990bc2cba12f54fc5","modified":1703680156036},{"_id":"node_modules/hexo-theme-nexmoe/.github/workflows/npm-publish.yml","hash":"b57ce794238f61bb8223752e516970cd1b7732c9","modified":1703680156041},{"_id":"node_modules/hexo-theme-nexmoe/.github/workflows/release-drafter.yml","hash":"ccbe1e1ae6ee3b2a7d32362791aa006afa95e94d","modified":1703680156044},{"_id":"node_modules/hexo-theme-nexmoe/demo/scaffolds/draft.md","hash":"204ab550ddffa92051ea0eb2484a78d84dac3693","modified":1703680155967},{"_id":"node_modules/hexo-theme-nexmoe/demo/scaffolds/page.md","hash":"f0af1cb10f27d859caa51c8e3704469d9ed842a6","modified":1703680155974},{"_id":"node_modules/hexo-theme-nexmoe/demo/scaffolds/post.md","hash":"e7169dab8ce62d41e3734e30706fa786cc7d46f4","modified":1703680155976},{"_id":"node_modules/hexo-theme-nexmoe/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1703680155858},{"_id":"node_modules/hexo-theme-nexmoe/layout/_index/list.ejs","hash":"e98a95f50d6f9042302ec4fad62ac85c5336ba26","modified":1703680155757},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/archive.ejs","hash":"2c8c5ee017bfdd56cbb80c7796ef9393aea16d52","modified":1703680155708},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/category.ejs","hash":"99113b9f2cb4ffefdda3e3a343647ac6a5083091","modified":1703680155723},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/hitokoto.ejs","hash":"2c9c3567d2b5a99cdbca90673c638409529881db","modified":1703680155746},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/recent_posts.ejs","hash":"7d9eaf8228eda803aa4956e55432f78e056d6a01","modified":1703680155811},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/link.ejs","hash":"61bc7a6018309f5b3525b451ccdd62e6664f7e74","modified":1703680155751},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/tag.ejs","hash":"ddf844f08124454bea2a30f8349b63f3cb63ac16","modified":1703680155825},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/search.ejs","hash":"9771d5e03623a8892c23dab9b24360edbaf87233","modified":1703680155816},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/tagcloud.ejs","hash":"25e1af5116bd5cbf6c1d1e259a8564e21a3a28d5","modified":1703680155828},{"_id":"node_modules/hexo-theme-nexmoe/layout/_widget/social.ejs","hash":"133927c64cbe6f9cf6601e32be0b03ed576dfbf5","modified":1703680155819},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/background.jsx","hash":"05ee70bc00ddac592469a9e56cfdb9f683f130ef","modified":1703680155940},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/head.ejs","hash":"c14cec07f778dbf643e51671e47c2e6e711045b8","modified":1703680155737},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/paginator.jsx","hash":"9b1f26c6f899b1c66c65d7213137f02796b56236","modified":1703680155957},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/searchbox.jsx","hash":"83714b79399e0bef913bef8c4dbef58e9dd875f2","modified":1703680155960},{"_id":"node_modules/hexo-theme-nexmoe/scripts/helper/image_filter.js","hash":"284c3f15eaba3ff6db42fe12f921fada5c6f24b4","modified":1703680155886},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/right.ejs","hash":"e4db789fcf7f7dfe58e22c78ae30a5db2355cc47","modified":1703680155814},{"_id":"node_modules/hexo-theme-nexmoe/scripts/helper/css_auto_version.js","hash":"354700a113aca785c82bd59a16901a2dff2a2580","modified":1703680155864},{"_id":"node_modules/hexo-theme-nexmoe/scripts/helper/js_auto_version.js","hash":"96e6d7d0dadd39198e33ec8d5f0331e4a600ca37","modified":1703680155893},{"_id":"node_modules/hexo-theme-nexmoe/scripts/tag/gallery.js","hash":"bc07b003bd405138ff4bca5fb03ba180fc29b92e","modified":1703680155881},{"_id":"node_modules/hexo-theme-nexmoe/scripts/tag/links.js","hash":"3676a23bdf32e0c1a933ccb8a79da6c5880a2e19","modified":1703680155898},{"_id":"node_modules/hexo-theme-nexmoe/source/css/style.styl","hash":"2021dacedfe0f6f2ed6fdf6a9e9c067fe792cde0","modified":1703680156018},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/lax.min.js","hash":"1de100aa90834f1f4fae9a4deb44a73048fefff0","modified":1703680155897},{"_id":"node_modules/hexo-theme-nexmoe/source/js/search.js","hash":"eb69cd78f6ab8d3e83576dae29f09c9af0ffe8b9","modified":1703680155915},{"_id":"node_modules/hexo-theme-nexmoe/source/js/app.js","hash":"965c3befaa26a06484204b34f20b8770e186866a","modified":1703680155850},{"_id":"node_modules/hexo-theme-nexmoe/source/js/copy-codeblock.js","hash":"51f1b526133258db1080826574c50a683a34c559","modified":1703680155860},{"_id":"node_modules/hexo-theme-nexmoe/source/preset/plain.styl","hash":"0413a4e36642110f0a23738d10f2874e6e43ed6d","modified":1703680156011},{"_id":"node_modules/hexo-theme-nexmoe/demo/source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1703680155973},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/xiaoshu/body.jsx","hash":"1d8210e9968298440a1da0cc86c3e3454dba4427","modified":1703680155945},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/xiaoshu/content.jsx","hash":"13a868d0b70283aaaa49770ad530261eda7a750d","modified":1703680155947},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/xiaoshu/footer.jsx","hash":"3ede4910be7915854ee06a545aa8ee04bd216031","modified":1703680155950},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/xiaoshu/header.jsx","hash":"3ede4910be7915854ee06a545aa8ee04bd216031","modified":1703680155952},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/nexmoe/body.jsx","hash":"7e63a37bcd01a67950fb4f52895bf9e6cf9f955b","modified":1703680155942},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/nexmoe/content.jsx","hash":"4bfadb1ce4e732289f43f81cfce41fb35a3f2f89","modified":1703680155946},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/nexmoe/footer.jsx","hash":"167f67e30cdb15576c9cd9dd7cc6aafb4625e069","modified":1703680155949},{"_id":"node_modules/hexo-theme-nexmoe/layout/_layout/nexmoe/header.ejs","hash":"24ebcbd15daee1b6b1ede4ffaffa9b86f7154167","modified":1703680155742},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_post/copyright.ejs","hash":"bf2cb43d66842b4bc51eb6908c588044a68d1364","modified":1703680155730},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_post/meta.ejs","hash":"be2fdf6732f49d5d3277b4e4b0a4f9fc85fa4643","modified":1703680155806},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_post/tag.ejs","hash":"5934bcb1b256642708c97f61da85fbdbd959a078","modified":1703680155822},{"_id":"node_modules/hexo-theme-nexmoe/layout/_partial/_post/word-count.ejs","hash":"5415f792394b364fcbc1502971874dac6ea54de4","modified":1703680155830},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_index/list.styl","hash":"6ce0e88126225e582c4d788c4c88a30c11fee8fb","modified":1703680156007},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/archives.styl","hash":"3f401f6caf7e7ed6c0b7fe622ed02a25cc9e5237","modified":1703680155983},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/article.styl","hash":"726d9837026a4979dae3d9d790feba952de98b48","modified":1703680155985},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/background.styl","hash":"a4c012e17734de0bf1a62bf5b5ebc98755b23bcb","modified":1703680155986},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/copy-codeblock.styl","hash":"83372948cb098a8ad1da8bde17963701b8e39409","modified":1703680155994},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/pagination.styl","hash":"aa22dd62542d69f07ce5178cd3f94cf20c9f1bca","modified":1703680156008},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/py.styl","hash":"53c72cb99593d83523559013713fc25b4ae5957c","modified":1703680156013},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_partial/searchbox.styl","hash":"b25cefb269bb7188ed9d6ab0b530f30e138b33d1","modified":1703680156015},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_widget/hitokoto.styl","hash":"0086bb5a3f250439be64588fca075ee3326a6ad1","modified":1703680156003},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_widget/index.styl","hash":"465acffbe8cc98c3b275cc286c0991f422930b60","modified":1703680156004},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/demo.css","hash":"53456972a11d52af67187fc17999e6665f9f06fe","modified":1703680155589},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/demo_index.html","hash":"a82acbfeabc50a6668ebf6115b5c5c3d308079b6","modified":1703680155840},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.css","hash":"3566d949bdc045cd816be382d180b796e0a78748","modified":1703680155644},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.eot","hash":"1d1851c2197382a9b7cd3b3fcdef79a61ad331f6","modified":1703680155835},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.js","hash":"a536d4780220f9cd7fc5126d9ec1108b19afb6b9","modified":1703680155885},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.json","hash":"0dd0193f6f400e5da6d3aef89f76c22c79e0f396","modified":1703680155921},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.svg","hash":"2af6d26577c3ae2ca126351f0be764cbae9da6ff","modified":1703680156021},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.ttf","hash":"b0f4b5501cbcaeaf15dc608359574a29bc4c4265","modified":1703680156024},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.woff","hash":"e292802913e6c248a17797dc24ecfc0a3473c3cf","modified":1703680156025},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/iconfont/iconfont.woff2","hash":"9209e4f7e45d37e58356e5ede7ea9d6d9e922d77","modified":1703680156028},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/fancybox/fancybox.css","hash":"cbce0cfc36f47e30e9c9824875f0b854a05f1916","modified":1703680155624},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_layout/nexmoe/content.styl","hash":"718c99320e6862a020e2652d8259c980283a6ac0","modified":1703680155989},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_layout/nexmoe/header.styl","hash":"b1c905f3a6089936aa6740546c266c03a99a8169","modified":1703680155997},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_layout/xiaoshu/content.styl","hash":"0e382da59dfe8bb1451b115e1c32f40ed126174f","modified":1703680155993},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_layout/xiaoshu/footer.styl","hash":"bebef911fb8030bbfed418492e6c1c0eae2306a7","modified":1703680155996},{"_id":"node_modules/hexo-theme-nexmoe/source/css/_layout/xiaoshu/header.styl","hash":"fb047e449d0a3f37f8beffc31af0ed9ffa2da9d3","modified":1703680155998},{"_id":"source/assets/yyx.jpg","hash":"25ef158ee1e2ed631b98cd933ee304ed234aa1c2","modified":1703683459981},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/fancybox/fancybox.umd.js","hash":"f2126b3e96721606a2ba20e0f148404814262171","modified":1703680155877},{"_id":"node_modules/hexo-theme-nexmoe/demo/package-lock.json","hash":"37e07fd906a664c3706e684e8efcb4d86f31e3e9","modified":1703680155934},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/mdui_043tiny/mdui.css","hash":"1500b5d27b8ce2e7c543bb6d7205de43059378db","modified":1703680155700},{"_id":"node_modules/hexo-theme-nexmoe/source/lib/mdui_043tiny/mdui.js","hash":"5c0bced25b23773e764338ae4581f366f984cb6c","modified":1703680155911},{"_id":"source/assets/bg.png","hash":"52b779ec4d77e92bb77432b36f2a165e6d2ab117","modified":1689429700509},{"_id":"public/custom.css","hash":"70e48403dd6c1d8af99568ff95f1b9c79401836f","modified":1703741186169},{"_id":"public/content.json","hash":"736bc2772ac035797cc1f1d53cf21b80c845b880","modified":1717423722562},{"_id":"public/archive.html","hash":"65ae7810d65599b5fabdb57b5e17570b74dd77ec","modified":1717423722562},{"_id":"public/friends.html","hash":"3f62473b8069598abad0cfd22b8154a6ece2cd9d","modified":1717423722562},{"_id":"public/2023/12/27/hello-world/index.html","hash":"485e1965b66b9d1253ac22431074eec977d79af0","modified":1703684284977},{"_id":"public/archives/2023/index.html","hash":"8c115968cfc604916d501155d6169ac21114f06d","modified":1717423722562},{"_id":"public/2023/12/27/Just-a-test/index.html","hash":"d7fbd0933e6fc3d62bc38e1beba5691e5ce52b78","modified":1717423722562},{"_id":"public/index.html","hash":"ee2a33bd9b8de97e1755825de6eba3b96b36fb65","modified":1717423722562},{"_id":"public/archives/index.html","hash":"467de07ed0442b0243d5fad4fa5f13be78be96ac","modified":1717423722562},{"_id":"public/archives/2023/12/index.html","hash":"a68c443115ac74a4a447beb6ea46a7e38d60df84","modified":1717423722562},{"_id":"public/lib/iconfont/iconfont.eot","hash":"1d1851c2197382a9b7cd3b3fcdef79a61ad331f6","modified":1703683808993},{"_id":"public/lib/iconfont/iconfont.svg","hash":"2af6d26577c3ae2ca126351f0be764cbae9da6ff","modified":1703683808993},{"_id":"public/lib/iconfont/iconfont.ttf","hash":"b0f4b5501cbcaeaf15dc608359574a29bc4c4265","modified":1703683808993},{"_id":"public/lib/iconfont/iconfont.woff","hash":"e292802913e6c248a17797dc24ecfc0a3473c3cf","modified":1703683808993},{"_id":"public/lib/iconfont/iconfont.woff2","hash":"9209e4f7e45d37e58356e5ede7ea9d6d9e922d77","modified":1703683808993},{"_id":"public/css/style.css","hash":"2986810eeaa90c45dce6d38f4b6ff845f39a2f0a","modified":1703683808993},{"_id":"public/lib/lax.min.js","hash":"1de100aa90834f1f4fae9a4deb44a73048fefff0","modified":1703683808993},{"_id":"public/js/search.js","hash":"eb69cd78f6ab8d3e83576dae29f09c9af0ffe8b9","modified":1703683808993},{"_id":"public/js/app.js","hash":"965c3befaa26a06484204b34f20b8770e186866a","modified":1703683808993},{"_id":"public/js/copy-codeblock.js","hash":"51f1b526133258db1080826574c50a683a34c559","modified":1703683808993},{"_id":"public/lib/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1703683808993},{"_id":"public/preset/plain.css","hash":"368322b6cc3b448ed92d2cadd0fb3abc421d8ab4","modified":1703683808993},{"_id":"public/lib/iconfont/demo_index.html","hash":"df3f126af2695d3dd839edcfda49b951b02f701e","modified":1703683808993},{"_id":"public/lib/iconfont/iconfont.css","hash":"01952f8f10c716cbb463b589a345e46f1b8cc101","modified":1703683808993},{"_id":"public/lib/iconfont/iconfont.json","hash":"8fbdca1d1886c8c6d9bfe1fb105595c65050a175","modified":1703683808993},{"_id":"public/lib/iconfont/iconfont.js","hash":"a536d4780220f9cd7fc5126d9ec1108b19afb6b9","modified":1703683808993},{"_id":"public/lib/fancybox/fancybox.css","hash":"cbce0cfc36f47e30e9c9824875f0b854a05f1916","modified":1703683808993},{"_id":"public/lib/fancybox/fancybox.umd.js","hash":"f2126b3e96721606a2ba20e0f148404814262171","modified":1703683808993},{"_id":"public/lib/mdui_043tiny/mdui.js","hash":"0bd653abb12272e4ed2122dbdc8ca1c2b140a363","modified":1703683808993},{"_id":"public/lib/mdui_043tiny/mdui.css","hash":"b79ef94d2b11f8ce05ba048f5d74a3bd09f12e4d","modified":1703683808993},{"_id":"public/assets/avatar.jpg","hash":"ea162a5ead04cff7d16681398cf27e2ec1af9fe6","modified":1703683808993},{"_id":"public/assets/Just-a-test/Cheshire_cat.png","hash":"aeaa47778394fa2d283318fdb79fc1670d1f938f","modified":1703683808993},{"_id":"public/assets/yyx.jpg","hash":"25ef158ee1e2ed631b98cd933ee304ed234aa1c2","modified":1703683808993},{"_id":"public/assets/bg.png","hash":"52b779ec4d77e92bb77432b36f2a165e6d2ab117","modified":1703683808993},{"_id":"source/PY.md","hash":"e1865bd8ef3ed9e01e51c0be1ae32a9fd10c1641","modified":1703683833145},{"_id":"public/PY.html","hash":"88da83ed0379f1a945e7ee1009716c86fa5a41e3","modified":1703683841130},{"_id":"source/assets/blogs/Just-a-test/Cheshire_cat.png","hash":"aeaa47778394fa2d283318fdb79fc1670d1f938f","modified":1701586518000},{"_id":"source/assets/friends/yyx.jpg","hash":"25ef158ee1e2ed631b98cd933ee304ed234aa1c2","modified":1703683459981},{"_id":"public/assets/blogs/Just-a-test/Cheshire_cat.png","hash":"aeaa47778394fa2d283318fdb79fc1670d1f938f","modified":1703689300518},{"_id":"public/assets/friends/yyx.jpg","hash":"25ef158ee1e2ed631b98cd933ee304ed234aa1c2","modified":1703689300518},{"_id":"source/about.md","hash":"a99989ca3926b4b82652ed8162d05f431694781c","modified":1703746068574},{"_id":"source/assets/about/cover.png","hash":"0cc6c07f03cccedc76f0ee4c0c45d5d789513dab","modified":1703740826085},{"_id":"public/about.html","hash":"ec71a302d75b9a482ef3de0f32a5b9b22bfe590c","modified":1717423722562},{"_id":"public/assets/about/cover.png","hash":"0cc6c07f03cccedc76f0ee4c0c45d5d789513dab","modified":1703741186169},{"_id":"source/favicon.png","hash":"0c68ac3b1b2f01e224a9ceafbd3f9ab0c0e88dd7","modified":1703743958272},{"_id":"public/favicon.png","hash":"0c68ac3b1b2f01e224a9ceafbd3f9ab0c0e88dd7","modified":1703744035737},{"_id":"source/assets/favicon.png","hash":"0c68ac3b1b2f01e224a9ceafbd3f9ab0c0e88dd7","modified":1703743958272},{"_id":"public/assets/favicon.png","hash":"0c68ac3b1b2f01e224a9ceafbd3f9ab0c0e88dd7","modified":1703744530447},{"_id":"source/assets/favicon.ico","hash":"fb8b9925147a656644fa2dabc5b38bae71b5113f","modified":1703747003208},{"_id":"public/assets/favicon.ico","hash":"fb8b9925147a656644fa2dabc5b38bae71b5113f","modified":1703747024074},{"_id":"source/assets/friends/lyh.jpg","hash":"45b0b6fb5699570ed2991474c9a8e37ab9b4960a","modified":1703748461899},{"_id":"source/assets/friends/qurser.jpg","hash":"6af953afba1f26c44239b4ea3badc04282275a96","modified":1703748434381},{"_id":"public/assets/friends/lyh.jpg","hash":"45b0b6fb5699570ed2991474c9a8e37ab9b4960a","modified":1703748575691},{"_id":"public/assets/friends/qurser.jpg","hash":"6af953afba1f26c44239b4ea3badc04282275a96","modified":1703748575691},{"_id":"public/tags/Test/index.html","hash":"2a6277b251ec27736e3a74afefc3c848e8319559","modified":1717423722562},{"_id":"public/tags/Cheshire-Cat/index.html","hash":"e47fd0ee655af199ef8a0de7a77e66fde4852575","modified":1717423722562},{"_id":"public/categories/Categories/index.html","hash":"c501c8eb22cf0697c2618c4c1a3c4b3c59dcf1b7","modified":1703834996672},{"_id":"public/categories/Categories/Test/index.html","hash":"ff677a1b962743f061c95960115509ced2c50383","modified":1703834996672},{"_id":"public/categories/Categories/Test/Cheshire-Cat/index.html","hash":"5cf46d5cf070cd4f6af6e558bf851b816fd67a1d","modified":1703834996672},{"_id":"public/tags/Tag/index.html","hash":"e24a6a4850cba10803602911186d8bdc3e434370","modified":1703834996672},{"_id":"source/_posts/尝试说明一下BiliTools.md","hash":"cff57e9e63bfa2e0b366e426dc97cbf8ad8bee58","modified":1703877767723},{"_id":"public/2023/12/29/尝试说明一下BiliTools/index.html","hash":"4bdfda0dab6ecc9d9d6c546f39401427ff9ef0aa","modified":1703877777845},{"_id":"public/categories/Program/index.html","hash":"86f68576e8be91833aea47cc45bbb423519feca3","modified":1717423722562},{"_id":"public/tags/Bilibili/index.html","hash":"4d299fea95d9c940c73046998d07cbaec15dcbc6","modified":1717423722562},{"_id":"public/categories/Test/index.html","hash":"4dc0a724b7272942762928214631d31688fea987","modified":1717423722562},{"_id":"public/tags/Python/index.html","hash":"18306de078b71c559f05e897fe3f6d145944d4b8","modified":1717423722562},{"_id":"source/_posts/Try-to-introduce-my-BiliTools.md","hash":"3750e93f86c454496183805f6aaac367e73d7c19","modified":1707376510818},{"_id":"public/2023/12/29/Try-to-introduce-my-BiliTools/index.html","hash":"070fdc5aac6fa1d34d6f93744797a516fd2b935e","modified":1717423722562},{"_id":"public/tags/Tkinter/index.html","hash":"f6ac2ae3ad329405936b871712a1dc0f7c8ee181","modified":1717423722562},{"_id":"source/assets/blogs/BiliTools-introduction/plot_shower.png","hash":"f0411945393db240c3200ceb48da3afb9e20b2c0","modified":1704022698971},{"_id":"source/assets/blogs/BiliTools-introduction/plot_shower_failed.png","hash":"f93776f83d398c09e9867ea58b9b737f5ce63917","modified":1704032112135},{"_id":"public/assets/blogs/BiliTools-introduction/plot_shower.png","hash":"f0411945393db240c3200ceb48da3afb9e20b2c0","modified":1704032421240},{"_id":"public/assets/blogs/BiliTools-introduction/plot_shower_failed.png","hash":"f93776f83d398c09e9867ea58b9b737f5ce63917","modified":1704032421240},{"_id":"source/_posts/Try-to-introduce-my-MiraiChan.md","hash":"7f44e64c2af1b9e808d3aed09a953b78280e3911","modified":1712315383571},{"_id":"public/2024/02/08/Try-to-introduce-my-MiraiChan/index.html","hash":"e66063376ba7fc86dbad60478a1fd2d06f7e7cbd","modified":1717423722562},{"_id":"public/archives/2024/index.html","hash":"8b80715611c057f9d73c05045bbcee087790b24f","modified":1717423722562},{"_id":"public/archives/2024/02/index.html","hash":"4c58e6aaf23883348c00017c6315a31001d7e8df","modified":1717423722562},{"_id":"public/tags/onebot/index.html","hash":"094eb562f0d1612dd2fbc813f5320008f5d8dc62","modified":1717423722562},{"_id":"public/tags/QQ/index.html","hash":"aa6401f3e7d271ea4282b130021f52984fabe54c","modified":1717423722562},{"_id":"public/tags/shamrock/index.html","hash":"07428a73ef833eff8dbc0c43b36eb7ca004cb682","modified":1717423722562},{"_id":"source/CNAME","hash":"a4c551c5e5e3ab8f271c6a2d57839bbda3cf33a2","modified":1707395311165},{"_id":"public/CNAME","hash":"a4c551c5e5e3ab8f271c6a2d57839bbda3cf33a2","modified":1707395316814},{"_id":"source/_posts/Discrete_math_shortest_path_algorithms.md","hash":"cdcb06a82177613f3b293c463eb54fd270ad4fd2","modified":1717423707369},{"_id":"source/assets/blogs/discrete_math_graphs_algos/Bellman–Ford_algorithm_example.gif","hash":"1d25d5a1de65690030b6dbd57c37107aa1191637","modified":1717423048633},{"_id":"source/assets/blogs/discrete_math_graphs_algos/Dijkstra_Animation.gif","hash":"e6c1e1b8c4555508d90f08cc76b283c0be358fc9","modified":1717423060058},{"_id":"public/2024/06/03/Discrete_math_shortest_path_algorithms/index.html","hash":"3ef7177b4e4370d946e15e404533b49964ba47bb","modified":1717423722562},{"_id":"public/archives/2024/06/index.html","hash":"4276eda7fcdc31175a18c910226584f8c4b7c86c","modified":1717423722562},{"_id":"public/assets/blogs/discrete_math_graphs_algos/Dijkstra_Animation.gif","hash":"e6c1e1b8c4555508d90f08cc76b283c0be358fc9","modified":1717423254060},{"_id":"public/assets/blogs/discrete_math_graphs_algos/Bellman–Ford_algorithm_example.gif","hash":"1d25d5a1de65690030b6dbd57c37107aa1191637","modified":1717423254060},{"_id":"public/tags/Algorithm/index.html","hash":"b1f4affcb58270cfef455bbacded408d5397d583","modified":1717423722562},{"_id":"public/tags/Discrete-Math/index.html","hash":"d28269e00b7d256a7f5e767a09af3970e40df507","modified":1717423722562},{"_id":"public/categories/Algorithm/index.html","hash":"6201f6b0d7fd50ff9ac2a86eaa5141cf63e081ac","modified":1717423722562}],"Category":[{"name":"Categories","_id":"clqqbcz720000tco10k5kb8tt"},{"name":"Test","parent":"clqqbcz720000tco10k5kb8tt","_id":"clqqbcz730003tco1e8rk0kl5"},{"name":"Cheshire Cat","parent":"clqqbcz730003tco1e8rk0kl5","_id":"clqqbcz730004tco18ot4gal6"},{"name":"Categories Test","_id":"clqqbdztp0000doo117sydu8x"},{"name":"Test","parent":"clqqbdztp0000doo117sydu8x","_id":"clqqbdztq0003doo13qjr5i6c"},{"name":"Cheshire Cat","parent":"clqqbdztq0003doo13qjr5i6c","_id":"clqqbdztq0004doo15e6y1bzc"},{"name":"Program","_id":"clqqfd3ue0001jco1dyik3wnc"},{"name":"Test","_id":"clqqfd3uf0003jco1azbe5r3n"},{"name":"Algorithm","_id":"clwz1pgx3000038o1a6xhea18"}],"Data":[],"Page":[{"_content":":root {\n    --gutter: 25px;\n    --radius: 13px;\n    --color-primary: #66ccff; \n    --color2: #35c9bb; \n    --color3: #ffb900; \n    --color4: #33d57a; \n    --color5: #00dbff; \n    --color6: #1a98ff; \n    --color7: #9090ff; \n    --color-primary-bg: rgba(102, 204, 255, 0.15); \n    --color2-bg: rgba(53, 201, 187, 0.15); \n    --color3-bg: rgba(255,185,0,0.15); \n    --color4-bg: rgba(51,213,122,0.15); \n    --color5-bg: rgba(0,219,255,0.15); \n    --color6-bg: rgba(26,152,255,0.15); \n    --color7-bg: rgba(144,144,255,0.15); \n    --color-shadow: rgba(161, 177, 204, 0.4); \n}\n","source":"custom.css","raw":":root {\n    --gutter: 25px;\n    --radius: 13px;\n    --color-primary: #66ccff; \n    --color2: #35c9bb; \n    --color3: #ffb900; \n    --color4: #33d57a; \n    --color5: #00dbff; \n    --color6: #1a98ff; \n    --color7: #9090ff; \n    --color-primary-bg: rgba(102, 204, 255, 0.15); \n    --color2-bg: rgba(53, 201, 187, 0.15); \n    --color3-bg: rgba(255,185,0,0.15); \n    --color4-bg: rgba(51,213,122,0.15); \n    --color5-bg: rgba(0,219,255,0.15); \n    --color6-bg: rgba(26,152,255,0.15); \n    --color7-bg: rgba(144,144,255,0.15); \n    --color-shadow: rgba(161, 177, 204, 0.4); \n}\n","date":"2023-12-28T04:32:15.894Z","updated":"2023-12-28T04:32:15.894Z","path":"custom.css","layout":"false","_id":"clqntcox20000z4o142ga60bz","title":"","comments":1,"content":":root {\n    --gutter: 25px;\n    --radius: 13px;\n    --color-primary: #66ccff; \n    --color2: #35c9bb; \n    --color3: #ffb900; \n    --color4: #33d57a; \n    --color5: #00dbff; \n    --color6: #1a98ff; \n    --color7: #9090ff; \n    --color-primary-bg: rgba(102, 204, 255, 0.15); \n    --color2-bg: rgba(53, 201, 187, 0.15); \n    --color3-bg: rgba(255,185,0,0.15); \n    --color4-bg: rgba(51,213,122,0.15); \n    --color5-bg: rgba(0,219,255,0.15); \n    --color6-bg: rgba(26,152,255,0.15); \n    --color7-bg: rgba(144,144,255,0.15); \n    --color-shadow: rgba(161, 177, 204, 0.4); \n}\n"},{"title":"文章归档","layout":"archives","_content":"\n","source":"archive.md","raw":"---\ntitle: 文章归档\nlayout: archives\n---\n\n","date":"2023-12-27T13:29:47.459Z","updated":"2023-12-27T13:28:23.464Z","path":"archive.html","comments":1,"_id":"clqntcox40001z4o1dvd6dirl","content":"","excerpt":"","more":""},{"title":"朋友们","layout":"py","_content":"\n## 朋友们\n\n{% links shuffle %}\n[\n {\n  \"title\": \"清影转绝\",\n  \"link\": \"https://space.bilibili.com/284872525/\",\n  \"img\": \"/assets/friends/yyx.jpg\",\n  \"des\": \"是风丸厨头子\"\n },\n {\n  \"title\": \"风总会有停止的时候\",\n  \"link\": \"https://space.bilibili.com/382138819/\",\n  \"img\": \"/assets/friends/lyh.jpg\",\n  \"des\": \"事homo\"\n },\n {\n  \"title\": \"Qurser\",\n  \"link\": \"https://space.bilibili.com/349784654/\",\n  \"img\": \"/assets/friends/qurser.jpg\",\n  \"des\": \"\"\n }\n]\n{% endlinks %}","source":"friends.md","raw":"---\ntitle: 朋友们\nlayout: py\n---\n\n## 朋友们\n\n{% links shuffle %}\n[\n {\n  \"title\": \"清影转绝\",\n  \"link\": \"https://space.bilibili.com/284872525/\",\n  \"img\": \"/assets/friends/yyx.jpg\",\n  \"des\": \"是风丸厨头子\"\n },\n {\n  \"title\": \"风总会有停止的时候\",\n  \"link\": \"https://space.bilibili.com/382138819/\",\n  \"img\": \"/assets/friends/lyh.jpg\",\n  \"des\": \"事homo\"\n },\n {\n  \"title\": \"Qurser\",\n  \"link\": \"https://space.bilibili.com/349784654/\",\n  \"img\": \"/assets/friends/qurser.jpg\",\n  \"des\": \"\"\n }\n]\n{% endlinks %}","date":"2023-12-28T07:30:03.571Z","updated":"2023-12-28T07:30:03.571Z","path":"friends.html","_id":"clqntmvvz0000vgo17i8khx1i","comments":1,"content":"<h2 id=\"朋友们\"><a href=\"#朋友们\" class=\"headerlink\" title=\"朋友们\"></a>朋友们</h2><div class=\"nexmoe-py\"><ul>\n\t\t\t\t<li >\n\t\t\t\t\t<a target=\"_blank\" href=\"https://space.bilibili.com/349784654/\" title=\"Qurser\">\n\t\t\t\t\t\t<img onerror=\"imgOnError(this);\" data-fancybox=\"gallery\" src=\"/assets/friends/qurser.jpg\" alt=\"Qurser\" data-caption=\"Qurser\" loading=\"lazy\">\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t\t<li mdui-tooltip=\"{content: '是风丸厨头子'}\">\n\t\t\t\t\t<a target=\"_blank\" href=\"https://space.bilibili.com/284872525/\" title=\"清影转绝\">\n\t\t\t\t\t\t<img onerror=\"imgOnError(this);\" data-fancybox=\"gallery\" src=\"/assets/friends/yyx.jpg\" alt=\"清影转绝\" data-caption=\"清影转绝\" loading=\"lazy\">\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t\t<li mdui-tooltip=\"{content: '事homo'}\">\n\t\t\t\t\t<a target=\"_blank\" href=\"https://space.bilibili.com/382138819/\" title=\"风总会有停止的时候\">\n\t\t\t\t\t\t<img onerror=\"imgOnError(this);\" data-fancybox=\"gallery\" src=\"/assets/friends/lyh.jpg\" alt=\"风总会有停止的时候\" data-caption=\"风总会有停止的时候\" loading=\"lazy\">\n\t\t\t\t\t</a>\n\t\t\t\t</li></ul></div>","excerpt":"","more":"<h2 id=\"朋友们\"><a href=\"#朋友们\" class=\"headerlink\" title=\"朋友们\"></a>朋友们</h2><div class=\"nexmoe-py\"><ul>\n\t\t\t\t<li >\n\t\t\t\t\t<a target=\"_blank\" href=\"https://space.bilibili.com/349784654/\" title=\"Qurser\">\n\t\t\t\t\t\t<img src=\"/assets/friends/qurser.jpg\" alt=\"Qurser\" >\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t\t<li mdui-tooltip=\"{content: '是风丸厨头子'}\">\n\t\t\t\t\t<a target=\"_blank\" href=\"https://space.bilibili.com/284872525/\" title=\"清影转绝\">\n\t\t\t\t\t\t<img src=\"/assets/friends/yyx.jpg\" alt=\"清影转绝\" >\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t\t<li mdui-tooltip=\"{content: '事homo'}\">\n\t\t\t\t\t<a target=\"_blank\" href=\"https://space.bilibili.com/382138819/\" title=\"风总会有停止的时候\">\n\t\t\t\t\t\t<img src=\"/assets/friends/lyh.jpg\" alt=\"风总会有停止的时候\" >\n\t\t\t\t\t</a>\n\t\t\t\t</li></ul></div>"},{"title":"关于","cover":"/assets/about/cover.png","coverWidth":2844,"coverHeight":1600,"abbrlink":"about","date":"2023-12-27T16:00:00.000Z","_content":"\n18 岁，事个沙贝\n\nNice to meet you ( •̀ ω •́ )✧\n\n咱目前就读于杭州电子科技~~高等专科学校~~大学\n\n是数学苦手、编程苦手和社交苦手\n\n[头像来源](https://www.pixiv.net/artworks/79501395)\n\n","source":"about.md","raw":"---\ntitle: 关于\ncover: /assets/about/cover.png\ncoverWidth: 2844\ncoverHeight: 1600\nabbrlink: about\ndate: 2023-12-28\n---\n\n18 岁，事个沙贝\n\nNice to meet you ( •̀ ω •́ )✧\n\n咱目前就读于杭州电子科技~~高等专科学校~~大学\n\n是数学苦手、编程苦手和社交苦手\n\n[头像来源](https://www.pixiv.net/artworks/79501395)\n\n","updated":"2023-12-28T06:47:48.574Z","path":"about.html","_id":"clqorihc30000p0o125sw15zx","comments":1,"layout":"page","content":"<p>18 岁，事个沙贝</p>\n<p>Nice to meet you ( •̀ ω •́ )✧</p>\n<p>咱目前就读于杭州电子科技<del>高等专科学校</del>大学</p>\n<p>是数学苦手、编程苦手和社交苦手</p>\n<p><a href=\"https://www.pixiv.net/artworks/79501395\">头像来源</a></p>\n","excerpt":"","more":"<p>18 岁，事个沙贝</p>\n<p>Nice to meet you ( •̀ ω •́ )✧</p>\n<p>咱目前就读于杭州电子科技<del>高等专科学校</del>大学</p>\n<p>是数学苦手、编程苦手和社交苦手</p>\n<p><a href=\"https://www.pixiv.net/artworks/79501395\">头像来源</a></p>\n"}],"Post":[{"title":"Just a test","date":"2023-12-27T11:11:44.000Z","_content":"\nHello bro, this is just a test page.  \n\nIf set properly, a sticker will be displayed below.  \n\n![a sticker](/assets/blogs/Just-a-test/Cheshire_cat.png)\n","source":"_posts/Just-a-test.md","raw":"---\ntitle: Just a test\ndate: 2023-12-27 19:11:44\ntags: [Test, Cheshire Cat]\ncategories: [Test]\n---\n\nHello bro, this is just a test page.  \n\nIf set properly, a sticker will be displayed below.  \n\n![a sticker](/assets/blogs/Just-a-test/Cheshire_cat.png)\n","slug":"Just-a-test","published":1,"updated":"2024-06-03T14:06:29.621Z","_id":"clqntcox80004z4o189cqaq0g","comments":1,"layout":"post","photos":[],"content":"<p>Hello bro, this is just a test page.  </p>\n<p>If set properly, a sticker will be displayed below.  </p>\n<p><img onerror=\"imgOnError(this);\" data-fancybox=\"gallery\" src=\"/assets/blogs/Just-a-test/Cheshire_cat.png\" alt=\"a sticker\" data-caption=\"a sticker\" loading=\"lazy\"></p>\n","excerpt":"","more":"<p>Hello bro, this is just a test page.  </p>\n<p>If set properly, a sticker will be displayed below.  </p>\n<p><img src=\"/assets/blogs/Just-a-test/Cheshire_cat.png\" alt=\"a sticker\"></p>\n"},{"title":"尝试详细介绍一下我的 BiliTools","date":"2023-12-29T07:36:00.000Z","_content":"\n想要介绍一下陪了自己两年多的项目 ~~, 顺便练一下 markdown 语法~~\n\n阅前提示: \n1. 以下内容的措辞可能令人费解, 因为咱在表达方面并没有什么天赋\n2. 以下内容不一定正确或者符合规范, 如果有错误欢迎提出w\n\n# Intro\n\nBiliTools 是我在 2021 年 5 月左右使用 Python 编写的一个用于下载 B 站的各种资源的程序\n\n[项目地址](https://github.com/NingmengLemon/BiliTools)\n\n## 关于版本号\n因为有前身在, 所以版本号直接从 2 开始\n又因为咱的脑子可能有点抽风, 版本号目前都是 v.2.0.0_Dev{实际更新版本数} 这个样子w\n目前更新到了 Dev17 的说, 以下内容都是适用于该版本的\n\n## 关于前身\n前身是由我编写的 BiliDownloader, 其实就是一个 [you-get](https://github.com/soimort/you-get) 的 GUI 而已\n附加了一点针对 B 站的功能, 比如弹幕下载和过滤, 版本号为 1\n\n## 史山注意\n首先最初在写这个程序的时候我还是个若至, 像各种语言规范什么的都不知道\n\n你可以在程序中见到:\n- 随处可见的超长单行\n- 刁钻古怪的调用链\n- (几乎)没有类型标注\n- 稀少的注释与日志\n- 一些不知道在干什么但是删掉就会出 Bug 的代码\n- 各种若至的代码逻辑\n- 各种花里胡哨但又一堆 Bug 的功能\n\n然后到现在我稍微懂了那么一点语言规范, 但是先前拉的史已经不好收拾了\n\n有的时候甚至都不想再继续写, 想 remake 一个新程序出来了\n\n这个程序伴随着我的进步, 我的程序水平也在逐渐提升（吗？）\n\n~~所以还是蛮有纪念意义的, 对吧~~\n\n## 感谢\n\n[Bilibili-API-collect](https://github.com/SocialSisterYi/bilibili-API-collect)\n\n[danmaku2ass](https://github.com/m13253/danmaku2ass)\n\n# Quick Overview\n\n## 文件结构\n\n截至 Dev17 的文件结构如下\n```\nBiliTools\n├─ bilitools.py             # 主程序\n├─ basic_window.py          # 提供了(几乎)所有窗口的基类\n├─ bezier_curve.py          # (未使用)用于画贝塞尔曲线的一些基本操作\n├─ configuration.py         # 一些与配置相关的数据与操作\n├─ custom_widgets.py        # 一些自定义的 tk 组件\n├─ danmaku2ass.py           # 修改过的 danmaku2ass\n├─ ffdriver.py              # 用于调用 ffmpeg 的操作\n├─ imglib.py                # 图标们 (以 base64 方式编码的 png)\n├─ textlib.py               # Tips 和 About 文本\n├─ videoshot_handler.py     # 提供了用于处理视频快照的一个类\n└─ biliapis                 # 封装了一些 B 站的 API, 大多取自 bilibili-api-collect\n     ├─ __init__.py         # 用于统领起这个 API 库, 定义了一些杂七杂八的操作\n     ├─ requester.py        # 用于请求的模块\n     ├─ error.py            # 定义了错误类\n     ├─ bilicodes.py        # 各种常用的标识码\n     ├─ wbi.py              # WBI 鉴权\n     ├─ article.py          # 专栏相关\n     ├─ audio.py            # 音频相关\n     ├─ comment.py          # 评论相关\n     ├─ danmaku.py          # 弹幕相关\n     ├─ dynamic.py          # 动态相关\n     ├─ live.py             # 直播相关\n     ├─ login.py            # 登录相关\n     ├─ manga.py            # 漫画相关\n     ├─ media.py            # 影视与番剧相关\n     ├─ stream.py           # 媒体流相关\n     ├─ subtitle.py         # 字幕相关\n     ├─ user.py             # 用户相关\n     ├─ video.py            # 视频相关\n     └─ other.py            # 其他 API\n```\n\n## 依赖\n```\ntkinter         # GUI 库, Python 应该会自带\npillow          # 用于图像处理\nqrcode          # 用于生成二维码\nbeautifulsoup4  # 用于处理 HTML 和 XML\nbrotli          # 用于解压数据\nlxml            # bs4 的依赖\ncolorama        # 用于控制台着色\npycryptodome    # 用于计算 CorrespondPath\n```\n[ffmpeg](https://github.com/FFmpeg/FFmpeg) - 通过管道进行调用, 安装即可\n\n# Go ♂ Deeper\n\n## 各个类间的继承关系\n\n<details><summary>点击展开</summary>\n\n```\nobject\n├─ DownloadManager\n├─ Window\n│   ├─ MainWindow\n│   ├─ BatchWindow\n│   ├─ InputWindow\n│   ├─ ConfigWindow\n│   ├─ AudioWindow\n│   ├─ CommonVideoWindow\n│   ├─ CollectWindow\n│   ├─ LoginWindow\n│   ├─ PbpShower\n│   ├─ PartsChooser\n│   ├─ BlackroomWindow\n│   ├─ BangumiWindow\n│   ├─ MangaViewer_Rolling      (未完工)\n│   ├─ MangaViewer_PageTurning  (未完工)\n│   ├─ SearchWindow\n│   ├─ PlotShower\n│   ├─ VideoShotViewer\n│   ├─ ArticleWindow    (未完工)\n│   ├─ ToviewWindow     (未完工)\n│   └─ Thread_with_gui\n├─ ToolTip\n├─ _CustomMsgbox\n└─ VideoShotHandler\n\ntk.Frame\n└─ VerticalScrolledFrame\n    ├─ _CommonVideoSearchShower\n    └─ _MediaSearchShower\n\nttk.Button\n└─ ImageButton\n\ntk.Label\n└─ ImageLabel\n\ntk.Toplevel\n└─ _TipWindow\n\nException\n└─ BiliError\n\nthreading.Thread\n└─ _DownloadThread\n\n```\n\n</details>\n\n## 多线程的处理\n\n就像其他基于 tk 的应用程序一样, 此程序也以主线程为主\n\n为了处理那些耗时的任务, 自然是需要用到子线程的, 但是子线程没办法直接修改 tk 窗口中的对象, 否则就会导致`thread not in mainloop`错误\n\n于是我在`basic_window.py`中的`Window`基类中定义了一个`task_queue`成员. 这是一个队列, 子线程可以向其中放入无参的函数对象, 而这些函数对象会被位于主线程中的由`Tk.after()`驱动的一个自动循环执行的函数`listen_task`自动取出并在主线程中执行. 此时这个函数是在主线程中被执行的, 就可以直接修改窗口中的对象了.\n\n像这样, 耗时的任务就可以在子线程中执行完毕, 然后把数据装在上述的函数中发送给主线程, 再由这个函数填充到窗口中 (填充的过程其实耗时很少)\n\n<details><summary> 这个基类的多线程控制部分</summary>\n\n```python\nclass Window(object): # 程序中所有常规窗口的父类\n    def __init__(self, ..., toplevel=False, ..., master=None):\n        self.task_queue = queue.Queue() # 此队列用于储存来自子线程的无参函数对象\n        if toplevel or master:\n            self.window = tk.Toplevel(master=master)\n        else:\n            self.window = tk.Tk()\n        ...\n        self.listen_task()\n\n    def listen_task(self):\n        if not self.task_queue.empty():\n            func = self.task_queue.get_nowait()\n            try:\n                func()\n            except Exception as e:\n                logging.error('Task Listener Caught an Error: '+str(e))\n                #raise\n                traceback_info = traceback.format_exc()\n                # print(traceback_info)\n            else:\n                pass\n                #logging.debug(\"Call func: \"+str(func))\n        if self.task_queue.empty():\n            self.window.after(10,self.listen_task)\n        else:\n            self.window.after(1,self.listen_task)\n\n    ...\n```\n> `...`是被省略的部分\n</details>\n\n我通过这种方式来进行多线程协调.\n\n~~听上去还是蛮巧妙的?~~\n\n但是, 把这个方法写在基类中就意味着, 每个窗口创建时都会附带一个队列和一个反复执行的函数. 我不清楚别人是不是这么做的, 反正我当时就这么写了w.\n现在我对这个做法其实不是很满意, 因为我认为这可能消耗了额外的资源 ~~, 多少有些强迫症了~~\n\n## 网络请求的封装\n\n比较让人难绷的是, 我以前把负责网络请求的模块`requester`直接放在了`biliapis`模块中, 我现在觉得这个层次结构不算合理.\n这也就是说, 要想把`biliapis`模块用到别的项目中, 底下的`requester`也会被 copy 一份, 而那个别的项目中可能已经有了别的网络请求模块, 就会造成冗余...\n然后`requester`中封装的`get`与`post`还对返回的流对象做了处理, 把请求过程中创建的`req.Request`对象嗯塞了进去, 这是为了方便`login`模块中对 cookies 的操作. 但也进一步导致了可移植性的下降.\n\n<details><summary>搓程序时候的趣事(?)</summary>\n\nChatGPT 一开始说用`urllib`打开的流中会有`request`这个成员, 但是其实使用 opener 打开的流中并没有, 当时跟 GPT 杠了挺久, 然后 GPT 改口了ww\n\nGPT 最终的答复是:\n\n> `opener.open()`方法返回的`HTTPResponse`对象可能不会附带`request`属性。这是因为`opener.open()`方法是一个高级接口，它隐藏了底层的请求细节，不直接暴露`Request`对象。\n\n</details>\n\n以`get`方法为例, 它的代码如下\n```python\n@auto_retry(retry_time)\ndef get(url, headers=fake_headers_get):\n    req = request.Request(url, headers=headers)\n    response = opener.open(req, None, timeout=timeout)\n    response.request = req      # 强行塞入 request\n    logging.debug('Get: '+url)\n    return response\n```\n<details><summary>我猜你想吐槽...</summary>\n\n> 啊你这个请求怎么没有用`with`啊\n> 这个函数怎么直接就把流对象传回去了啊\n\nemm来看其他部分是怎么用这个函数的:\n```python\ndef get_content_bytes(url, headers=fake_headers_get, update_cookie=True):\n    # 取名有问题, 请自动忽略 content 这个词\n    with get(url, headers=headers) as response:\n        if cookies and update_cookie:\n            cookies.make_cookies(response, response.request)\n        return read_and_decode_data(response)\n        # 取名也有问题, decode 应该改成 decompress\n```\n~~我其实不是很确定用自动重试装饰器来修饰这个函数是不是正确的选择~~\n\n</details>\n\n\n总之就是很不满意 (叉腰)\n\n## 多窗口之间的协作\n\n首先需要提醒的是, 下文提到的`Window`(定义在`basic_window.py`中)继承自`object`, `tk.Tk`或者`tk.Toplevel`对象则被存放在`Window.window`处\n\n~~很令人费解是吧? 我也想问问以前的我为什么要这么写~~\n\n\n我一般会在窗口类(一般继承自`Window`)的`__init__()`方法的末尾加上`self.window.wait_window(self.window)`来使外界在执行实例化窗口类的操作时停在这一步, 直到窗口被释放 (`self.window.destroy()`被执行)\n官方的模块 `tk.messagebox` 和 `tk.filedialog` 中的操作也有类似的逻辑\n\n> 当时的我在`Window`类中直接把上面那个\"停下\"的操作封装成了`self.mainloop()`这个方法, 极具迷惑性.\n> 注意与下文提到的`mainloop`做区别.\n> ~~越写就越想穿越回去抽自己几个大嘴巴子~~\n\n对于大部分不需要在打开窗口的同时打开另一个窗口的窗口是这样.\n至于为什么不用`Tk.mainloop()`来等待窗口, 是因为我发现如果这样做的话, 关闭窗口时会产生一些莫名其妙的问题\n按照我的理解, `Tk.mainloop()`会使整个 tk 的事件循环阻塞主线程; 如果通过`Tk.destroy()`将其打破, tk 会认为整个程序应该结束了, 但其实没有, 这只是一个窗口关闭了而已.\n\n于是我的整个程序里一个`Tk.mainloop()`都没用过w\n\n而除了下载窗口外的所有子窗口(`Toplevel`)的父窗口都是主窗口(`Tk`), 当把主窗口关掉的时候其余窗口就会被自动地关闭.\n至于下载窗口, 它拥有特殊的内部逻辑, 并没有使用等待窗口这一机制.\n\n## 下载器的内部逻辑\n\n这一部分最初于 2021 年 11 月左右完成 (根据写的日志来看)\n~~当时这部分是在自习课上想出来的, 笔记本应该还能找到, 但是放在家里了w~~\n\n**这一部分是线程安全问题的重灾区.**\n中途曾尝试修复过一次, 给涉及到多线程操作的几个列表添加了线程锁. 但是偏偏漏掉了最核心的用于存储原始数据的列表和另外三个用于存放任务状态的列表. \n我最终发现这个遗留问题的时候已经为时已晚. 各个线程锁在之前尝试修复的时候搅成了一坨, 就连继续往上拉史都做不到了, 哪怕只加一个线程锁都会在莫名其妙的地方锁死.\n~~当然如果花时间的话其实还是可以修的, 需要把之前修的地方推掉重来~~\n\n### 显示机制\n\n并不是通过修改窗口属性将构建好的窗口显示或隐藏, 而是到了需要显示的时候才开始构建\n\n当 用于接受下载任务的`task_receiver()`被调用 且 这个函数运行于主线程中 时, `show()`方法会被自动调用\n`show()`方法会执行构建 GUI 的代码, 而`hide()`方法则会直接销毁整个窗口\n由于涉及到 GUI 操作, 上述两个方法都必须在主线程中运行\n\n窗口中显示的的任务信息存储在`table_display_list`这个多维列表中, 每次刷新显示的信息时`auto_refresh_table`这个方法会将它的内容展示到 GUI 中\n\n> `auto_refresh_table`也是借助`Tk.after()`来进行自动循环的\n\n下载器刷新 GUI 的流程:\n\n1. 刷新任务列表\n   - 如果任务数没有变动, 那么直接修改对应项的值\n   - 如果任务数有变动:\n       1. 先记录哪些项被选中了\n       2. 然后删除列表框中的所有项\n       3. 将新的信息填充进去\n       4. 复现先前选中的项\n2. 更新统计信息\n3. 准备下一次自动刷新\n\n### 数据存储与任务管理\n\n最核心的内容是`data_objs`这个成员, 它存储着传入`task_receiver`的原始数据\n下载的各个步骤都会读取\n\n有三个索引列表与它相关\n- `failed_indexes`\n- `running_indexes`\n- `done_indexes`\n\n存放的内容是任务对应的数据在`data_objs`中的索引\n<small>也是在`table_display_list`中的索引</small>\n\n> 我认为下载器中的最关键的一个量就是这个索引\n> 在特化的任务函数中第一个显式参数就是`index`, 说的就是这个索引\n\n感觉逼逼叨叨这么多还不如放张图, 等我...\n\n<details><summary>试着用了 mermaid 语法</summary>\n\n<pre class=\"mermaid\">\nflowchart TB\n\n    F(下载管理器实例化) -- 启动 --> auto_thread_starter\n    \n    subgraph auto_thread_starter\n        direction TB\n    \n        b{检查 task_queue}\n        b -- 有任务 --> c[将任务取出, 作为子线程开始运行]\n        b -- 无任务 --> b\n        c --> b\n    end\n    \n    c -- 启动 --> task_itself\n    \n    subgraph task_itself\n        direction TB\n        g[将参数中的 index 放入 running_indexes]\n        g --> h[任务计数器+1]\n        h --> i[进行任务内容]\n        i --> j[将 index 从 running_indexes 中移除]\n        j --> k{任务是否成功}\n        k -- 是 --> l[将 index 放入 done_indexes]\n        k -- 否 --> m[将 index 放入 failed_indexes]\n        l --> n(任务计数器-1)\n        m --> n\n    end\n\n</pre>\n\n</details>\n\n如果要添加任务, 则遵循下面的流程:\n\n<details><summary>另一个流程图</summary>\n\n<pre class=\"mermaid\">\nflowchart TB\n    direction TB\n    A(添加任务) --> B[获取到下载所需的数据]\n    B --> C[将任务数据放入 data_objs]\n    C --> D[\n        将对应的任务函数和任务在 data_objs 中的索引和数据包装成 lambda\n        然后放入 task_queue\n        ]\n    D --> E[\n        在 table_display_list 中创建位置\n        <small>任务在两个列表中的索引保持一致</small>\n        ]\n</pre>\n\n</details>\n\n### 下载进度的保存与读取\n\n#### 保存\n\n程序会遍历整个`data_objs`, 从中筛选出还没有成功的任务组成一个列表\n然后将这个列表作为一个临时字典的`objs`键对应的值\n`table_display_list`中对应的项也会被组成列表, 作为这个临时字典的`displaylist`键对应的值\n最后程序会将这个字典保存为 json 文件\n\n上述操作被封装为了`save_progress`这个方法\n这个方法在每次有任务开始或结束的时候都会被调用\n\n#### 读取\n\n首先程序会读取保存的 json 文件, 然后遍历其中的`objs`列表, 按照与`task_receiver`中类似的方法逐个添加任务\n在这个过程中, 除了任务状态文本会被改成`待处理`外, 其余内容将会与保存前保持一致\n\n上述操作被封装为了`load_progress`这个方法\n这个方法在程序启动的时候经过用户确认后会被调用\n\n## Tkinter 中的滚动页面的实现\n\n我最开始定义了一个继承自`tk.Frame`的滚动框架`VerticalScrolledFrame`\n\n在用它展示条漫时我发现它的最大滚动范围在 31000px 左右, 这可能是`canvas`的极限\n\n层次结构是: \nframe > canvas > frame > 页面元素\n\n<pre class=\"mermaid\"> \n\nflowchart LR\n\nsubgraph top_frame\n    subgraph canvas\n        subgraph bottom_frame\n            page_content\n        end\n    end\n    scrollbar[\n        S\n        c\n        r\n        o\n        l\n        l\n        b\n        a\n        r]\nend\n\n</pre>\n\nemm大概长这样, 可能有些夸张了\n\n缺点是需要手动给页面元素绑定鼠标滚动等事件\n纵向滚动条用于控制页面的滚动, 实质上是在控制`canvas`中的里层`frame`的上下移动\n\n这个框架被设计成宽度由内容物的宽度决定, 高度由用户定义\n被用在了`SearchWindow`的`Notebook`的单个分页中\n\n如果需要左右滚动的话也同理了\n加上一些自动调用的代码应该就能实现像橱窗那样的循环展示效果 ~~(虽然我没亲自写过)~~\n\n## 互动视频剧情图展示器的实现\n\n整个剧情图的展示基于`tk.Canvas`画布, 在画布右侧和下方分别加上了纵向滚动条和横向滚动条\n\n最核心的内容是`self.plots`与`self.explored_plot_ids`\n`self.plots`是一个装着(装着字典的列表)的列表, 分层存储着请求到的原始数据\n节点们组成类似于有向图的结构, 像下面这样\n~~一开始我其实是把它当作树来处理的~~\n<pre class=\"mermaid\">\nflowchart TB\n    subgraph self.plots\n        subgraph layer_1\n            plot_1\n        end\n        subgraph layer_2\n            plot_2\n            plot_3\n            plot_4\n        end\n        subgraph layer_3\n            plot_5\n            plot_6\n        end\n    end\n\n    plot_1 --> plot_2\n    plot_1 --> plot_3\n    plot_1 --> plot_4\n    \n    plot_2 --> plot_5\n    plot_2 --> plot_6\n    \n    plot_3 --> plot_5\n    \n    plot_4 --> plot_5\n    \n    plot_6 --> plot_2\n</pre>\n<small><del>我超这个`mermaid`的牛魔绘图啊</del></small>\n分层是为了更有层次地绘图\n\n各个节点之间的连接由每个节点数据中包含的多个`jump_edge_id`确定\n\n为了方便画图, 引入了`self.explored_plot_ids`, `self.plot_coors`\n`self.explored_plot_ids`是一个字典, 以`节点id: (节点所在的层的索引, 节点在层中的索引)`的形式存储节点id到节点数据的映射\n`self.plot_coors`是一个字典, 以`节点id: (节点在画布中的x坐标, y坐标, 节点块的宽, 节点块的高)`的形式存储节点id到节点块在画布中的位置的映射\n\n为了方便下载, 引入了`self.cid_map`和`self.avid_map`这两个字典\n它们分别存储节点id到cid的映射和cid到avid的映射\n\n### 节点的探索\n\n互动视频有两个重要的id, 剧情图id`graph_id` 和 节点id`edge_id`\n剧情图id代表这个互动视频, 节点id代表它的节点\n> 剧情图id可以通过向[这个接口](api.bilibili.com/x/player/v2)提交互动视频的`cid`和(`avid`或`bvid`)得到\n\n> 每个节点id都有对应的`cid`, 配合互动视频的`bvid`或`avid`可以取到视频的流\n> 初始节点的`cid`就是这个互动视频的`cid`\n> <small>其实互动视频的节点就是另一种形式的视频分P</small>\n\n> 对接口的节点id参数传入`0`就可以获得初始节点的数据\n\n借由初始节点的数据, 可以得到它可能跳转到的节点们的id\n再请求这些节点id的数据, 获得它们可能跳转到的节点们的id\n就这么一直下去, 直到不再有新的节点id出现\n> 如果一个节点没有跳转到的节点, 就说明它是终止节点\n\n将每一轮上述操作获得的数据按轮分层 <small>(初始节点单独一层)</small>, 就完成了节点探索的操作\n\n### 节点的绘制\n\n<details><summary>先看效果()</summary>\n\n目标视频: [电棍家中的惨案](https://www.bilibili.com/video/BV1Pt4y1S7Wb/)\n\n![Plot_Shower](/assets/blogs/BiliTools-introduction/plot_shower.png)\n\n起始节点被涂成淡红色, 终止节点被涂成淡绿色\n\n</details>\n\n遍历整个`self.plots`, 为每个节点绘制块, 然后为每个节点绘制跳转箭头\n- 如果节点跳转到的是下一层的节点, 那么直接连接即可 <small><del>原本想用贝塞尔曲线来连接的, 然后寄了</del></small>\n- 否则则将箭头拉到画布顶部或底部, 绕到目标块所在层的后面进行连接(跳连)\n\n设置了一些偏移值来确保箭头的线不会重合.\n<small>(但是对于一些关系复杂的互动视频, 上述策略会造成跳连的箭头太多, 导致绘图非常混乱, 完全没法读)</small>\n\n<details><summary>翻车了</summary>\n\n目标视频: [收养澄闪](https://www.bilibili.com/video/BV1eq4y1e7QF/)\n\n![Plot_Shower_failed](/assets/blogs/BiliTools-introduction/plot_shower_failed.png)\n\n~~视频做得太好导致的~~\n\n</details>\n\n以后可能会做一个生成`mermaid`流程图的功能? ~~(画饼ing)~~\n\n总之这玩意真就图一乐\n\n### 交互\n\n#### 点击\n\n我想实现`当点击一个节点块的时候, 打开侧边栏并在其中展示这个节点的信息`这个交互逻辑\n\n首先来实现点击绘图对象罢.\n<small>`tk.Canvas`其实是可以为其中的绘图对象绑定点击事件的, 但我当时不知道w</small>\n我给整个 canvas 绑定了一个点击事件, 根据坐标来判断被点击的节点块\n\n所谓的侧边栏, 是另一个隐藏在右边的框架\n当它要显示的时候, canvas 的宽度会减小侧边栏的宽度那么多, 然后侧边栏框架出现\n\n值得注意的是, 我已经发现了超出 canvas 范围的的强制滚动会使我的点击事件错位这个问题, 我会在后续将它修复\n\n~~简称: 下次一定~~\n\n#### 拖动\n\n<small>写到这里的时候发现我之前写的拖动操作寄了</small>\n\n~~那么今天的内容就到这里了让我们下次再见~~\n\n# Defects\n\n## 线程安全问题\n\n这个问题在 [下载器的内部逻辑](#下载器的内部逻辑) 这部分有提到\n\n大概就是, 如果有多个线程*同时*操作一个*线程不安全*的对象, 就可能会出问题\nPython 中的字典是线程安全的, 但是列表不是\n\n为了避免这个问题, 可以:\n- 给操作对象加上线程锁, 使同一时间只能有一个线程访问它\n- 换用线程安全的对象来存储信息\n\n上文提到的`修复`, 便是给对象加锁\n~~结果加成了一坨 (恼)~~\n\n## 默认参数评估问题\n\n这个问题潜伏了很久, 直到在我使用`custom_widgets`中的`run_with_gui`这个函数的时候才被发现\n\n<details><summary>发现的过程</summary>\n\n程序第一次调用`run_with_gui`时, `is_progress_hook_available`这个参数被传入了`True`.\n这会使这个函数传入的`func`参数(这是一个函数)在后续的过程中被*额外传入*一个叫做`progress_hook`的字典, `func`函数可以通过修改这个字典来汇报任务的进度\n\n问题就在于额外传入这个操作上.\n在老版本的程序中, 程序在准备阶段会直接修改先前传入的`kwargs`, 以便后续方便地使用`func(**kwargs)`来传入参数.\n而我将`kwargs`的默认参数设定为了`{}`, 而不是`None`.\n\n第二次调用的时候到了, 这次`is_progress_hook_available`这个参数被传入了默认的`False`(这倒不是问题的所在), 按照程序的设计, `kwargs`不会被修改. 比较巧合的是, 第一次传入的函数只有`progress_hook`这一个参数, 而第二次的函数则是无参的, 两次调用的`kwargs`这个参数都没有被指定.\n这就导致了后文所说的默认参数评估的问题.\n\n> <font color=red face=consolas>TypeError: self.func() got an unexpected keyword argument 'progress_hook'</font>\n\n~~解释器: Aughhhhhhhhh~~\n\n</details>\n\n虽然我自主地修复了这个问题, 并且知道它导致的问题是前一次调用影响到了后一次, 但以我的水平无法解释它的成因\n\n有请: GPT 先生!\n> 在Python中，函数的默认参数如果设置为字典（或其他可变数据类型，如列表、集合等），会有一个潜在的陷阱：如果默认参数在函数内部被修改了，那么这个修改会在未来的函数调用中持续存在。这是因为默认参数只会在函数定义时被评估一次，不是每次调用时都评估。这意味着，如果你修改了默认参数的内容，那么下一次调用函数时，默认参数的值不再是定义函数时指定的原始值。\n> 这个行为对于不可变的默认值（例如None、整数、字符串等）通常不会导致问题，因为它们不会被函数调用所改变。然而，对于可变的默认值（例如字典、列表等），这种行为可能导致意外的副作用，因为如果函数内部修改了这些可变对象，这些修改会影响到下一次函数调用时这些默认参数的状态。\n\n<details><summary>ChatGPT 举的例子</summary>\n\n以一个列表作为默认参数的函数为例，来展示这个评估过程：\n\n```python\ndef append_to_list(value, my_list=[]):  # 默认参数在这里被评估一次\n    my_list.append(value)\n    return my_list\n```\n\n在这个例子中，`my_list=[]` 是一个默认参数。这个默认参数的列表对象在函数定义时创建，并且只创建一次。如果你在函数内部修改了 `my_list`，比如通过调用 `append_to_list` 函数，那么你实际上是在修改这个单一的、在函数定义时创建的列表对象。这样，下一次调用 `append_to_list` 时，你将看到上一次调用的结果仍然保留在列表中，因为它是同一个列表对象。\n\n为了避免这种情况，你应该使用一个不可变的默认值，比如 `None`，然后在函数内部检查它，并在需要时创建一个新的列表：\n\n```python\ndef append_to_list(value, my_list=None):\n    if my_list is None:\n        my_list = []  # 在这里为每次调用创建一个新的列表\n    my_list.append(value)\n    return my_list\n```\n\n在这个修正后的版本中，每次调用 `append_to_list` 时，如果没有提供 `my_list` 参数，就会创建一个新的空列表。这样，每次函数调用都是独立的，不会有意外的共享状态。\n\n</details>\n\nBiliTools 中的很多函数都被我像这样写了, 比如这个:\n\n```python\ndef _video_download_thread(self, ..., subtitle_regulation=config['download']['video']['subtitle_lang_regulation'], ...):\n    ...\n```\n\n这些问题目前还没有得到修复...\n~~绝对不是因为我忘了! 我回头就去修!~~\n\n## 其他问题\n\n> 未完待续...","source":"_posts/Try-to-introduce-my-BiliTools.md","raw":"---\ntitle: 尝试详细介绍一下我的 BiliTools\ndate: 2023-12-29 15:36:00\ntags: [Bilibili, Python, Tkinter]\ncategories: [Program]\n---\n\n想要介绍一下陪了自己两年多的项目 ~~, 顺便练一下 markdown 语法~~\n\n阅前提示: \n1. 以下内容的措辞可能令人费解, 因为咱在表达方面并没有什么天赋\n2. 以下内容不一定正确或者符合规范, 如果有错误欢迎提出w\n\n# Intro\n\nBiliTools 是我在 2021 年 5 月左右使用 Python 编写的一个用于下载 B 站的各种资源的程序\n\n[项目地址](https://github.com/NingmengLemon/BiliTools)\n\n## 关于版本号\n因为有前身在, 所以版本号直接从 2 开始\n又因为咱的脑子可能有点抽风, 版本号目前都是 v.2.0.0_Dev{实际更新版本数} 这个样子w\n目前更新到了 Dev17 的说, 以下内容都是适用于该版本的\n\n## 关于前身\n前身是由我编写的 BiliDownloader, 其实就是一个 [you-get](https://github.com/soimort/you-get) 的 GUI 而已\n附加了一点针对 B 站的功能, 比如弹幕下载和过滤, 版本号为 1\n\n## 史山注意\n首先最初在写这个程序的时候我还是个若至, 像各种语言规范什么的都不知道\n\n你可以在程序中见到:\n- 随处可见的超长单行\n- 刁钻古怪的调用链\n- (几乎)没有类型标注\n- 稀少的注释与日志\n- 一些不知道在干什么但是删掉就会出 Bug 的代码\n- 各种若至的代码逻辑\n- 各种花里胡哨但又一堆 Bug 的功能\n\n然后到现在我稍微懂了那么一点语言规范, 但是先前拉的史已经不好收拾了\n\n有的时候甚至都不想再继续写, 想 remake 一个新程序出来了\n\n这个程序伴随着我的进步, 我的程序水平也在逐渐提升（吗？）\n\n~~所以还是蛮有纪念意义的, 对吧~~\n\n## 感谢\n\n[Bilibili-API-collect](https://github.com/SocialSisterYi/bilibili-API-collect)\n\n[danmaku2ass](https://github.com/m13253/danmaku2ass)\n\n# Quick Overview\n\n## 文件结构\n\n截至 Dev17 的文件结构如下\n```\nBiliTools\n├─ bilitools.py             # 主程序\n├─ basic_window.py          # 提供了(几乎)所有窗口的基类\n├─ bezier_curve.py          # (未使用)用于画贝塞尔曲线的一些基本操作\n├─ configuration.py         # 一些与配置相关的数据与操作\n├─ custom_widgets.py        # 一些自定义的 tk 组件\n├─ danmaku2ass.py           # 修改过的 danmaku2ass\n├─ ffdriver.py              # 用于调用 ffmpeg 的操作\n├─ imglib.py                # 图标们 (以 base64 方式编码的 png)\n├─ textlib.py               # Tips 和 About 文本\n├─ videoshot_handler.py     # 提供了用于处理视频快照的一个类\n└─ biliapis                 # 封装了一些 B 站的 API, 大多取自 bilibili-api-collect\n     ├─ __init__.py         # 用于统领起这个 API 库, 定义了一些杂七杂八的操作\n     ├─ requester.py        # 用于请求的模块\n     ├─ error.py            # 定义了错误类\n     ├─ bilicodes.py        # 各种常用的标识码\n     ├─ wbi.py              # WBI 鉴权\n     ├─ article.py          # 专栏相关\n     ├─ audio.py            # 音频相关\n     ├─ comment.py          # 评论相关\n     ├─ danmaku.py          # 弹幕相关\n     ├─ dynamic.py          # 动态相关\n     ├─ live.py             # 直播相关\n     ├─ login.py            # 登录相关\n     ├─ manga.py            # 漫画相关\n     ├─ media.py            # 影视与番剧相关\n     ├─ stream.py           # 媒体流相关\n     ├─ subtitle.py         # 字幕相关\n     ├─ user.py             # 用户相关\n     ├─ video.py            # 视频相关\n     └─ other.py            # 其他 API\n```\n\n## 依赖\n```\ntkinter         # GUI 库, Python 应该会自带\npillow          # 用于图像处理\nqrcode          # 用于生成二维码\nbeautifulsoup4  # 用于处理 HTML 和 XML\nbrotli          # 用于解压数据\nlxml            # bs4 的依赖\ncolorama        # 用于控制台着色\npycryptodome    # 用于计算 CorrespondPath\n```\n[ffmpeg](https://github.com/FFmpeg/FFmpeg) - 通过管道进行调用, 安装即可\n\n# Go ♂ Deeper\n\n## 各个类间的继承关系\n\n<details><summary>点击展开</summary>\n\n```\nobject\n├─ DownloadManager\n├─ Window\n│   ├─ MainWindow\n│   ├─ BatchWindow\n│   ├─ InputWindow\n│   ├─ ConfigWindow\n│   ├─ AudioWindow\n│   ├─ CommonVideoWindow\n│   ├─ CollectWindow\n│   ├─ LoginWindow\n│   ├─ PbpShower\n│   ├─ PartsChooser\n│   ├─ BlackroomWindow\n│   ├─ BangumiWindow\n│   ├─ MangaViewer_Rolling      (未完工)\n│   ├─ MangaViewer_PageTurning  (未完工)\n│   ├─ SearchWindow\n│   ├─ PlotShower\n│   ├─ VideoShotViewer\n│   ├─ ArticleWindow    (未完工)\n│   ├─ ToviewWindow     (未完工)\n│   └─ Thread_with_gui\n├─ ToolTip\n├─ _CustomMsgbox\n└─ VideoShotHandler\n\ntk.Frame\n└─ VerticalScrolledFrame\n    ├─ _CommonVideoSearchShower\n    └─ _MediaSearchShower\n\nttk.Button\n└─ ImageButton\n\ntk.Label\n└─ ImageLabel\n\ntk.Toplevel\n└─ _TipWindow\n\nException\n└─ BiliError\n\nthreading.Thread\n└─ _DownloadThread\n\n```\n\n</details>\n\n## 多线程的处理\n\n就像其他基于 tk 的应用程序一样, 此程序也以主线程为主\n\n为了处理那些耗时的任务, 自然是需要用到子线程的, 但是子线程没办法直接修改 tk 窗口中的对象, 否则就会导致`thread not in mainloop`错误\n\n于是我在`basic_window.py`中的`Window`基类中定义了一个`task_queue`成员. 这是一个队列, 子线程可以向其中放入无参的函数对象, 而这些函数对象会被位于主线程中的由`Tk.after()`驱动的一个自动循环执行的函数`listen_task`自动取出并在主线程中执行. 此时这个函数是在主线程中被执行的, 就可以直接修改窗口中的对象了.\n\n像这样, 耗时的任务就可以在子线程中执行完毕, 然后把数据装在上述的函数中发送给主线程, 再由这个函数填充到窗口中 (填充的过程其实耗时很少)\n\n<details><summary> 这个基类的多线程控制部分</summary>\n\n```python\nclass Window(object): # 程序中所有常规窗口的父类\n    def __init__(self, ..., toplevel=False, ..., master=None):\n        self.task_queue = queue.Queue() # 此队列用于储存来自子线程的无参函数对象\n        if toplevel or master:\n            self.window = tk.Toplevel(master=master)\n        else:\n            self.window = tk.Tk()\n        ...\n        self.listen_task()\n\n    def listen_task(self):\n        if not self.task_queue.empty():\n            func = self.task_queue.get_nowait()\n            try:\n                func()\n            except Exception as e:\n                logging.error('Task Listener Caught an Error: '+str(e))\n                #raise\n                traceback_info = traceback.format_exc()\n                # print(traceback_info)\n            else:\n                pass\n                #logging.debug(\"Call func: \"+str(func))\n        if self.task_queue.empty():\n            self.window.after(10,self.listen_task)\n        else:\n            self.window.after(1,self.listen_task)\n\n    ...\n```\n> `...`是被省略的部分\n</details>\n\n我通过这种方式来进行多线程协调.\n\n~~听上去还是蛮巧妙的?~~\n\n但是, 把这个方法写在基类中就意味着, 每个窗口创建时都会附带一个队列和一个反复执行的函数. 我不清楚别人是不是这么做的, 反正我当时就这么写了w.\n现在我对这个做法其实不是很满意, 因为我认为这可能消耗了额外的资源 ~~, 多少有些强迫症了~~\n\n## 网络请求的封装\n\n比较让人难绷的是, 我以前把负责网络请求的模块`requester`直接放在了`biliapis`模块中, 我现在觉得这个层次结构不算合理.\n这也就是说, 要想把`biliapis`模块用到别的项目中, 底下的`requester`也会被 copy 一份, 而那个别的项目中可能已经有了别的网络请求模块, 就会造成冗余...\n然后`requester`中封装的`get`与`post`还对返回的流对象做了处理, 把请求过程中创建的`req.Request`对象嗯塞了进去, 这是为了方便`login`模块中对 cookies 的操作. 但也进一步导致了可移植性的下降.\n\n<details><summary>搓程序时候的趣事(?)</summary>\n\nChatGPT 一开始说用`urllib`打开的流中会有`request`这个成员, 但是其实使用 opener 打开的流中并没有, 当时跟 GPT 杠了挺久, 然后 GPT 改口了ww\n\nGPT 最终的答复是:\n\n> `opener.open()`方法返回的`HTTPResponse`对象可能不会附带`request`属性。这是因为`opener.open()`方法是一个高级接口，它隐藏了底层的请求细节，不直接暴露`Request`对象。\n\n</details>\n\n以`get`方法为例, 它的代码如下\n```python\n@auto_retry(retry_time)\ndef get(url, headers=fake_headers_get):\n    req = request.Request(url, headers=headers)\n    response = opener.open(req, None, timeout=timeout)\n    response.request = req      # 强行塞入 request\n    logging.debug('Get: '+url)\n    return response\n```\n<details><summary>我猜你想吐槽...</summary>\n\n> 啊你这个请求怎么没有用`with`啊\n> 这个函数怎么直接就把流对象传回去了啊\n\nemm来看其他部分是怎么用这个函数的:\n```python\ndef get_content_bytes(url, headers=fake_headers_get, update_cookie=True):\n    # 取名有问题, 请自动忽略 content 这个词\n    with get(url, headers=headers) as response:\n        if cookies and update_cookie:\n            cookies.make_cookies(response, response.request)\n        return read_and_decode_data(response)\n        # 取名也有问题, decode 应该改成 decompress\n```\n~~我其实不是很确定用自动重试装饰器来修饰这个函数是不是正确的选择~~\n\n</details>\n\n\n总之就是很不满意 (叉腰)\n\n## 多窗口之间的协作\n\n首先需要提醒的是, 下文提到的`Window`(定义在`basic_window.py`中)继承自`object`, `tk.Tk`或者`tk.Toplevel`对象则被存放在`Window.window`处\n\n~~很令人费解是吧? 我也想问问以前的我为什么要这么写~~\n\n\n我一般会在窗口类(一般继承自`Window`)的`__init__()`方法的末尾加上`self.window.wait_window(self.window)`来使外界在执行实例化窗口类的操作时停在这一步, 直到窗口被释放 (`self.window.destroy()`被执行)\n官方的模块 `tk.messagebox` 和 `tk.filedialog` 中的操作也有类似的逻辑\n\n> 当时的我在`Window`类中直接把上面那个\"停下\"的操作封装成了`self.mainloop()`这个方法, 极具迷惑性.\n> 注意与下文提到的`mainloop`做区别.\n> ~~越写就越想穿越回去抽自己几个大嘴巴子~~\n\n对于大部分不需要在打开窗口的同时打开另一个窗口的窗口是这样.\n至于为什么不用`Tk.mainloop()`来等待窗口, 是因为我发现如果这样做的话, 关闭窗口时会产生一些莫名其妙的问题\n按照我的理解, `Tk.mainloop()`会使整个 tk 的事件循环阻塞主线程; 如果通过`Tk.destroy()`将其打破, tk 会认为整个程序应该结束了, 但其实没有, 这只是一个窗口关闭了而已.\n\n于是我的整个程序里一个`Tk.mainloop()`都没用过w\n\n而除了下载窗口外的所有子窗口(`Toplevel`)的父窗口都是主窗口(`Tk`), 当把主窗口关掉的时候其余窗口就会被自动地关闭.\n至于下载窗口, 它拥有特殊的内部逻辑, 并没有使用等待窗口这一机制.\n\n## 下载器的内部逻辑\n\n这一部分最初于 2021 年 11 月左右完成 (根据写的日志来看)\n~~当时这部分是在自习课上想出来的, 笔记本应该还能找到, 但是放在家里了w~~\n\n**这一部分是线程安全问题的重灾区.**\n中途曾尝试修复过一次, 给涉及到多线程操作的几个列表添加了线程锁. 但是偏偏漏掉了最核心的用于存储原始数据的列表和另外三个用于存放任务状态的列表. \n我最终发现这个遗留问题的时候已经为时已晚. 各个线程锁在之前尝试修复的时候搅成了一坨, 就连继续往上拉史都做不到了, 哪怕只加一个线程锁都会在莫名其妙的地方锁死.\n~~当然如果花时间的话其实还是可以修的, 需要把之前修的地方推掉重来~~\n\n### 显示机制\n\n并不是通过修改窗口属性将构建好的窗口显示或隐藏, 而是到了需要显示的时候才开始构建\n\n当 用于接受下载任务的`task_receiver()`被调用 且 这个函数运行于主线程中 时, `show()`方法会被自动调用\n`show()`方法会执行构建 GUI 的代码, 而`hide()`方法则会直接销毁整个窗口\n由于涉及到 GUI 操作, 上述两个方法都必须在主线程中运行\n\n窗口中显示的的任务信息存储在`table_display_list`这个多维列表中, 每次刷新显示的信息时`auto_refresh_table`这个方法会将它的内容展示到 GUI 中\n\n> `auto_refresh_table`也是借助`Tk.after()`来进行自动循环的\n\n下载器刷新 GUI 的流程:\n\n1. 刷新任务列表\n   - 如果任务数没有变动, 那么直接修改对应项的值\n   - 如果任务数有变动:\n       1. 先记录哪些项被选中了\n       2. 然后删除列表框中的所有项\n       3. 将新的信息填充进去\n       4. 复现先前选中的项\n2. 更新统计信息\n3. 准备下一次自动刷新\n\n### 数据存储与任务管理\n\n最核心的内容是`data_objs`这个成员, 它存储着传入`task_receiver`的原始数据\n下载的各个步骤都会读取\n\n有三个索引列表与它相关\n- `failed_indexes`\n- `running_indexes`\n- `done_indexes`\n\n存放的内容是任务对应的数据在`data_objs`中的索引\n<small>也是在`table_display_list`中的索引</small>\n\n> 我认为下载器中的最关键的一个量就是这个索引\n> 在特化的任务函数中第一个显式参数就是`index`, 说的就是这个索引\n\n感觉逼逼叨叨这么多还不如放张图, 等我...\n\n<details><summary>试着用了 mermaid 语法</summary>\n\n<pre class=\"mermaid\">\nflowchart TB\n\n    F(下载管理器实例化) -- 启动 --> auto_thread_starter\n    \n    subgraph auto_thread_starter\n        direction TB\n    \n        b{检查 task_queue}\n        b -- 有任务 --> c[将任务取出, 作为子线程开始运行]\n        b -- 无任务 --> b\n        c --> b\n    end\n    \n    c -- 启动 --> task_itself\n    \n    subgraph task_itself\n        direction TB\n        g[将参数中的 index 放入 running_indexes]\n        g --> h[任务计数器+1]\n        h --> i[进行任务内容]\n        i --> j[将 index 从 running_indexes 中移除]\n        j --> k{任务是否成功}\n        k -- 是 --> l[将 index 放入 done_indexes]\n        k -- 否 --> m[将 index 放入 failed_indexes]\n        l --> n(任务计数器-1)\n        m --> n\n    end\n\n</pre>\n\n</details>\n\n如果要添加任务, 则遵循下面的流程:\n\n<details><summary>另一个流程图</summary>\n\n<pre class=\"mermaid\">\nflowchart TB\n    direction TB\n    A(添加任务) --> B[获取到下载所需的数据]\n    B --> C[将任务数据放入 data_objs]\n    C --> D[\n        将对应的任务函数和任务在 data_objs 中的索引和数据包装成 lambda\n        然后放入 task_queue\n        ]\n    D --> E[\n        在 table_display_list 中创建位置\n        <small>任务在两个列表中的索引保持一致</small>\n        ]\n</pre>\n\n</details>\n\n### 下载进度的保存与读取\n\n#### 保存\n\n程序会遍历整个`data_objs`, 从中筛选出还没有成功的任务组成一个列表\n然后将这个列表作为一个临时字典的`objs`键对应的值\n`table_display_list`中对应的项也会被组成列表, 作为这个临时字典的`displaylist`键对应的值\n最后程序会将这个字典保存为 json 文件\n\n上述操作被封装为了`save_progress`这个方法\n这个方法在每次有任务开始或结束的时候都会被调用\n\n#### 读取\n\n首先程序会读取保存的 json 文件, 然后遍历其中的`objs`列表, 按照与`task_receiver`中类似的方法逐个添加任务\n在这个过程中, 除了任务状态文本会被改成`待处理`外, 其余内容将会与保存前保持一致\n\n上述操作被封装为了`load_progress`这个方法\n这个方法在程序启动的时候经过用户确认后会被调用\n\n## Tkinter 中的滚动页面的实现\n\n我最开始定义了一个继承自`tk.Frame`的滚动框架`VerticalScrolledFrame`\n\n在用它展示条漫时我发现它的最大滚动范围在 31000px 左右, 这可能是`canvas`的极限\n\n层次结构是: \nframe > canvas > frame > 页面元素\n\n<pre class=\"mermaid\"> \n\nflowchart LR\n\nsubgraph top_frame\n    subgraph canvas\n        subgraph bottom_frame\n            page_content\n        end\n    end\n    scrollbar[\n        S\n        c\n        r\n        o\n        l\n        l\n        b\n        a\n        r]\nend\n\n</pre>\n\nemm大概长这样, 可能有些夸张了\n\n缺点是需要手动给页面元素绑定鼠标滚动等事件\n纵向滚动条用于控制页面的滚动, 实质上是在控制`canvas`中的里层`frame`的上下移动\n\n这个框架被设计成宽度由内容物的宽度决定, 高度由用户定义\n被用在了`SearchWindow`的`Notebook`的单个分页中\n\n如果需要左右滚动的话也同理了\n加上一些自动调用的代码应该就能实现像橱窗那样的循环展示效果 ~~(虽然我没亲自写过)~~\n\n## 互动视频剧情图展示器的实现\n\n整个剧情图的展示基于`tk.Canvas`画布, 在画布右侧和下方分别加上了纵向滚动条和横向滚动条\n\n最核心的内容是`self.plots`与`self.explored_plot_ids`\n`self.plots`是一个装着(装着字典的列表)的列表, 分层存储着请求到的原始数据\n节点们组成类似于有向图的结构, 像下面这样\n~~一开始我其实是把它当作树来处理的~~\n<pre class=\"mermaid\">\nflowchart TB\n    subgraph self.plots\n        subgraph layer_1\n            plot_1\n        end\n        subgraph layer_2\n            plot_2\n            plot_3\n            plot_4\n        end\n        subgraph layer_3\n            plot_5\n            plot_6\n        end\n    end\n\n    plot_1 --> plot_2\n    plot_1 --> plot_3\n    plot_1 --> plot_4\n    \n    plot_2 --> plot_5\n    plot_2 --> plot_6\n    \n    plot_3 --> plot_5\n    \n    plot_4 --> plot_5\n    \n    plot_6 --> plot_2\n</pre>\n<small><del>我超这个`mermaid`的牛魔绘图啊</del></small>\n分层是为了更有层次地绘图\n\n各个节点之间的连接由每个节点数据中包含的多个`jump_edge_id`确定\n\n为了方便画图, 引入了`self.explored_plot_ids`, `self.plot_coors`\n`self.explored_plot_ids`是一个字典, 以`节点id: (节点所在的层的索引, 节点在层中的索引)`的形式存储节点id到节点数据的映射\n`self.plot_coors`是一个字典, 以`节点id: (节点在画布中的x坐标, y坐标, 节点块的宽, 节点块的高)`的形式存储节点id到节点块在画布中的位置的映射\n\n为了方便下载, 引入了`self.cid_map`和`self.avid_map`这两个字典\n它们分别存储节点id到cid的映射和cid到avid的映射\n\n### 节点的探索\n\n互动视频有两个重要的id, 剧情图id`graph_id` 和 节点id`edge_id`\n剧情图id代表这个互动视频, 节点id代表它的节点\n> 剧情图id可以通过向[这个接口](api.bilibili.com/x/player/v2)提交互动视频的`cid`和(`avid`或`bvid`)得到\n\n> 每个节点id都有对应的`cid`, 配合互动视频的`bvid`或`avid`可以取到视频的流\n> 初始节点的`cid`就是这个互动视频的`cid`\n> <small>其实互动视频的节点就是另一种形式的视频分P</small>\n\n> 对接口的节点id参数传入`0`就可以获得初始节点的数据\n\n借由初始节点的数据, 可以得到它可能跳转到的节点们的id\n再请求这些节点id的数据, 获得它们可能跳转到的节点们的id\n就这么一直下去, 直到不再有新的节点id出现\n> 如果一个节点没有跳转到的节点, 就说明它是终止节点\n\n将每一轮上述操作获得的数据按轮分层 <small>(初始节点单独一层)</small>, 就完成了节点探索的操作\n\n### 节点的绘制\n\n<details><summary>先看效果()</summary>\n\n目标视频: [电棍家中的惨案](https://www.bilibili.com/video/BV1Pt4y1S7Wb/)\n\n![Plot_Shower](/assets/blogs/BiliTools-introduction/plot_shower.png)\n\n起始节点被涂成淡红色, 终止节点被涂成淡绿色\n\n</details>\n\n遍历整个`self.plots`, 为每个节点绘制块, 然后为每个节点绘制跳转箭头\n- 如果节点跳转到的是下一层的节点, 那么直接连接即可 <small><del>原本想用贝塞尔曲线来连接的, 然后寄了</del></small>\n- 否则则将箭头拉到画布顶部或底部, 绕到目标块所在层的后面进行连接(跳连)\n\n设置了一些偏移值来确保箭头的线不会重合.\n<small>(但是对于一些关系复杂的互动视频, 上述策略会造成跳连的箭头太多, 导致绘图非常混乱, 完全没法读)</small>\n\n<details><summary>翻车了</summary>\n\n目标视频: [收养澄闪](https://www.bilibili.com/video/BV1eq4y1e7QF/)\n\n![Plot_Shower_failed](/assets/blogs/BiliTools-introduction/plot_shower_failed.png)\n\n~~视频做得太好导致的~~\n\n</details>\n\n以后可能会做一个生成`mermaid`流程图的功能? ~~(画饼ing)~~\n\n总之这玩意真就图一乐\n\n### 交互\n\n#### 点击\n\n我想实现`当点击一个节点块的时候, 打开侧边栏并在其中展示这个节点的信息`这个交互逻辑\n\n首先来实现点击绘图对象罢.\n<small>`tk.Canvas`其实是可以为其中的绘图对象绑定点击事件的, 但我当时不知道w</small>\n我给整个 canvas 绑定了一个点击事件, 根据坐标来判断被点击的节点块\n\n所谓的侧边栏, 是另一个隐藏在右边的框架\n当它要显示的时候, canvas 的宽度会减小侧边栏的宽度那么多, 然后侧边栏框架出现\n\n值得注意的是, 我已经发现了超出 canvas 范围的的强制滚动会使我的点击事件错位这个问题, 我会在后续将它修复\n\n~~简称: 下次一定~~\n\n#### 拖动\n\n<small>写到这里的时候发现我之前写的拖动操作寄了</small>\n\n~~那么今天的内容就到这里了让我们下次再见~~\n\n# Defects\n\n## 线程安全问题\n\n这个问题在 [下载器的内部逻辑](#下载器的内部逻辑) 这部分有提到\n\n大概就是, 如果有多个线程*同时*操作一个*线程不安全*的对象, 就可能会出问题\nPython 中的字典是线程安全的, 但是列表不是\n\n为了避免这个问题, 可以:\n- 给操作对象加上线程锁, 使同一时间只能有一个线程访问它\n- 换用线程安全的对象来存储信息\n\n上文提到的`修复`, 便是给对象加锁\n~~结果加成了一坨 (恼)~~\n\n## 默认参数评估问题\n\n这个问题潜伏了很久, 直到在我使用`custom_widgets`中的`run_with_gui`这个函数的时候才被发现\n\n<details><summary>发现的过程</summary>\n\n程序第一次调用`run_with_gui`时, `is_progress_hook_available`这个参数被传入了`True`.\n这会使这个函数传入的`func`参数(这是一个函数)在后续的过程中被*额外传入*一个叫做`progress_hook`的字典, `func`函数可以通过修改这个字典来汇报任务的进度\n\n问题就在于额外传入这个操作上.\n在老版本的程序中, 程序在准备阶段会直接修改先前传入的`kwargs`, 以便后续方便地使用`func(**kwargs)`来传入参数.\n而我将`kwargs`的默认参数设定为了`{}`, 而不是`None`.\n\n第二次调用的时候到了, 这次`is_progress_hook_available`这个参数被传入了默认的`False`(这倒不是问题的所在), 按照程序的设计, `kwargs`不会被修改. 比较巧合的是, 第一次传入的函数只有`progress_hook`这一个参数, 而第二次的函数则是无参的, 两次调用的`kwargs`这个参数都没有被指定.\n这就导致了后文所说的默认参数评估的问题.\n\n> <font color=red face=consolas>TypeError: self.func() got an unexpected keyword argument 'progress_hook'</font>\n\n~~解释器: Aughhhhhhhhh~~\n\n</details>\n\n虽然我自主地修复了这个问题, 并且知道它导致的问题是前一次调用影响到了后一次, 但以我的水平无法解释它的成因\n\n有请: GPT 先生!\n> 在Python中，函数的默认参数如果设置为字典（或其他可变数据类型，如列表、集合等），会有一个潜在的陷阱：如果默认参数在函数内部被修改了，那么这个修改会在未来的函数调用中持续存在。这是因为默认参数只会在函数定义时被评估一次，不是每次调用时都评估。这意味着，如果你修改了默认参数的内容，那么下一次调用函数时，默认参数的值不再是定义函数时指定的原始值。\n> 这个行为对于不可变的默认值（例如None、整数、字符串等）通常不会导致问题，因为它们不会被函数调用所改变。然而，对于可变的默认值（例如字典、列表等），这种行为可能导致意外的副作用，因为如果函数内部修改了这些可变对象，这些修改会影响到下一次函数调用时这些默认参数的状态。\n\n<details><summary>ChatGPT 举的例子</summary>\n\n以一个列表作为默认参数的函数为例，来展示这个评估过程：\n\n```python\ndef append_to_list(value, my_list=[]):  # 默认参数在这里被评估一次\n    my_list.append(value)\n    return my_list\n```\n\n在这个例子中，`my_list=[]` 是一个默认参数。这个默认参数的列表对象在函数定义时创建，并且只创建一次。如果你在函数内部修改了 `my_list`，比如通过调用 `append_to_list` 函数，那么你实际上是在修改这个单一的、在函数定义时创建的列表对象。这样，下一次调用 `append_to_list` 时，你将看到上一次调用的结果仍然保留在列表中，因为它是同一个列表对象。\n\n为了避免这种情况，你应该使用一个不可变的默认值，比如 `None`，然后在函数内部检查它，并在需要时创建一个新的列表：\n\n```python\ndef append_to_list(value, my_list=None):\n    if my_list is None:\n        my_list = []  # 在这里为每次调用创建一个新的列表\n    my_list.append(value)\n    return my_list\n```\n\n在这个修正后的版本中，每次调用 `append_to_list` 时，如果没有提供 `my_list` 参数，就会创建一个新的空列表。这样，每次函数调用都是独立的，不会有意外的共享状态。\n\n</details>\n\nBiliTools 中的很多函数都被我像这样写了, 比如这个:\n\n```python\ndef _video_download_thread(self, ..., subtitle_regulation=config['download']['video']['subtitle_lang_regulation'], ...):\n    ...\n```\n\n这些问题目前还没有得到修复...\n~~绝对不是因为我忘了! 我回头就去修!~~\n\n## 其他问题\n\n> 未完待续...","slug":"Try-to-introduce-my-BiliTools","published":1,"updated":"2024-02-08T07:15:10.818Z","_id":"clqr0xnb10000fko1c0z74w7c","comments":1,"layout":"post","photos":[],"content":"<p>想要介绍一下陪了自己两年多的项目 <del>, 顺便练一下 markdown 语法</del></p>\n<p>阅前提示: </p>\n<ol>\n<li>以下内容的措辞可能令人费解, 因为咱在表达方面并没有什么天赋</li>\n<li>以下内容不一定正确或者符合规范, 如果有错误欢迎提出w</li>\n</ol>\n<h1 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h1><p>BiliTools 是我在 2021 年 5 月左右使用 Python 编写的一个用于下载 B 站的各种资源的程序</p>\n<p><a href=\"https://github.com/NingmengLemon/BiliTools\">项目地址</a></p>\n<h2 id=\"关于版本号\"><a href=\"#关于版本号\" class=\"headerlink\" title=\"关于版本号\"></a>关于版本号</h2><p>因为有前身在, 所以版本号直接从 2 开始<br>又因为咱的脑子可能有点抽风, 版本号目前都是 v.2.0.0_Dev{实际更新版本数} 这个样子w<br>目前更新到了 Dev17 的说, 以下内容都是适用于该版本的</p>\n<h2 id=\"关于前身\"><a href=\"#关于前身\" class=\"headerlink\" title=\"关于前身\"></a>关于前身</h2><p>前身是由我编写的 BiliDownloader, 其实就是一个 <a href=\"https://github.com/soimort/you-get\">you-get</a> 的 GUI 而已<br>附加了一点针对 B 站的功能, 比如弹幕下载和过滤, 版本号为 1</p>\n<h2 id=\"史山注意\"><a href=\"#史山注意\" class=\"headerlink\" title=\"史山注意\"></a>史山注意</h2><p>首先最初在写这个程序的时候我还是个若至, 像各种语言规范什么的都不知道</p>\n<p>你可以在程序中见到:</p>\n<ul>\n<li>随处可见的超长单行</li>\n<li>刁钻古怪的调用链</li>\n<li>(几乎)没有类型标注</li>\n<li>稀少的注释与日志</li>\n<li>一些不知道在干什么但是删掉就会出 Bug 的代码</li>\n<li>各种若至的代码逻辑</li>\n<li>各种花里胡哨但又一堆 Bug 的功能</li>\n</ul>\n<p>然后到现在我稍微懂了那么一点语言规范, 但是先前拉的史已经不好收拾了</p>\n<p>有的时候甚至都不想再继续写, 想 remake 一个新程序出来了</p>\n<p>这个程序伴随着我的进步, 我的程序水平也在逐渐提升（吗？）</p>\n<p><del>所以还是蛮有纪念意义的, 对吧</del></p>\n<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"https://github.com/SocialSisterYi/bilibili-API-collect\">Bilibili-API-collect</a></p>\n<p><a href=\"https://github.com/m13253/danmaku2ass\">danmaku2ass</a></p>\n<h1 id=\"Quick-Overview\"><a href=\"#Quick-Overview\" class=\"headerlink\" title=\"Quick Overview\"></a>Quick Overview</h1><h2 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h2><p>截至 Dev17 的文件结构如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">BiliTools<br>├─ bilitools.py             # 主程序<br>├─ basic_window.py          # 提供了(几乎)所有窗口的基类<br>├─ bezier_curve.py          # (未使用)用于画贝塞尔曲线的一些基本操作<br>├─ configuration.py         # 一些与配置相关的数据与操作<br>├─ custom_widgets.py        # 一些自定义的 tk 组件<br>├─ danmaku2ass.py           # 修改过的 danmaku2ass<br>├─ ffdriver.py              # 用于调用 ffmpeg 的操作<br>├─ imglib.py                # 图标们 (以 base64 方式编码的 png)<br>├─ textlib.py               # Tips 和 About 文本<br>├─ videoshot_handler.py     # 提供了用于处理视频快照的一个类<br>└─ biliapis                 # 封装了一些 B 站的 API, 大多取自 bilibili-api-collect<br>     ├─ __init__.py         # 用于统领起这个 API 库, 定义了一些杂七杂八的操作<br>     ├─ requester.py        # 用于请求的模块<br>     ├─ error.py            # 定义了错误类<br>     ├─ bilicodes.py        # 各种常用的标识码<br>     ├─ wbi.py              # WBI 鉴权<br>     ├─ article.py          # 专栏相关<br>     ├─ audio.py            # 音频相关<br>     ├─ comment.py          # 评论相关<br>     ├─ danmaku.py          # 弹幕相关<br>     ├─ dynamic.py          # 动态相关<br>     ├─ live.py             # 直播相关<br>     ├─ login.py            # 登录相关<br>     ├─ manga.py            # 漫画相关<br>     ├─ media.py            # 影视与番剧相关<br>     ├─ stream.py           # 媒体流相关<br>     ├─ subtitle.py         # 字幕相关<br>     ├─ user.py             # 用户相关<br>     ├─ video.py            # 视频相关<br>     └─ other.py            # 其他 API<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">tkinter         # GUI 库, Python 应该会自带<br>pillow          # 用于图像处理<br>qrcode          # 用于生成二维码<br>beautifulsoup4  # 用于处理 HTML 和 XML<br>brotli          # 用于解压数据<br>lxml            # bs4 的依赖<br>colorama        # 用于控制台着色<br>pycryptodome    # 用于计算 CorrespondPath<br></code></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/FFmpeg/FFmpeg\">ffmpeg</a> - 通过管道进行调用, 安装即可</p>\n<h1 id=\"Go-♂-Deeper\"><a href=\"#Go-♂-Deeper\" class=\"headerlink\" title=\"Go ♂ Deeper\"></a>Go ♂ Deeper</h1><h2 id=\"各个类间的继承关系\"><a href=\"#各个类间的继承关系\" class=\"headerlink\" title=\"各个类间的继承关系\"></a>各个类间的继承关系</h2><details><summary>点击展开</summary>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">object<br>├─ DownloadManager<br>├─ Window<br>│   ├─ MainWindow<br>│   ├─ BatchWindow<br>│   ├─ InputWindow<br>│   ├─ ConfigWindow<br>│   ├─ AudioWindow<br>│   ├─ CommonVideoWindow<br>│   ├─ CollectWindow<br>│   ├─ LoginWindow<br>│   ├─ PbpShower<br>│   ├─ PartsChooser<br>│   ├─ BlackroomWindow<br>│   ├─ BangumiWindow<br>│   ├─ MangaViewer_Rolling      (未完工)<br>│   ├─ MangaViewer_PageTurning  (未完工)<br>│   ├─ SearchWindow<br>│   ├─ PlotShower<br>│   ├─ VideoShotViewer<br>│   ├─ ArticleWindow    (未完工)<br>│   ├─ ToviewWindow     (未完工)<br>│   └─ Thread_with_gui<br>├─ ToolTip<br>├─ _CustomMsgbox<br>└─ VideoShotHandler<br><br>tk.Frame<br>└─ VerticalScrolledFrame<br>    ├─ _CommonVideoSearchShower<br>    └─ _MediaSearchShower<br><br>ttk.Button<br>└─ ImageButton<br><br>tk.Label<br>└─ ImageLabel<br><br>tk.Toplevel<br>└─ _TipWindow<br><br>Exception<br>└─ BiliError<br><br>threading.Thread<br>└─ _DownloadThread<br><br></code></pre></td></tr></table></figure>\n\n</details>\n\n<h2 id=\"多线程的处理\"><a href=\"#多线程的处理\" class=\"headerlink\" title=\"多线程的处理\"></a>多线程的处理</h2><p>就像其他基于 tk 的应用程序一样, 此程序也以主线程为主</p>\n<p>为了处理那些耗时的任务, 自然是需要用到子线程的, 但是子线程没办法直接修改 tk 窗口中的对象, 否则就会导致<code>thread not in mainloop</code>错误</p>\n<p>于是我在<code>basic_window.py</code>中的<code>Window</code>基类中定义了一个<code>task_queue</code>成员. 这是一个队列, 子线程可以向其中放入无参的函数对象, 而这些函数对象会被位于主线程中的由<code>Tk.after()</code>驱动的一个自动循环执行的函数<code>listen_task</code>自动取出并在主线程中执行. 此时这个函数是在主线程中被执行的, 就可以直接修改窗口中的对象了.</p>\n<p>像这样, 耗时的任务就可以在子线程中执行完毕, 然后把数据装在上述的函数中发送给主线程, 再由这个函数填充到窗口中 (填充的过程其实耗时很少)</p>\n<details><summary> 这个基类的多线程控制部分</summary>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Window</span>(<span class=\"hljs-title class_ inherited__\">object</span>): <span class=\"hljs-comment\"># 程序中所有常规窗口的父类</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, ..., toplevel=<span class=\"hljs-literal\">False</span>, ..., master=<span class=\"hljs-literal\">None</span></span>):<br>        self.task_queue = queue.Queue() <span class=\"hljs-comment\"># 此队列用于储存来自子线程的无参函数对象</span><br>        <span class=\"hljs-keyword\">if</span> toplevel <span class=\"hljs-keyword\">or</span> master:<br>            self.window = tk.Toplevel(master=master)<br>        <span class=\"hljs-keyword\">else</span>:<br>            self.window = tk.Tk()<br>        ...<br>        self.listen_task()<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">listen_task</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> self.task_queue.empty():<br>            func = self.task_queue.get_nowait()<br>            <span class=\"hljs-keyword\">try</span>:<br>                func()<br>            <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>                logging.error(<span class=\"hljs-string\">&#x27;Task Listener Caught an Error: &#x27;</span>+<span class=\"hljs-built_in\">str</span>(e))<br>                <span class=\"hljs-comment\">#raise</span><br>                traceback_info = traceback.format_exc()<br>                <span class=\"hljs-comment\"># print(traceback_info)</span><br>            <span class=\"hljs-keyword\">else</span>:<br>                <span class=\"hljs-keyword\">pass</span><br>                <span class=\"hljs-comment\">#logging.debug(&quot;Call func: &quot;+str(func))</span><br>        <span class=\"hljs-keyword\">if</span> self.task_queue.empty():<br>            self.window.after(<span class=\"hljs-number\">10</span>,self.listen_task)<br>        <span class=\"hljs-keyword\">else</span>:<br>            self.window.after(<span class=\"hljs-number\">1</span>,self.listen_task)<br><br>    ...<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>...</code>是被省略的部分</p>\n</blockquote>\n</details>\n\n<p>我通过这种方式来进行多线程协调.</p>\n<p><del>听上去还是蛮巧妙的?</del></p>\n<p>但是, 把这个方法写在基类中就意味着, 每个窗口创建时都会附带一个队列和一个反复执行的函数. 我不清楚别人是不是这么做的, 反正我当时就这么写了w.<br>现在我对这个做法其实不是很满意, 因为我认为这可能消耗了额外的资源 <del>, 多少有些强迫症了</del></p>\n<h2 id=\"网络请求的封装\"><a href=\"#网络请求的封装\" class=\"headerlink\" title=\"网络请求的封装\"></a>网络请求的封装</h2><p>比较让人难绷的是, 我以前把负责网络请求的模块<code>requester</code>直接放在了<code>biliapis</code>模块中, 我现在觉得这个层次结构不算合理.<br>这也就是说, 要想把<code>biliapis</code>模块用到别的项目中, 底下的<code>requester</code>也会被 copy 一份, 而那个别的项目中可能已经有了别的网络请求模块, 就会造成冗余…<br>然后<code>requester</code>中封装的<code>get</code>与<code>post</code>还对返回的流对象做了处理, 把请求过程中创建的<code>req.Request</code>对象嗯塞了进去, 这是为了方便<code>login</code>模块中对 cookies 的操作. 但也进一步导致了可移植性的下降.</p>\n<details><summary>搓程序时候的趣事(?)</summary>\n\n<p>ChatGPT 一开始说用<code>urllib</code>打开的流中会有<code>request</code>这个成员, 但是其实使用 opener 打开的流中并没有, 当时跟 GPT 杠了挺久, 然后 GPT 改口了ww</p>\n<p>GPT 最终的答复是:</p>\n<blockquote>\n<p><code>opener.open()</code>方法返回的<code>HTTPResponse</code>对象可能不会附带<code>request</code>属性。这是因为<code>opener.open()</code>方法是一个高级接口，它隐藏了底层的请求细节，不直接暴露<code>Request</code>对象。</p>\n</blockquote>\n</details>\n\n<p>以<code>get</code>方法为例, 它的代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">@auto_retry(<span class=\"hljs-params\">retry_time</span>)</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">url, headers=fake_headers_get</span>):<br>    req = request.Request(url, headers=headers)<br>    response = opener.<span class=\"hljs-built_in\">open</span>(req, <span class=\"hljs-literal\">None</span>, timeout=timeout)<br>    response.request = req      <span class=\"hljs-comment\"># 强行塞入 request</span><br>    logging.debug(<span class=\"hljs-string\">&#x27;Get: &#x27;</span>+url)<br>    <span class=\"hljs-keyword\">return</span> response<br></code></pre></td></tr></table></figure>\n<details><summary>我猜你想吐槽...</summary>\n\n<blockquote>\n<p>啊你这个请求怎么没有用<code>with</code>啊<br>这个函数怎么直接就把流对象传回去了啊</p>\n</blockquote>\n<p>emm来看其他部分是怎么用这个函数的:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_content_bytes</span>(<span class=\"hljs-params\">url, headers=fake_headers_get, update_cookie=<span class=\"hljs-literal\">True</span></span>):<br>    <span class=\"hljs-comment\"># 取名有问题, 请自动忽略 content 这个词</span><br>    <span class=\"hljs-keyword\">with</span> get(url, headers=headers) <span class=\"hljs-keyword\">as</span> response:<br>        <span class=\"hljs-keyword\">if</span> cookies <span class=\"hljs-keyword\">and</span> update_cookie:<br>            cookies.make_cookies(response, response.request)<br>        <span class=\"hljs-keyword\">return</span> read_and_decode_data(response)<br>        <span class=\"hljs-comment\"># 取名也有问题, decode 应该改成 decompress</span><br></code></pre></td></tr></table></figure>\n<p><del>我其实不是很确定用自动重试装饰器来修饰这个函数是不是正确的选择</del></p>\n</details>\n\n\n<p>总之就是很不满意 (叉腰)</p>\n<h2 id=\"多窗口之间的协作\"><a href=\"#多窗口之间的协作\" class=\"headerlink\" title=\"多窗口之间的协作\"></a>多窗口之间的协作</h2><p>首先需要提醒的是, 下文提到的<code>Window</code>(定义在<code>basic_window.py</code>中)继承自<code>object</code>, <code>tk.Tk</code>或者<code>tk.Toplevel</code>对象则被存放在<code>Window.window</code>处</p>\n<p><del>很令人费解是吧? 我也想问问以前的我为什么要这么写</del></p>\n<p>我一般会在窗口类(一般继承自<code>Window</code>)的<code>__init__()</code>方法的末尾加上<code>self.window.wait_window(self.window)</code>来使外界在执行实例化窗口类的操作时停在这一步, 直到窗口被释放 (<code>self.window.destroy()</code>被执行)<br>官方的模块 <code>tk.messagebox</code> 和 <code>tk.filedialog</code> 中的操作也有类似的逻辑</p>\n<blockquote>\n<p>当时的我在<code>Window</code>类中直接把上面那个”停下”的操作封装成了<code>self.mainloop()</code>这个方法, 极具迷惑性.<br>注意与下文提到的<code>mainloop</code>做区别.<br><del>越写就越想穿越回去抽自己几个大嘴巴子</del></p>\n</blockquote>\n<p>对于大部分不需要在打开窗口的同时打开另一个窗口的窗口是这样.<br>至于为什么不用<code>Tk.mainloop()</code>来等待窗口, 是因为我发现如果这样做的话, 关闭窗口时会产生一些莫名其妙的问题<br>按照我的理解, <code>Tk.mainloop()</code>会使整个 tk 的事件循环阻塞主线程; 如果通过<code>Tk.destroy()</code>将其打破, tk 会认为整个程序应该结束了, 但其实没有, 这只是一个窗口关闭了而已.</p>\n<p>于是我的整个程序里一个<code>Tk.mainloop()</code>都没用过w</p>\n<p>而除了下载窗口外的所有子窗口(<code>Toplevel</code>)的父窗口都是主窗口(<code>Tk</code>), 当把主窗口关掉的时候其余窗口就会被自动地关闭.<br>至于下载窗口, 它拥有特殊的内部逻辑, 并没有使用等待窗口这一机制.</p>\n<h2 id=\"下载器的内部逻辑\"><a href=\"#下载器的内部逻辑\" class=\"headerlink\" title=\"下载器的内部逻辑\"></a>下载器的内部逻辑</h2><p>这一部分最初于 2021 年 11 月左右完成 (根据写的日志来看)<br><del>当时这部分是在自习课上想出来的, 笔记本应该还能找到, 但是放在家里了w</del></p>\n<p><strong>这一部分是线程安全问题的重灾区.</strong><br>中途曾尝试修复过一次, 给涉及到多线程操作的几个列表添加了线程锁. 但是偏偏漏掉了最核心的用于存储原始数据的列表和另外三个用于存放任务状态的列表.<br>我最终发现这个遗留问题的时候已经为时已晚. 各个线程锁在之前尝试修复的时候搅成了一坨, 就连继续往上拉史都做不到了, 哪怕只加一个线程锁都会在莫名其妙的地方锁死.<br><del>当然如果花时间的话其实还是可以修的, 需要把之前修的地方推掉重来</del></p>\n<h3 id=\"显示机制\"><a href=\"#显示机制\" class=\"headerlink\" title=\"显示机制\"></a>显示机制</h3><p>并不是通过修改窗口属性将构建好的窗口显示或隐藏, 而是到了需要显示的时候才开始构建</p>\n<p>当 用于接受下载任务的<code>task_receiver()</code>被调用 且 这个函数运行于主线程中 时, <code>show()</code>方法会被自动调用<br><code>show()</code>方法会执行构建 GUI 的代码, 而<code>hide()</code>方法则会直接销毁整个窗口<br>由于涉及到 GUI 操作, 上述两个方法都必须在主线程中运行</p>\n<p>窗口中显示的的任务信息存储在<code>table_display_list</code>这个多维列表中, 每次刷新显示的信息时<code>auto_refresh_table</code>这个方法会将它的内容展示到 GUI 中</p>\n<blockquote>\n<p><code>auto_refresh_table</code>也是借助<code>Tk.after()</code>来进行自动循环的</p>\n</blockquote>\n<p>下载器刷新 GUI 的流程:</p>\n<ol>\n<li>刷新任务列表<ul>\n<li>如果任务数没有变动, 那么直接修改对应项的值</li>\n<li>如果任务数有变动:<ol>\n<li>先记录哪些项被选中了</li>\n<li>然后删除列表框中的所有项</li>\n<li>将新的信息填充进去</li>\n<li>复现先前选中的项</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>更新统计信息</li>\n<li>准备下一次自动刷新</li>\n</ol>\n<h3 id=\"数据存储与任务管理\"><a href=\"#数据存储与任务管理\" class=\"headerlink\" title=\"数据存储与任务管理\"></a>数据存储与任务管理</h3><p>最核心的内容是<code>data_objs</code>这个成员, 它存储着传入<code>task_receiver</code>的原始数据<br>下载的各个步骤都会读取</p>\n<p>有三个索引列表与它相关</p>\n<ul>\n<li><code>failed_indexes</code></li>\n<li><code>running_indexes</code></li>\n<li><code>done_indexes</code></li>\n</ul>\n<p>存放的内容是任务对应的数据在<code>data_objs</code>中的索引<br><small>也是在<code>table_display_list</code>中的索引</small></p>\n<blockquote>\n<p>我认为下载器中的最关键的一个量就是这个索引<br>在特化的任务函数中第一个显式参数就是<code>index</code>, 说的就是这个索引</p>\n</blockquote>\n<p>感觉逼逼叨叨这么多还不如放张图, 等我…</p>\n<details><summary>试着用了 mermaid 语法</summary>\n\n<pre class=\"mermaid\">\nflowchart TB\n\n    F(下载管理器实例化) -- 启动 --> auto_thread_starter\n    \n    subgraph auto_thread_starter\n        direction TB\n    \n        b{检查 task_queue}\n        b -- 有任务 --> c[将任务取出, 作为子线程开始运行]\n        b -- 无任务 --> b\n        c --> b\n    end\n    \n    c -- 启动 --> task_itself\n    \n    subgraph task_itself\n        direction TB\n        g[将参数中的 index 放入 running_indexes]\n        g --> h[任务计数器+1]\n        h --> i[进行任务内容]\n        i --> j[将 index 从 running_indexes 中移除]\n        j --> k{任务是否成功}\n        k -- 是 --> l[将 index 放入 done_indexes]\n        k -- 否 --> m[将 index 放入 failed_indexes]\n        l --> n(任务计数器-1)\n        m --> n\n    end\n\n</pre>\n\n</details>\n\n<p>如果要添加任务, 则遵循下面的流程:</p>\n<details><summary>另一个流程图</summary>\n\n<pre class=\"mermaid\">\nflowchart TB\n    direction TB\n    A(添加任务) --> B[获取到下载所需的数据]\n    B --> C[将任务数据放入 data_objs]\n    C --> D[\n        将对应的任务函数和任务在 data_objs 中的索引和数据包装成 lambda\n        然后放入 task_queue\n        ]\n    D --> E[\n        在 table_display_list 中创建位置\n        <small>任务在两个列表中的索引保持一致</small>\n        ]\n</pre>\n\n</details>\n\n<h3 id=\"下载进度的保存与读取\"><a href=\"#下载进度的保存与读取\" class=\"headerlink\" title=\"下载进度的保存与读取\"></a>下载进度的保存与读取</h3><h4 id=\"保存\"><a href=\"#保存\" class=\"headerlink\" title=\"保存\"></a>保存</h4><p>程序会遍历整个<code>data_objs</code>, 从中筛选出还没有成功的任务组成一个列表<br>然后将这个列表作为一个临时字典的<code>objs</code>键对应的值<br><code>table_display_list</code>中对应的项也会被组成列表, 作为这个临时字典的<code>displaylist</code>键对应的值<br>最后程序会将这个字典保存为 json 文件</p>\n<p>上述操作被封装为了<code>save_progress</code>这个方法<br>这个方法在每次有任务开始或结束的时候都会被调用</p>\n<h4 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a>读取</h4><p>首先程序会读取保存的 json 文件, 然后遍历其中的<code>objs</code>列表, 按照与<code>task_receiver</code>中类似的方法逐个添加任务<br>在这个过程中, 除了任务状态文本会被改成<code>待处理</code>外, 其余内容将会与保存前保持一致</p>\n<p>上述操作被封装为了<code>load_progress</code>这个方法<br>这个方法在程序启动的时候经过用户确认后会被调用</p>\n<h2 id=\"Tkinter-中的滚动页面的实现\"><a href=\"#Tkinter-中的滚动页面的实现\" class=\"headerlink\" title=\"Tkinter 中的滚动页面的实现\"></a>Tkinter 中的滚动页面的实现</h2><p>我最开始定义了一个继承自<code>tk.Frame</code>的滚动框架<code>VerticalScrolledFrame</code></p>\n<p>在用它展示条漫时我发现它的最大滚动范围在 31000px 左右, 这可能是<code>canvas</code>的极限</p>\n<p>层次结构是:<br>frame &gt; canvas &gt; frame &gt; 页面元素</p>\n<pre class=\"mermaid\"> \n\nflowchart LR\n\nsubgraph top_frame\n    subgraph canvas\n        subgraph bottom_frame\n            page_content\n        end\n    end\n    scrollbar[\n        S\n        c\n        r\n        o\n        l\n        l\n        b\n        a\n        r]\nend\n\n</pre>\n\n<p>emm大概长这样, 可能有些夸张了</p>\n<p>缺点是需要手动给页面元素绑定鼠标滚动等事件<br>纵向滚动条用于控制页面的滚动, 实质上是在控制<code>canvas</code>中的里层<code>frame</code>的上下移动</p>\n<p>这个框架被设计成宽度由内容物的宽度决定, 高度由用户定义<br>被用在了<code>SearchWindow</code>的<code>Notebook</code>的单个分页中</p>\n<p>如果需要左右滚动的话也同理了<br>加上一些自动调用的代码应该就能实现像橱窗那样的循环展示效果 <del>(虽然我没亲自写过)</del></p>\n<h2 id=\"互动视频剧情图展示器的实现\"><a href=\"#互动视频剧情图展示器的实现\" class=\"headerlink\" title=\"互动视频剧情图展示器的实现\"></a>互动视频剧情图展示器的实现</h2><p>整个剧情图的展示基于<code>tk.Canvas</code>画布, 在画布右侧和下方分别加上了纵向滚动条和横向滚动条</p>\n<p>最核心的内容是<code>self.plots</code>与<code>self.explored_plot_ids</code><br><code>self.plots</code>是一个装着(装着字典的列表)的列表, 分层存储着请求到的原始数据<br>节点们组成类似于有向图的结构, 像下面这样<br><del>一开始我其实是把它当作树来处理的</del></p>\n<pre class=\"mermaid\">\nflowchart TB\n    subgraph self.plots\n        subgraph layer_1\n            plot_1\n        end\n        subgraph layer_2\n            plot_2\n            plot_3\n            plot_4\n        end\n        subgraph layer_3\n            plot_5\n            plot_6\n        end\n    end\n\n    plot_1 --> plot_2\n    plot_1 --> plot_3\n    plot_1 --> plot_4\n    \n    plot_2 --> plot_5\n    plot_2 --> plot_6\n    \n    plot_3 --> plot_5\n    \n    plot_4 --> plot_5\n    \n    plot_6 --> plot_2\n</pre>\n<p><small><del>我超这个<code>mermaid</code>的牛魔绘图啊</del></small><br>分层是为了更有层次地绘图</p>\n<p>各个节点之间的连接由每个节点数据中包含的多个<code>jump_edge_id</code>确定</p>\n<p>为了方便画图, 引入了<code>self.explored_plot_ids</code>, <code>self.plot_coors</code><br><code>self.explored_plot_ids</code>是一个字典, 以<code>节点id: (节点所在的层的索引, 节点在层中的索引)</code>的形式存储节点id到节点数据的映射<br><code>self.plot_coors</code>是一个字典, 以<code>节点id: (节点在画布中的x坐标, y坐标, 节点块的宽, 节点块的高)</code>的形式存储节点id到节点块在画布中的位置的映射</p>\n<p>为了方便下载, 引入了<code>self.cid_map</code>和<code>self.avid_map</code>这两个字典<br>它们分别存储节点id到cid的映射和cid到avid的映射</p>\n<h3 id=\"节点的探索\"><a href=\"#节点的探索\" class=\"headerlink\" title=\"节点的探索\"></a>节点的探索</h3><p>互动视频有两个重要的id, 剧情图id<code>graph_id</code> 和 节点id<code>edge_id</code><br>剧情图id代表这个互动视频, 节点id代表它的节点</p>\n<blockquote>\n<p>剧情图id可以通过向<a href=\"api.bilibili.com/x/player/v2\">这个接口</a>提交互动视频的<code>cid</code>和(<code>avid</code>或<code>bvid</code>)得到</p>\n</blockquote>\n<blockquote>\n<p>每个节点id都有对应的<code>cid</code>, 配合互动视频的<code>bvid</code>或<code>avid</code>可以取到视频的流<br>初始节点的<code>cid</code>就是这个互动视频的<code>cid</code><br><small>其实互动视频的节点就是另一种形式的视频分P</small></p>\n</blockquote>\n<blockquote>\n<p>对接口的节点id参数传入<code>0</code>就可以获得初始节点的数据</p>\n</blockquote>\n<p>借由初始节点的数据, 可以得到它可能跳转到的节点们的id<br>再请求这些节点id的数据, 获得它们可能跳转到的节点们的id<br>就这么一直下去, 直到不再有新的节点id出现</p>\n<blockquote>\n<p>如果一个节点没有跳转到的节点, 就说明它是终止节点</p>\n</blockquote>\n<p>将每一轮上述操作获得的数据按轮分层 <small>(初始节点单独一层)</small>, 就完成了节点探索的操作</p>\n<h3 id=\"节点的绘制\"><a href=\"#节点的绘制\" class=\"headerlink\" title=\"节点的绘制\"></a>节点的绘制</h3><details><summary>先看效果()</summary>\n\n<p>目标视频: <a href=\"https://www.bilibili.com/video/BV1Pt4y1S7Wb/\">电棍家中的惨案</a></p>\n<p><img onerror=\"imgOnError(this);\" data-fancybox=\"gallery\" src=\"/assets/blogs/BiliTools-introduction/plot_shower.png\" alt=\"Plot_Shower\" data-caption=\"Plot_Shower\" loading=\"lazy\"></p>\n<p>起始节点被涂成淡红色, 终止节点被涂成淡绿色</p>\n</details>\n\n<p>遍历整个<code>self.plots</code>, 为每个节点绘制块, 然后为每个节点绘制跳转箭头</p>\n<ul>\n<li>如果节点跳转到的是下一层的节点, 那么直接连接即可 <small><del>原本想用贝塞尔曲线来连接的, 然后寄了</del></small></li>\n<li>否则则将箭头拉到画布顶部或底部, 绕到目标块所在层的后面进行连接(跳连)</li>\n</ul>\n<p>设置了一些偏移值来确保箭头的线不会重合.<br><small>(但是对于一些关系复杂的互动视频, 上述策略会造成跳连的箭头太多, 导致绘图非常混乱, 完全没法读)</small></p>\n<details><summary>翻车了</summary>\n\n<p>目标视频: <a href=\"https://www.bilibili.com/video/BV1eq4y1e7QF/\">收养澄闪</a></p>\n<p><img onerror=\"imgOnError(this);\" data-fancybox=\"gallery\" src=\"/assets/blogs/BiliTools-introduction/plot_shower_failed.png\" alt=\"Plot_Shower_failed\" data-caption=\"Plot_Shower_failed\" loading=\"lazy\"></p>\n<p><del>视频做得太好导致的</del></p>\n</details>\n\n<p>以后可能会做一个生成<code>mermaid</code>流程图的功能? <del>(画饼ing)</del></p>\n<p>总之这玩意真就图一乐</p>\n<h3 id=\"交互\"><a href=\"#交互\" class=\"headerlink\" title=\"交互\"></a>交互</h3><h4 id=\"点击\"><a href=\"#点击\" class=\"headerlink\" title=\"点击\"></a>点击</h4><p>我想实现<code>当点击一个节点块的时候, 打开侧边栏并在其中展示这个节点的信息</code>这个交互逻辑</p>\n<p>首先来实现点击绘图对象罢.<br><small><code>tk.Canvas</code>其实是可以为其中的绘图对象绑定点击事件的, 但我当时不知道w</small><br>我给整个 canvas 绑定了一个点击事件, 根据坐标来判断被点击的节点块</p>\n<p>所谓的侧边栏, 是另一个隐藏在右边的框架<br>当它要显示的时候, canvas 的宽度会减小侧边栏的宽度那么多, 然后侧边栏框架出现</p>\n<p>值得注意的是, 我已经发现了超出 canvas 范围的的强制滚动会使我的点击事件错位这个问题, 我会在后续将它修复</p>\n<p><del>简称: 下次一定</del></p>\n<h4 id=\"拖动\"><a href=\"#拖动\" class=\"headerlink\" title=\"拖动\"></a>拖动</h4><p><small>写到这里的时候发现我之前写的拖动操作寄了</small></p>\n<p><del>那么今天的内容就到这里了让我们下次再见</del></p>\n<h1 id=\"Defects\"><a href=\"#Defects\" class=\"headerlink\" title=\"Defects\"></a>Defects</h1><h2 id=\"线程安全问题\"><a href=\"#线程安全问题\" class=\"headerlink\" title=\"线程安全问题\"></a>线程安全问题</h2><p>这个问题在 <a href=\"#%E4%B8%8B%E8%BD%BD%E5%99%A8%E7%9A%84%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91\">下载器的内部逻辑</a> 这部分有提到</p>\n<p>大概就是, 如果有多个线程<em>同时</em>操作一个<em>线程不安全</em>的对象, 就可能会出问题<br>Python 中的字典是线程安全的, 但是列表不是</p>\n<p>为了避免这个问题, 可以:</p>\n<ul>\n<li>给操作对象加上线程锁, 使同一时间只能有一个线程访问它</li>\n<li>换用线程安全的对象来存储信息</li>\n</ul>\n<p>上文提到的<code>修复</code>, 便是给对象加锁<br><del>结果加成了一坨 (恼)</del></p>\n<h2 id=\"默认参数评估问题\"><a href=\"#默认参数评估问题\" class=\"headerlink\" title=\"默认参数评估问题\"></a>默认参数评估问题</h2><p>这个问题潜伏了很久, 直到在我使用<code>custom_widgets</code>中的<code>run_with_gui</code>这个函数的时候才被发现</p>\n<details><summary>发现的过程</summary>\n\n<p>程序第一次调用<code>run_with_gui</code>时, <code>is_progress_hook_available</code>这个参数被传入了<code>True</code>.<br>这会使这个函数传入的<code>func</code>参数(这是一个函数)在后续的过程中被<em>额外传入</em>一个叫做<code>progress_hook</code>的字典, <code>func</code>函数可以通过修改这个字典来汇报任务的进度</p>\n<p>问题就在于额外传入这个操作上.<br>在老版本的程序中, 程序在准备阶段会直接修改先前传入的<code>kwargs</code>, 以便后续方便地使用<code>func(**kwargs)</code>来传入参数.<br>而我将<code>kwargs</code>的默认参数设定为了<code>&#123;&#125;</code>, 而不是<code>None</code>.</p>\n<p>第二次调用的时候到了, 这次<code>is_progress_hook_available</code>这个参数被传入了默认的<code>False</code>(这倒不是问题的所在), 按照程序的设计, <code>kwargs</code>不会被修改. 比较巧合的是, 第一次传入的函数只有<code>progress_hook</code>这一个参数, 而第二次的函数则是无参的, 两次调用的<code>kwargs</code>这个参数都没有被指定.<br>这就导致了后文所说的默认参数评估的问题.</p>\n<blockquote>\n<p><font color=red face=consolas>TypeError: self.func() got an unexpected keyword argument ‘progress_hook’</font></p>\n</blockquote>\n<p><del>解释器: Aughhhhhhhhh</del></p>\n</details>\n\n<p>虽然我自主地修复了这个问题, 并且知道它导致的问题是前一次调用影响到了后一次, 但以我的水平无法解释它的成因</p>\n<p>有请: GPT 先生!</p>\n<blockquote>\n<p>在Python中，函数的默认参数如果设置为字典（或其他可变数据类型，如列表、集合等），会有一个潜在的陷阱：如果默认参数在函数内部被修改了，那么这个修改会在未来的函数调用中持续存在。这是因为默认参数只会在函数定义时被评估一次，不是每次调用时都评估。这意味着，如果你修改了默认参数的内容，那么下一次调用函数时，默认参数的值不再是定义函数时指定的原始值。<br>这个行为对于不可变的默认值（例如None、整数、字符串等）通常不会导致问题，因为它们不会被函数调用所改变。然而，对于可变的默认值（例如字典、列表等），这种行为可能导致意外的副作用，因为如果函数内部修改了这些可变对象，这些修改会影响到下一次函数调用时这些默认参数的状态。</p>\n</blockquote>\n<details><summary>ChatGPT 举的例子</summary>\n\n<p>以一个列表作为默认参数的函数为例，来展示这个评估过程：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">append_to_list</span>(<span class=\"hljs-params\">value, my_list=[]</span>):  <span class=\"hljs-comment\"># 默认参数在这里被评估一次</span><br>    my_list.append(value)<br>    <span class=\"hljs-keyword\">return</span> my_list<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>my_list=[]</code> 是一个默认参数。这个默认参数的列表对象在函数定义时创建，并且只创建一次。如果你在函数内部修改了 <code>my_list</code>，比如通过调用 <code>append_to_list</code> 函数，那么你实际上是在修改这个单一的、在函数定义时创建的列表对象。这样，下一次调用 <code>append_to_list</code> 时，你将看到上一次调用的结果仍然保留在列表中，因为它是同一个列表对象。</p>\n<p>为了避免这种情况，你应该使用一个不可变的默认值，比如 <code>None</code>，然后在函数内部检查它，并在需要时创建一个新的列表：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">append_to_list</span>(<span class=\"hljs-params\">value, my_list=<span class=\"hljs-literal\">None</span></span>):<br>    <span class=\"hljs-keyword\">if</span> my_list <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:<br>        my_list = []  <span class=\"hljs-comment\"># 在这里为每次调用创建一个新的列表</span><br>    my_list.append(value)<br>    <span class=\"hljs-keyword\">return</span> my_list<br></code></pre></td></tr></table></figure>\n\n<p>在这个修正后的版本中，每次调用 <code>append_to_list</code> 时，如果没有提供 <code>my_list</code> 参数，就会创建一个新的空列表。这样，每次函数调用都是独立的，不会有意外的共享状态。</p>\n</details>\n\n<p>BiliTools 中的很多函数都被我像这样写了, 比如这个:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_video_download_thread</span>(<span class=\"hljs-params\">self, ..., subtitle_regulation=config[<span class=\"hljs-string\">&#x27;download&#x27;</span>][<span class=\"hljs-string\">&#x27;video&#x27;</span>][<span class=\"hljs-string\">&#x27;subtitle_lang_regulation&#x27;</span>], ...</span>):<br>    ...<br></code></pre></td></tr></table></figure>\n\n<p>这些问题目前还没有得到修复…<br><del>绝对不是因为我忘了! 我回头就去修!</del></p>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><blockquote>\n<p>未完待续…</p>\n</blockquote>\n","excerpt":"","more":"<p>想要介绍一下陪了自己两年多的项目 <del>, 顺便练一下 markdown 语法</del></p>\n<p>阅前提示: </p>\n<ol>\n<li>以下内容的措辞可能令人费解, 因为咱在表达方面并没有什么天赋</li>\n<li>以下内容不一定正确或者符合规范, 如果有错误欢迎提出w</li>\n</ol>\n<h1 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h1><p>BiliTools 是我在 2021 年 5 月左右使用 Python 编写的一个用于下载 B 站的各种资源的程序</p>\n<p><a href=\"https://github.com/NingmengLemon/BiliTools\">项目地址</a></p>\n<h2 id=\"关于版本号\"><a href=\"#关于版本号\" class=\"headerlink\" title=\"关于版本号\"></a>关于版本号</h2><p>因为有前身在, 所以版本号直接从 2 开始<br>又因为咱的脑子可能有点抽风, 版本号目前都是 v.2.0.0_Dev{实际更新版本数} 这个样子w<br>目前更新到了 Dev17 的说, 以下内容都是适用于该版本的</p>\n<h2 id=\"关于前身\"><a href=\"#关于前身\" class=\"headerlink\" title=\"关于前身\"></a>关于前身</h2><p>前身是由我编写的 BiliDownloader, 其实就是一个 <a href=\"https://github.com/soimort/you-get\">you-get</a> 的 GUI 而已<br>附加了一点针对 B 站的功能, 比如弹幕下载和过滤, 版本号为 1</p>\n<h2 id=\"史山注意\"><a href=\"#史山注意\" class=\"headerlink\" title=\"史山注意\"></a>史山注意</h2><p>首先最初在写这个程序的时候我还是个若至, 像各种语言规范什么的都不知道</p>\n<p>你可以在程序中见到:</p>\n<ul>\n<li>随处可见的超长单行</li>\n<li>刁钻古怪的调用链</li>\n<li>(几乎)没有类型标注</li>\n<li>稀少的注释与日志</li>\n<li>一些不知道在干什么但是删掉就会出 Bug 的代码</li>\n<li>各种若至的代码逻辑</li>\n<li>各种花里胡哨但又一堆 Bug 的功能</li>\n</ul>\n<p>然后到现在我稍微懂了那么一点语言规范, 但是先前拉的史已经不好收拾了</p>\n<p>有的时候甚至都不想再继续写, 想 remake 一个新程序出来了</p>\n<p>这个程序伴随着我的进步, 我的程序水平也在逐渐提升（吗？）</p>\n<p><del>所以还是蛮有纪念意义的, 对吧</del></p>\n<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"https://github.com/SocialSisterYi/bilibili-API-collect\">Bilibili-API-collect</a></p>\n<p><a href=\"https://github.com/m13253/danmaku2ass\">danmaku2ass</a></p>\n<h1 id=\"Quick-Overview\"><a href=\"#Quick-Overview\" class=\"headerlink\" title=\"Quick Overview\"></a>Quick Overview</h1><h2 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h2><p>截至 Dev17 的文件结构如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">BiliTools<br>├─ bilitools.py             # 主程序<br>├─ basic_window.py          # 提供了(几乎)所有窗口的基类<br>├─ bezier_curve.py          # (未使用)用于画贝塞尔曲线的一些基本操作<br>├─ configuration.py         # 一些与配置相关的数据与操作<br>├─ custom_widgets.py        # 一些自定义的 tk 组件<br>├─ danmaku2ass.py           # 修改过的 danmaku2ass<br>├─ ffdriver.py              # 用于调用 ffmpeg 的操作<br>├─ imglib.py                # 图标们 (以 base64 方式编码的 png)<br>├─ textlib.py               # Tips 和 About 文本<br>├─ videoshot_handler.py     # 提供了用于处理视频快照的一个类<br>└─ biliapis                 # 封装了一些 B 站的 API, 大多取自 bilibili-api-collect<br>     ├─ __init__.py         # 用于统领起这个 API 库, 定义了一些杂七杂八的操作<br>     ├─ requester.py        # 用于请求的模块<br>     ├─ error.py            # 定义了错误类<br>     ├─ bilicodes.py        # 各种常用的标识码<br>     ├─ wbi.py              # WBI 鉴权<br>     ├─ article.py          # 专栏相关<br>     ├─ audio.py            # 音频相关<br>     ├─ comment.py          # 评论相关<br>     ├─ danmaku.py          # 弹幕相关<br>     ├─ dynamic.py          # 动态相关<br>     ├─ live.py             # 直播相关<br>     ├─ login.py            # 登录相关<br>     ├─ manga.py            # 漫画相关<br>     ├─ media.py            # 影视与番剧相关<br>     ├─ stream.py           # 媒体流相关<br>     ├─ subtitle.py         # 字幕相关<br>     ├─ user.py             # 用户相关<br>     ├─ video.py            # 视频相关<br>     └─ other.py            # 其他 API<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">tkinter         # GUI 库, Python 应该会自带<br>pillow          # 用于图像处理<br>qrcode          # 用于生成二维码<br>beautifulsoup4  # 用于处理 HTML 和 XML<br>brotli          # 用于解压数据<br>lxml            # bs4 的依赖<br>colorama        # 用于控制台着色<br>pycryptodome    # 用于计算 CorrespondPath<br></code></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/FFmpeg/FFmpeg\">ffmpeg</a> - 通过管道进行调用, 安装即可</p>\n<h1 id=\"Go-♂-Deeper\"><a href=\"#Go-♂-Deeper\" class=\"headerlink\" title=\"Go ♂ Deeper\"></a>Go ♂ Deeper</h1><h2 id=\"各个类间的继承关系\"><a href=\"#各个类间的继承关系\" class=\"headerlink\" title=\"各个类间的继承关系\"></a>各个类间的继承关系</h2><details><summary>点击展开</summary>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">object<br>├─ DownloadManager<br>├─ Window<br>│   ├─ MainWindow<br>│   ├─ BatchWindow<br>│   ├─ InputWindow<br>│   ├─ ConfigWindow<br>│   ├─ AudioWindow<br>│   ├─ CommonVideoWindow<br>│   ├─ CollectWindow<br>│   ├─ LoginWindow<br>│   ├─ PbpShower<br>│   ├─ PartsChooser<br>│   ├─ BlackroomWindow<br>│   ├─ BangumiWindow<br>│   ├─ MangaViewer_Rolling      (未完工)<br>│   ├─ MangaViewer_PageTurning  (未完工)<br>│   ├─ SearchWindow<br>│   ├─ PlotShower<br>│   ├─ VideoShotViewer<br>│   ├─ ArticleWindow    (未完工)<br>│   ├─ ToviewWindow     (未完工)<br>│   └─ Thread_with_gui<br>├─ ToolTip<br>├─ _CustomMsgbox<br>└─ VideoShotHandler<br><br>tk.Frame<br>└─ VerticalScrolledFrame<br>    ├─ _CommonVideoSearchShower<br>    └─ _MediaSearchShower<br><br>ttk.Button<br>└─ ImageButton<br><br>tk.Label<br>└─ ImageLabel<br><br>tk.Toplevel<br>└─ _TipWindow<br><br>Exception<br>└─ BiliError<br><br>threading.Thread<br>└─ _DownloadThread<br><br></code></pre></td></tr></table></figure>\n\n</details>\n\n<h2 id=\"多线程的处理\"><a href=\"#多线程的处理\" class=\"headerlink\" title=\"多线程的处理\"></a>多线程的处理</h2><p>就像其他基于 tk 的应用程序一样, 此程序也以主线程为主</p>\n<p>为了处理那些耗时的任务, 自然是需要用到子线程的, 但是子线程没办法直接修改 tk 窗口中的对象, 否则就会导致<code>thread not in mainloop</code>错误</p>\n<p>于是我在<code>basic_window.py</code>中的<code>Window</code>基类中定义了一个<code>task_queue</code>成员. 这是一个队列, 子线程可以向其中放入无参的函数对象, 而这些函数对象会被位于主线程中的由<code>Tk.after()</code>驱动的一个自动循环执行的函数<code>listen_task</code>自动取出并在主线程中执行. 此时这个函数是在主线程中被执行的, 就可以直接修改窗口中的对象了.</p>\n<p>像这样, 耗时的任务就可以在子线程中执行完毕, 然后把数据装在上述的函数中发送给主线程, 再由这个函数填充到窗口中 (填充的过程其实耗时很少)</p>\n<details><summary> 这个基类的多线程控制部分</summary>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Window</span>(<span class=\"hljs-title class_ inherited__\">object</span>): <span class=\"hljs-comment\"># 程序中所有常规窗口的父类</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, ..., toplevel=<span class=\"hljs-literal\">False</span>, ..., master=<span class=\"hljs-literal\">None</span></span>):<br>        self.task_queue = queue.Queue() <span class=\"hljs-comment\"># 此队列用于储存来自子线程的无参函数对象</span><br>        <span class=\"hljs-keyword\">if</span> toplevel <span class=\"hljs-keyword\">or</span> master:<br>            self.window = tk.Toplevel(master=master)<br>        <span class=\"hljs-keyword\">else</span>:<br>            self.window = tk.Tk()<br>        ...<br>        self.listen_task()<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">listen_task</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> self.task_queue.empty():<br>            func = self.task_queue.get_nowait()<br>            <span class=\"hljs-keyword\">try</span>:<br>                func()<br>            <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>                logging.error(<span class=\"hljs-string\">&#x27;Task Listener Caught an Error: &#x27;</span>+<span class=\"hljs-built_in\">str</span>(e))<br>                <span class=\"hljs-comment\">#raise</span><br>                traceback_info = traceback.format_exc()<br>                <span class=\"hljs-comment\"># print(traceback_info)</span><br>            <span class=\"hljs-keyword\">else</span>:<br>                <span class=\"hljs-keyword\">pass</span><br>                <span class=\"hljs-comment\">#logging.debug(&quot;Call func: &quot;+str(func))</span><br>        <span class=\"hljs-keyword\">if</span> self.task_queue.empty():<br>            self.window.after(<span class=\"hljs-number\">10</span>,self.listen_task)<br>        <span class=\"hljs-keyword\">else</span>:<br>            self.window.after(<span class=\"hljs-number\">1</span>,self.listen_task)<br><br>    ...<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>...</code>是被省略的部分</p>\n</blockquote>\n</details>\n\n<p>我通过这种方式来进行多线程协调.</p>\n<p><del>听上去还是蛮巧妙的?</del></p>\n<p>但是, 把这个方法写在基类中就意味着, 每个窗口创建时都会附带一个队列和一个反复执行的函数. 我不清楚别人是不是这么做的, 反正我当时就这么写了w.<br>现在我对这个做法其实不是很满意, 因为我认为这可能消耗了额外的资源 <del>, 多少有些强迫症了</del></p>\n<h2 id=\"网络请求的封装\"><a href=\"#网络请求的封装\" class=\"headerlink\" title=\"网络请求的封装\"></a>网络请求的封装</h2><p>比较让人难绷的是, 我以前把负责网络请求的模块<code>requester</code>直接放在了<code>biliapis</code>模块中, 我现在觉得这个层次结构不算合理.<br>这也就是说, 要想把<code>biliapis</code>模块用到别的项目中, 底下的<code>requester</code>也会被 copy 一份, 而那个别的项目中可能已经有了别的网络请求模块, 就会造成冗余…<br>然后<code>requester</code>中封装的<code>get</code>与<code>post</code>还对返回的流对象做了处理, 把请求过程中创建的<code>req.Request</code>对象嗯塞了进去, 这是为了方便<code>login</code>模块中对 cookies 的操作. 但也进一步导致了可移植性的下降.</p>\n<details><summary>搓程序时候的趣事(?)</summary>\n\n<p>ChatGPT 一开始说用<code>urllib</code>打开的流中会有<code>request</code>这个成员, 但是其实使用 opener 打开的流中并没有, 当时跟 GPT 杠了挺久, 然后 GPT 改口了ww</p>\n<p>GPT 最终的答复是:</p>\n<blockquote>\n<p><code>opener.open()</code>方法返回的<code>HTTPResponse</code>对象可能不会附带<code>request</code>属性。这是因为<code>opener.open()</code>方法是一个高级接口，它隐藏了底层的请求细节，不直接暴露<code>Request</code>对象。</p>\n</blockquote>\n</details>\n\n<p>以<code>get</code>方法为例, 它的代码如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">@auto_retry(<span class=\"hljs-params\">retry_time</span>)</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">url, headers=fake_headers_get</span>):<br>    req = request.Request(url, headers=headers)<br>    response = opener.<span class=\"hljs-built_in\">open</span>(req, <span class=\"hljs-literal\">None</span>, timeout=timeout)<br>    response.request = req      <span class=\"hljs-comment\"># 强行塞入 request</span><br>    logging.debug(<span class=\"hljs-string\">&#x27;Get: &#x27;</span>+url)<br>    <span class=\"hljs-keyword\">return</span> response<br></code></pre></td></tr></table></figure>\n<details><summary>我猜你想吐槽...</summary>\n\n<blockquote>\n<p>啊你这个请求怎么没有用<code>with</code>啊<br>这个函数怎么直接就把流对象传回去了啊</p>\n</blockquote>\n<p>emm来看其他部分是怎么用这个函数的:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_content_bytes</span>(<span class=\"hljs-params\">url, headers=fake_headers_get, update_cookie=<span class=\"hljs-literal\">True</span></span>):<br>    <span class=\"hljs-comment\"># 取名有问题, 请自动忽略 content 这个词</span><br>    <span class=\"hljs-keyword\">with</span> get(url, headers=headers) <span class=\"hljs-keyword\">as</span> response:<br>        <span class=\"hljs-keyword\">if</span> cookies <span class=\"hljs-keyword\">and</span> update_cookie:<br>            cookies.make_cookies(response, response.request)<br>        <span class=\"hljs-keyword\">return</span> read_and_decode_data(response)<br>        <span class=\"hljs-comment\"># 取名也有问题, decode 应该改成 decompress</span><br></code></pre></td></tr></table></figure>\n<p><del>我其实不是很确定用自动重试装饰器来修饰这个函数是不是正确的选择</del></p>\n</details>\n\n\n<p>总之就是很不满意 (叉腰)</p>\n<h2 id=\"多窗口之间的协作\"><a href=\"#多窗口之间的协作\" class=\"headerlink\" title=\"多窗口之间的协作\"></a>多窗口之间的协作</h2><p>首先需要提醒的是, 下文提到的<code>Window</code>(定义在<code>basic_window.py</code>中)继承自<code>object</code>, <code>tk.Tk</code>或者<code>tk.Toplevel</code>对象则被存放在<code>Window.window</code>处</p>\n<p><del>很令人费解是吧? 我也想问问以前的我为什么要这么写</del></p>\n<p>我一般会在窗口类(一般继承自<code>Window</code>)的<code>__init__()</code>方法的末尾加上<code>self.window.wait_window(self.window)</code>来使外界在执行实例化窗口类的操作时停在这一步, 直到窗口被释放 (<code>self.window.destroy()</code>被执行)<br>官方的模块 <code>tk.messagebox</code> 和 <code>tk.filedialog</code> 中的操作也有类似的逻辑</p>\n<blockquote>\n<p>当时的我在<code>Window</code>类中直接把上面那个”停下”的操作封装成了<code>self.mainloop()</code>这个方法, 极具迷惑性.<br>注意与下文提到的<code>mainloop</code>做区别.<br><del>越写就越想穿越回去抽自己几个大嘴巴子</del></p>\n</blockquote>\n<p>对于大部分不需要在打开窗口的同时打开另一个窗口的窗口是这样.<br>至于为什么不用<code>Tk.mainloop()</code>来等待窗口, 是因为我发现如果这样做的话, 关闭窗口时会产生一些莫名其妙的问题<br>按照我的理解, <code>Tk.mainloop()</code>会使整个 tk 的事件循环阻塞主线程; 如果通过<code>Tk.destroy()</code>将其打破, tk 会认为整个程序应该结束了, 但其实没有, 这只是一个窗口关闭了而已.</p>\n<p>于是我的整个程序里一个<code>Tk.mainloop()</code>都没用过w</p>\n<p>而除了下载窗口外的所有子窗口(<code>Toplevel</code>)的父窗口都是主窗口(<code>Tk</code>), 当把主窗口关掉的时候其余窗口就会被自动地关闭.<br>至于下载窗口, 它拥有特殊的内部逻辑, 并没有使用等待窗口这一机制.</p>\n<h2 id=\"下载器的内部逻辑\"><a href=\"#下载器的内部逻辑\" class=\"headerlink\" title=\"下载器的内部逻辑\"></a>下载器的内部逻辑</h2><p>这一部分最初于 2021 年 11 月左右完成 (根据写的日志来看)<br><del>当时这部分是在自习课上想出来的, 笔记本应该还能找到, 但是放在家里了w</del></p>\n<p><strong>这一部分是线程安全问题的重灾区.</strong><br>中途曾尝试修复过一次, 给涉及到多线程操作的几个列表添加了线程锁. 但是偏偏漏掉了最核心的用于存储原始数据的列表和另外三个用于存放任务状态的列表.<br>我最终发现这个遗留问题的时候已经为时已晚. 各个线程锁在之前尝试修复的时候搅成了一坨, 就连继续往上拉史都做不到了, 哪怕只加一个线程锁都会在莫名其妙的地方锁死.<br><del>当然如果花时间的话其实还是可以修的, 需要把之前修的地方推掉重来</del></p>\n<h3 id=\"显示机制\"><a href=\"#显示机制\" class=\"headerlink\" title=\"显示机制\"></a>显示机制</h3><p>并不是通过修改窗口属性将构建好的窗口显示或隐藏, 而是到了需要显示的时候才开始构建</p>\n<p>当 用于接受下载任务的<code>task_receiver()</code>被调用 且 这个函数运行于主线程中 时, <code>show()</code>方法会被自动调用<br><code>show()</code>方法会执行构建 GUI 的代码, 而<code>hide()</code>方法则会直接销毁整个窗口<br>由于涉及到 GUI 操作, 上述两个方法都必须在主线程中运行</p>\n<p>窗口中显示的的任务信息存储在<code>table_display_list</code>这个多维列表中, 每次刷新显示的信息时<code>auto_refresh_table</code>这个方法会将它的内容展示到 GUI 中</p>\n<blockquote>\n<p><code>auto_refresh_table</code>也是借助<code>Tk.after()</code>来进行自动循环的</p>\n</blockquote>\n<p>下载器刷新 GUI 的流程:</p>\n<ol>\n<li>刷新任务列表<ul>\n<li>如果任务数没有变动, 那么直接修改对应项的值</li>\n<li>如果任务数有变动:<ol>\n<li>先记录哪些项被选中了</li>\n<li>然后删除列表框中的所有项</li>\n<li>将新的信息填充进去</li>\n<li>复现先前选中的项</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>更新统计信息</li>\n<li>准备下一次自动刷新</li>\n</ol>\n<h3 id=\"数据存储与任务管理\"><a href=\"#数据存储与任务管理\" class=\"headerlink\" title=\"数据存储与任务管理\"></a>数据存储与任务管理</h3><p>最核心的内容是<code>data_objs</code>这个成员, 它存储着传入<code>task_receiver</code>的原始数据<br>下载的各个步骤都会读取</p>\n<p>有三个索引列表与它相关</p>\n<ul>\n<li><code>failed_indexes</code></li>\n<li><code>running_indexes</code></li>\n<li><code>done_indexes</code></li>\n</ul>\n<p>存放的内容是任务对应的数据在<code>data_objs</code>中的索引<br><small>也是在<code>table_display_list</code>中的索引</small></p>\n<blockquote>\n<p>我认为下载器中的最关键的一个量就是这个索引<br>在特化的任务函数中第一个显式参数就是<code>index</code>, 说的就是这个索引</p>\n</blockquote>\n<p>感觉逼逼叨叨这么多还不如放张图, 等我…</p>\n<details><summary>试着用了 mermaid 语法</summary>\n\n<pre class=\"mermaid\">\nflowchart TB\n\n    F(下载管理器实例化) -- 启动 --> auto_thread_starter\n    \n    subgraph auto_thread_starter\n        direction TB\n    \n        b{检查 task_queue}\n        b -- 有任务 --> c[将任务取出, 作为子线程开始运行]\n        b -- 无任务 --> b\n        c --> b\n    end\n    \n    c -- 启动 --> task_itself\n    \n    subgraph task_itself\n        direction TB\n        g[将参数中的 index 放入 running_indexes]\n        g --> h[任务计数器+1]\n        h --> i[进行任务内容]\n        i --> j[将 index 从 running_indexes 中移除]\n        j --> k{任务是否成功}\n        k -- 是 --> l[将 index 放入 done_indexes]\n        k -- 否 --> m[将 index 放入 failed_indexes]\n        l --> n(任务计数器-1)\n        m --> n\n    end\n\n</pre>\n\n</details>\n\n<p>如果要添加任务, 则遵循下面的流程:</p>\n<details><summary>另一个流程图</summary>\n\n<pre class=\"mermaid\">\nflowchart TB\n    direction TB\n    A(添加任务) --> B[获取到下载所需的数据]\n    B --> C[将任务数据放入 data_objs]\n    C --> D[\n        将对应的任务函数和任务在 data_objs 中的索引和数据包装成 lambda\n        然后放入 task_queue\n        ]\n    D --> E[\n        在 table_display_list 中创建位置\n        <small>任务在两个列表中的索引保持一致</small>\n        ]\n</pre>\n\n</details>\n\n<h3 id=\"下载进度的保存与读取\"><a href=\"#下载进度的保存与读取\" class=\"headerlink\" title=\"下载进度的保存与读取\"></a>下载进度的保存与读取</h3><h4 id=\"保存\"><a href=\"#保存\" class=\"headerlink\" title=\"保存\"></a>保存</h4><p>程序会遍历整个<code>data_objs</code>, 从中筛选出还没有成功的任务组成一个列表<br>然后将这个列表作为一个临时字典的<code>objs</code>键对应的值<br><code>table_display_list</code>中对应的项也会被组成列表, 作为这个临时字典的<code>displaylist</code>键对应的值<br>最后程序会将这个字典保存为 json 文件</p>\n<p>上述操作被封装为了<code>save_progress</code>这个方法<br>这个方法在每次有任务开始或结束的时候都会被调用</p>\n<h4 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a>读取</h4><p>首先程序会读取保存的 json 文件, 然后遍历其中的<code>objs</code>列表, 按照与<code>task_receiver</code>中类似的方法逐个添加任务<br>在这个过程中, 除了任务状态文本会被改成<code>待处理</code>外, 其余内容将会与保存前保持一致</p>\n<p>上述操作被封装为了<code>load_progress</code>这个方法<br>这个方法在程序启动的时候经过用户确认后会被调用</p>\n<h2 id=\"Tkinter-中的滚动页面的实现\"><a href=\"#Tkinter-中的滚动页面的实现\" class=\"headerlink\" title=\"Tkinter 中的滚动页面的实现\"></a>Tkinter 中的滚动页面的实现</h2><p>我最开始定义了一个继承自<code>tk.Frame</code>的滚动框架<code>VerticalScrolledFrame</code></p>\n<p>在用它展示条漫时我发现它的最大滚动范围在 31000px 左右, 这可能是<code>canvas</code>的极限</p>\n<p>层次结构是:<br>frame &gt; canvas &gt; frame &gt; 页面元素</p>\n<pre class=\"mermaid\"> \n\nflowchart LR\n\nsubgraph top_frame\n    subgraph canvas\n        subgraph bottom_frame\n            page_content\n        end\n    end\n    scrollbar[\n        S\n        c\n        r\n        o\n        l\n        l\n        b\n        a\n        r]\nend\n\n</pre>\n\n<p>emm大概长这样, 可能有些夸张了</p>\n<p>缺点是需要手动给页面元素绑定鼠标滚动等事件<br>纵向滚动条用于控制页面的滚动, 实质上是在控制<code>canvas</code>中的里层<code>frame</code>的上下移动</p>\n<p>这个框架被设计成宽度由内容物的宽度决定, 高度由用户定义<br>被用在了<code>SearchWindow</code>的<code>Notebook</code>的单个分页中</p>\n<p>如果需要左右滚动的话也同理了<br>加上一些自动调用的代码应该就能实现像橱窗那样的循环展示效果 <del>(虽然我没亲自写过)</del></p>\n<h2 id=\"互动视频剧情图展示器的实现\"><a href=\"#互动视频剧情图展示器的实现\" class=\"headerlink\" title=\"互动视频剧情图展示器的实现\"></a>互动视频剧情图展示器的实现</h2><p>整个剧情图的展示基于<code>tk.Canvas</code>画布, 在画布右侧和下方分别加上了纵向滚动条和横向滚动条</p>\n<p>最核心的内容是<code>self.plots</code>与<code>self.explored_plot_ids</code><br><code>self.plots</code>是一个装着(装着字典的列表)的列表, 分层存储着请求到的原始数据<br>节点们组成类似于有向图的结构, 像下面这样<br><del>一开始我其实是把它当作树来处理的</del></p>\n<pre class=\"mermaid\">\nflowchart TB\n    subgraph self.plots\n        subgraph layer_1\n            plot_1\n        end\n        subgraph layer_2\n            plot_2\n            plot_3\n            plot_4\n        end\n        subgraph layer_3\n            plot_5\n            plot_6\n        end\n    end\n\n    plot_1 --> plot_2\n    plot_1 --> plot_3\n    plot_1 --> plot_4\n    \n    plot_2 --> plot_5\n    plot_2 --> plot_6\n    \n    plot_3 --> plot_5\n    \n    plot_4 --> plot_5\n    \n    plot_6 --> plot_2\n</pre>\n<p><small><del>我超这个<code>mermaid</code>的牛魔绘图啊</del></small><br>分层是为了更有层次地绘图</p>\n<p>各个节点之间的连接由每个节点数据中包含的多个<code>jump_edge_id</code>确定</p>\n<p>为了方便画图, 引入了<code>self.explored_plot_ids</code>, <code>self.plot_coors</code><br><code>self.explored_plot_ids</code>是一个字典, 以<code>节点id: (节点所在的层的索引, 节点在层中的索引)</code>的形式存储节点id到节点数据的映射<br><code>self.plot_coors</code>是一个字典, 以<code>节点id: (节点在画布中的x坐标, y坐标, 节点块的宽, 节点块的高)</code>的形式存储节点id到节点块在画布中的位置的映射</p>\n<p>为了方便下载, 引入了<code>self.cid_map</code>和<code>self.avid_map</code>这两个字典<br>它们分别存储节点id到cid的映射和cid到avid的映射</p>\n<h3 id=\"节点的探索\"><a href=\"#节点的探索\" class=\"headerlink\" title=\"节点的探索\"></a>节点的探索</h3><p>互动视频有两个重要的id, 剧情图id<code>graph_id</code> 和 节点id<code>edge_id</code><br>剧情图id代表这个互动视频, 节点id代表它的节点</p>\n<blockquote>\n<p>剧情图id可以通过向<a href=\"api.bilibili.com/x/player/v2\">这个接口</a>提交互动视频的<code>cid</code>和(<code>avid</code>或<code>bvid</code>)得到</p>\n</blockquote>\n<blockquote>\n<p>每个节点id都有对应的<code>cid</code>, 配合互动视频的<code>bvid</code>或<code>avid</code>可以取到视频的流<br>初始节点的<code>cid</code>就是这个互动视频的<code>cid</code><br><small>其实互动视频的节点就是另一种形式的视频分P</small></p>\n</blockquote>\n<blockquote>\n<p>对接口的节点id参数传入<code>0</code>就可以获得初始节点的数据</p>\n</blockquote>\n<p>借由初始节点的数据, 可以得到它可能跳转到的节点们的id<br>再请求这些节点id的数据, 获得它们可能跳转到的节点们的id<br>就这么一直下去, 直到不再有新的节点id出现</p>\n<blockquote>\n<p>如果一个节点没有跳转到的节点, 就说明它是终止节点</p>\n</blockquote>\n<p>将每一轮上述操作获得的数据按轮分层 <small>(初始节点单独一层)</small>, 就完成了节点探索的操作</p>\n<h3 id=\"节点的绘制\"><a href=\"#节点的绘制\" class=\"headerlink\" title=\"节点的绘制\"></a>节点的绘制</h3><details><summary>先看效果()</summary>\n\n<p>目标视频: <a href=\"https://www.bilibili.com/video/BV1Pt4y1S7Wb/\">电棍家中的惨案</a></p>\n<p><img src=\"/assets/blogs/BiliTools-introduction/plot_shower.png\" alt=\"Plot_Shower\"></p>\n<p>起始节点被涂成淡红色, 终止节点被涂成淡绿色</p>\n</details>\n\n<p>遍历整个<code>self.plots</code>, 为每个节点绘制块, 然后为每个节点绘制跳转箭头</p>\n<ul>\n<li>如果节点跳转到的是下一层的节点, 那么直接连接即可 <small><del>原本想用贝塞尔曲线来连接的, 然后寄了</del></small></li>\n<li>否则则将箭头拉到画布顶部或底部, 绕到目标块所在层的后面进行连接(跳连)</li>\n</ul>\n<p>设置了一些偏移值来确保箭头的线不会重合.<br><small>(但是对于一些关系复杂的互动视频, 上述策略会造成跳连的箭头太多, 导致绘图非常混乱, 完全没法读)</small></p>\n<details><summary>翻车了</summary>\n\n<p>目标视频: <a href=\"https://www.bilibili.com/video/BV1eq4y1e7QF/\">收养澄闪</a></p>\n<p><img src=\"/assets/blogs/BiliTools-introduction/plot_shower_failed.png\" alt=\"Plot_Shower_failed\"></p>\n<p><del>视频做得太好导致的</del></p>\n</details>\n\n<p>以后可能会做一个生成<code>mermaid</code>流程图的功能? <del>(画饼ing)</del></p>\n<p>总之这玩意真就图一乐</p>\n<h3 id=\"交互\"><a href=\"#交互\" class=\"headerlink\" title=\"交互\"></a>交互</h3><h4 id=\"点击\"><a href=\"#点击\" class=\"headerlink\" title=\"点击\"></a>点击</h4><p>我想实现<code>当点击一个节点块的时候, 打开侧边栏并在其中展示这个节点的信息</code>这个交互逻辑</p>\n<p>首先来实现点击绘图对象罢.<br><small><code>tk.Canvas</code>其实是可以为其中的绘图对象绑定点击事件的, 但我当时不知道w</small><br>我给整个 canvas 绑定了一个点击事件, 根据坐标来判断被点击的节点块</p>\n<p>所谓的侧边栏, 是另一个隐藏在右边的框架<br>当它要显示的时候, canvas 的宽度会减小侧边栏的宽度那么多, 然后侧边栏框架出现</p>\n<p>值得注意的是, 我已经发现了超出 canvas 范围的的强制滚动会使我的点击事件错位这个问题, 我会在后续将它修复</p>\n<p><del>简称: 下次一定</del></p>\n<h4 id=\"拖动\"><a href=\"#拖动\" class=\"headerlink\" title=\"拖动\"></a>拖动</h4><p><small>写到这里的时候发现我之前写的拖动操作寄了</small></p>\n<p><del>那么今天的内容就到这里了让我们下次再见</del></p>\n<h1 id=\"Defects\"><a href=\"#Defects\" class=\"headerlink\" title=\"Defects\"></a>Defects</h1><h2 id=\"线程安全问题\"><a href=\"#线程安全问题\" class=\"headerlink\" title=\"线程安全问题\"></a>线程安全问题</h2><p>这个问题在 <a href=\"#%E4%B8%8B%E8%BD%BD%E5%99%A8%E7%9A%84%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91\">下载器的内部逻辑</a> 这部分有提到</p>\n<p>大概就是, 如果有多个线程<em>同时</em>操作一个<em>线程不安全</em>的对象, 就可能会出问题<br>Python 中的字典是线程安全的, 但是列表不是</p>\n<p>为了避免这个问题, 可以:</p>\n<ul>\n<li>给操作对象加上线程锁, 使同一时间只能有一个线程访问它</li>\n<li>换用线程安全的对象来存储信息</li>\n</ul>\n<p>上文提到的<code>修复</code>, 便是给对象加锁<br><del>结果加成了一坨 (恼)</del></p>\n<h2 id=\"默认参数评估问题\"><a href=\"#默认参数评估问题\" class=\"headerlink\" title=\"默认参数评估问题\"></a>默认参数评估问题</h2><p>这个问题潜伏了很久, 直到在我使用<code>custom_widgets</code>中的<code>run_with_gui</code>这个函数的时候才被发现</p>\n<details><summary>发现的过程</summary>\n\n<p>程序第一次调用<code>run_with_gui</code>时, <code>is_progress_hook_available</code>这个参数被传入了<code>True</code>.<br>这会使这个函数传入的<code>func</code>参数(这是一个函数)在后续的过程中被<em>额外传入</em>一个叫做<code>progress_hook</code>的字典, <code>func</code>函数可以通过修改这个字典来汇报任务的进度</p>\n<p>问题就在于额外传入这个操作上.<br>在老版本的程序中, 程序在准备阶段会直接修改先前传入的<code>kwargs</code>, 以便后续方便地使用<code>func(**kwargs)</code>来传入参数.<br>而我将<code>kwargs</code>的默认参数设定为了<code>&#123;&#125;</code>, 而不是<code>None</code>.</p>\n<p>第二次调用的时候到了, 这次<code>is_progress_hook_available</code>这个参数被传入了默认的<code>False</code>(这倒不是问题的所在), 按照程序的设计, <code>kwargs</code>不会被修改. 比较巧合的是, 第一次传入的函数只有<code>progress_hook</code>这一个参数, 而第二次的函数则是无参的, 两次调用的<code>kwargs</code>这个参数都没有被指定.<br>这就导致了后文所说的默认参数评估的问题.</p>\n<blockquote>\n<p><font color=red face=consolas>TypeError: self.func() got an unexpected keyword argument ‘progress_hook’</font></p>\n</blockquote>\n<p><del>解释器: Aughhhhhhhhh</del></p>\n</details>\n\n<p>虽然我自主地修复了这个问题, 并且知道它导致的问题是前一次调用影响到了后一次, 但以我的水平无法解释它的成因</p>\n<p>有请: GPT 先生!</p>\n<blockquote>\n<p>在Python中，函数的默认参数如果设置为字典（或其他可变数据类型，如列表、集合等），会有一个潜在的陷阱：如果默认参数在函数内部被修改了，那么这个修改会在未来的函数调用中持续存在。这是因为默认参数只会在函数定义时被评估一次，不是每次调用时都评估。这意味着，如果你修改了默认参数的内容，那么下一次调用函数时，默认参数的值不再是定义函数时指定的原始值。<br>这个行为对于不可变的默认值（例如None、整数、字符串等）通常不会导致问题，因为它们不会被函数调用所改变。然而，对于可变的默认值（例如字典、列表等），这种行为可能导致意外的副作用，因为如果函数内部修改了这些可变对象，这些修改会影响到下一次函数调用时这些默认参数的状态。</p>\n</blockquote>\n<details><summary>ChatGPT 举的例子</summary>\n\n<p>以一个列表作为默认参数的函数为例，来展示这个评估过程：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">append_to_list</span>(<span class=\"hljs-params\">value, my_list=[]</span>):  <span class=\"hljs-comment\"># 默认参数在这里被评估一次</span><br>    my_list.append(value)<br>    <span class=\"hljs-keyword\">return</span> my_list<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>my_list=[]</code> 是一个默认参数。这个默认参数的列表对象在函数定义时创建，并且只创建一次。如果你在函数内部修改了 <code>my_list</code>，比如通过调用 <code>append_to_list</code> 函数，那么你实际上是在修改这个单一的、在函数定义时创建的列表对象。这样，下一次调用 <code>append_to_list</code> 时，你将看到上一次调用的结果仍然保留在列表中，因为它是同一个列表对象。</p>\n<p>为了避免这种情况，你应该使用一个不可变的默认值，比如 <code>None</code>，然后在函数内部检查它，并在需要时创建一个新的列表：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">append_to_list</span>(<span class=\"hljs-params\">value, my_list=<span class=\"hljs-literal\">None</span></span>):<br>    <span class=\"hljs-keyword\">if</span> my_list <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:<br>        my_list = []  <span class=\"hljs-comment\"># 在这里为每次调用创建一个新的列表</span><br>    my_list.append(value)<br>    <span class=\"hljs-keyword\">return</span> my_list<br></code></pre></td></tr></table></figure>\n\n<p>在这个修正后的版本中，每次调用 <code>append_to_list</code> 时，如果没有提供 <code>my_list</code> 参数，就会创建一个新的空列表。这样，每次函数调用都是独立的，不会有意外的共享状态。</p>\n</details>\n\n<p>BiliTools 中的很多函数都被我像这样写了, 比如这个:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_video_download_thread</span>(<span class=\"hljs-params\">self, ..., subtitle_regulation=config[<span class=\"hljs-string\">&#x27;download&#x27;</span>][<span class=\"hljs-string\">&#x27;video&#x27;</span>][<span class=\"hljs-string\">&#x27;subtitle_lang_regulation&#x27;</span>], ...</span>):<br>    ...<br></code></pre></td></tr></table></figure>\n\n<p>这些问题目前还没有得到修复…<br><del>绝对不是因为我忘了! 我回头就去修!</del></p>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><blockquote>\n<p>未完待续…</p>\n</blockquote>\n"},{"title":"尝试介绍一下我的 Mirai 酱","date":"2024-02-08T02:00:00.000Z","_content":"\n<small><del>首先很抱歉先前那篇讲 BiliTools 的文章不更了，问就是太烂了讲不动一点</small></del>\n这次我想来讲一下我的 QQ 机器人，Mirai 酱\n\n事先声明，本文中的信息并不可靠，请不要盲目相信……\n\n# Mirai 酱的故事\n\n最初想要做一个自己的 QQ 机器人，应该是在某位群友在群里询问了关于机器人的事之后。  \n~~后来他拉着他的机器人`凯尔希`进了群，不过不知为何最后却似了。~~\n\n## 最初的 Mirai 酱\n\n翻了下我的程序存档，Mirai 酱最早是在 2022 年 4 月左右被我编写出来的，当时基于[`Ariadne`](https://github.com/GraiaProject/Ariadne)和[`mirai`](https://github.com/mamoe/mirai)。  \n> Mirai 酱之所以叫 Mirai 酱，正是因为她最开始基于的框架是`mirai` ~~（绝对不是因为我是个起名废物qwq）~~  \n\n这是 Mirai 酱的第一代，拥有 B站动态转发、随机涩图、天气查询、每日抽签、疫情查询（在之后移除） 功能。（其实当然可以写更多，只是我没点子了）  \n\n后来不知道什么时候，`mirai`框架似乎似了，Mirai 酱也被我忘记了一段时间。直到……  \n我找到了`go-cqhttp`这个框架。\n> 在找引用链接的时候我发现`mirai`框架原来还活着，而且社区也跟进了签名服务器插件的开发（但框架换了就是换了，也没有换回去这种说法了）\n\n## 重生的 Mirai 酱\n\nMirai 酱第二代的完成大约是在 2023 年 6 月 12 日左右，基于[`pycqBot`](https://github.com/FengLiuFeseliud/pycqBot)和[`go-cqhttp`](https://github.com/Mrs4s/go-cqhttp)。在 8 月 24 日左右追加了`unidbg-fetch-qsign`来进行签名认证。  \n这一代的 Mirai 酱功能没有增加，甚至还减少了一个天气查询功能。~~（天气查询真没人用罢，交互还难写）~~  \n~~不过群友们在 Mirai 酱复活赛打赢之后还是很高兴，甚至发起了电~~\n\n## 现在的 Mirai 酱\n\nMirai 酱第三代的大致完成大致是在 2024 年 2 月 8 日零点左右  \n这一代的 Mirai 酱新增了方舟模拟抽卡的插件，并且每个插件都可以单独为某个群开启或关闭。  \n\n这次的框架迁移是因为`go-cqhttp`的停止维护（详见：[QQBot的未来以及迁移建议](https://github.com/Mrs4s/go-cqhttp/issues/2471)）。尽管 Mirai 酱还没因为这个出现什么问题，我还是根据他们的建议将 Mirai 酱迁移到了[`OpenShamrock`](https://github.com/whitechi73/OpenShamrock)框架。  \n\n然后我就发现虽然`go-cqhttp`和`shamrock`都是遵循[`onebot`](https://github.com/botuniverse/onebot)标准的，但是`pycqBot`在与`shamrock`交互的时候始终有莫名其妙的问题。于是我就仿照`pycqBot`专门为`shamrock`写了一个简易框架（有直接使用`pycqBot`中的一些代码，比如`cqcode`的实现），已经能够满足 Mirai 酱的需求了。不过因为实在是太简易了，以至于插件写起来与`pycqBot`相比有亿点麻烦（恼）  \nemm 就当作是 Python 练习了罢（？）  \n~~：你说得对，但是这就是重复造轮子的沙贝操作（全恼）~~\n\n`shamrock`被我部署在了我的小主机上的 PVE 里，依靠`BlissOS`运行。（参考：[PVE下安装BlissOS11](https://www.bilibili.com/video/BV1Mj411e7V9/)）  \n> 因为 tx 的作品实在是太“精致”了，为了 QQ 能够比较稳定地运行，我不得不给 BlissOS  开了 6GB 的 RAM\n\n主要的 Python 程序被我部署在了 PVE 中的另一台 Debian 12 上 ~~目前挂了一天一夜还没有出问题~~  \n\n# 关于简易框架\n\n> 十分甚至九分感谢`pycqBot`项目，提供了思路和具体实现供我~~照搬~~参考  \n\n<del><small>所以说这个简易框架，应该算是`mini-pycqBot`？（大雾）</small></del>\n\n## 通信方式\n\n和`pycqBot`一样，都是\n- 用`websocket`接收框架的事件上报\n- 用`http`发送指令到框架\n\n额外支持了cookies的长期储存，但是保存方式是pickle（逃\n\n~~其实也尝试着写了json保存，但是不行，B站的接口不认。大概是我漏了什么细节罢~~\n\n## 各部分关系\n\n```yaml\nlemonyBot:\n- __init__.py\n- base.py:          # 通信基础\n    - SocketBase    # 提供 WebSocket 通信方法\n    - HttpBase      # 提供 HTTP 通信方法\n- apps.py:\n    - SocketApp     # 封装了消息上报的接收（基本抄自 pycqBot）\n    - HttpApp       # 封装了接口（基本抄自 shamrock 文档）\n- bot.py:\n    - Bot           # 将 ws 和 http 部分结合到一起\n- objects.py:\n    - Plugin        # 插件对象的父类\n- cqcode.py         # 照搬自 pycqBot\n```\n\n<pre class=\"mermaid\">\nflowchart LR\nSocketBase --> SocketApp --> Bot\nHttpBase --> HttpApp --> Bot\nPlugin\n</pre>\n\n## 插件系统的实现\n\n使用`Bot.load_plugin()`加载一个插件实例之后，这个实例会被保存在`Bot._plugins`列表中  \n\n每当`SocketApp`收到消息上报时，它会根据消息的类型挨个去尝试调用插件们的对应方法，如果插件定义了对应的方法，它就会把消息包传给这个方法。  \n（消息类型的名字的生成照抄了`pycqBot`）\n\n当插件想要发送指令时，它只需要调用自身对应名字的方法即可。这些方法在`Plugin`父类中被批量预先定义（且分为普通和异步版本）\n这些方法对`Bot.call_api()`进行了封装，这样他们就只需要传入参数，而不用传入方法名了\n\n## 如何使用\n\n<small><del>老实说，真的会有人来用这个框架吗……</del></small>  \n就当是写给自己看的了，免得以后想搓新插件的时候又忘了\n\n### 简单的使用\n\n入口模块至少应该长这个样子：\n```python\n# 框架主体应当被最先导入\nimport lemonyBot\n# 导入各个插件类\nfrom plugins.MyPlugin import MyPlugin\n\n# 实例化Bot，记得改成自己的参数\nbot = lemonyBot.Bot(**{\n    \"ws_host\": \"127.0.0.1:1145\",\n    \"http_host\": \"127.0.0.1:1919\",\n    \"authkey\": \"aughhhhhhhhhhhhhh\",\n})\n# 设置管理员QQ号（选）\nbot.set_config(admins=[114514])\n# 挨个加载插件（的实例）\nbot.load_plugin(MyPlugin(bot))\n# 启动\nbot.start()\n```\n~~连我自己都觉得麻烦了~~  \n往后可能会优化一下导入方法，写成像`pycqBot`那样的：\n```python\nbot.plugin_load([\n    \"MyPlugin\"\n    ])\n```\n真的方便吧我靠 ~~再看看我这个简直就是原神~~\n\n> 上面设置的管理员不同于群里的管理员，而是 Bot 的管理员。\n> 插件可以通过这个来校验一些只有 Bot 主人才能有的权限。\n> （当然一个插件里都没写的话这个东西也就没用了）\n\n### 插件开发\n\n一个插件至少应该长这个样子：\n```python\n# 导入必需的模板\nfrom lemonyBot import Plugin, cqcode, Bot\n\n# 定义插件类，父类必须为 Plugin\nclass MyPlugin(Plugin):\n    def __init__(self, bot: Bot):\n        super().__init__(bot)\n        self.bot: Bot\n        # 在这后面加一些自己的初始化操作比如加载涩图数据\n    \n    # 定义用于接受上报事件的方法，参数为一个 dict\n    # 在 bot 收到这个类型的消息时会被自动调用\n    # event 的详细内容自己去查 shamrock 之类的文档\n    def message_group_normal(self, event: dict):\n        # 这里是对消息的过滤，emm就是设定回复触发的条件\n        # 按照自己的需求来，自由度是真的大罢\n        if event[\"message\"].lower().strip() == \"ciallo\":\n            # 调用预定义的方法，这里是普通版，没有返回值\n            # 要检查消息的发送结果请使用异步版方法\n            # ↑ 比如：self.send_group_msg_async()\n            # 异步版的返回值自己去查对应文档（这里是shamrock）\n            # 方法只接受一个字典参数，以后可能会加一个 **kwargs 调用方法\n            self.send_group_msg_func(\n                # 这个字典的键值就是接口的参数\n                # 具体参数需要你去查 shamrock 之类的文档\n                {\n                    \"group_id\": event[\"group_id\"],\n                    # 使用 cqcode 添加各种特殊消息 比如回复、图片\n                    # cqcode 模块的使用方法详见 pycqBot 的文档\n                    # 关于 cqcode 可以去看 go-cqhttp 文档\n                    # cqcode 是字符串，可以直接与正文拼接\n                    \"message\": cqcode.reply(msg_id=event[\"message_id\"])\n                    + \"Ciallo～(∠・ω< )⌒☆\",\n                    \"auto_escape\": False,\n                }\n            )\n        # 达到了对群里发出的每一条 ciallo 都回复一个 Ciallo～(∠・ω< )⌒☆ 的效果\n```\n普通版方法和异步版方法的名字只差一个后缀，是`_func`还是`_async`  \n可以使用`self.bot.add_task()`来借助简易框架内置的给`aiohttp`用的事件循环运行自己的协程  \n（异步自己去学，我讲不清楚的w）\n\n通过`self.admins`可以得到 Bot 的管理员们的QQ，以此来实现鉴权之类的操作  \n插件有需要网络请求的部分可以搞依赖注入，来使用`self.bot.request`这个写好的网络请求\n\n可供参考的资料：\n- [山姆摇滚文档](https://whitechi73.github.io/OpenShamrock/)\n- [go-cqhttp文档](https://docs.go-cqhttp.org/cqcode/)\n- [pycqBot文档](https://fengliufeseliud.github.io/pycqBot/)\n\n## 缺陷\n\n如你所见，这个简易框架：\n1. 没有定义消息类之类的简化处理流程之类的东西，而是直接让开发者处理事件字典\n2. 没有把接口的参数之类的写到程序里，而是要你自己去查文档\n3. 没有快捷的回复功能，必须自己手动生成`cqcode`来加到回复消息里（应该算是第一条的一部分）\n4. 没有像[这个](https://graia.readthedocs.io/ariadne/feature/base-parser/)一样的方便的消息筛选系统、鉴权系统，全都要开发者自己写\n5. 没有统一的插件启用禁用系统，各个插件是割裂的\n6. 还有很多……\n\n~~笑嘻了，我消息筛选用正则表达式用到似~~\n\n总之就是非常的简陋就是了，你要什么得自己来，一点都不开箱即用。\n\n不过反正都是自用的就是了 <small><del>我怎么写也没人能管我（小声）</del></small>\n\n# 关于 Mirai 酱的插件们\n\n## 涩图插件\n\n插件名：EroPicSender\n\n### 运行逻辑\n\n<pre class=\"mermaid\">\nflowchart TB\n\naskforsetu[/群友找Mirai酱要涩图/] --> checkperm\ncheckperm{检查插件开关} -- 关 -->reject\nreject[拒绝]\ncheckperm -- 开 --> checkcd\ncheckcd{检查冷却时间} -- 到了 --> getsetudata\ncheckcd -- 没到 --> reject\ngetsetudata[获得涩图数据] --> download[下载涩图本体] --> checktag\nchecktag{检查涩图标签\\n（R18之类的）} -- 能发 --> sendwithimg[发送图片] --> withdraw\nsendwithimg --> checkassets\nchecktag -- 不能发 --> sendwithoutimg[仅发送文字描述] --> checkassets\nwithdraw[等待1分钟后撤回涩图]\n\ncache[(涩图缓存)] -.-> getsetudata\ncheckassets{检查涩图缓存} -- 不足 --> 获取一包新的涩图 -.-> cache\ncheckassets -- 充足 --> over[什么都不做]\ncheckassets -.- cache\n\ninit[/插件初始化/] --> loadcache\nloadcache[从文件加载保存的缓存] --> checkassets\nloadcache -.-> cache\n\n</pre> \n\n（尝试用 mermaid 做了流程图，但是一坨） \n\n- 管理员可以无视插件开关要涩图  \n- 涩图下载失败也会发送提示\n- 涩图发送失败会改为仅发送文字描述  \n- 涩图发送成功后会在两分钟后撤回\n- 程序退出时会保存缓存到文件\n\n### 图源\n\n来自 [Lolicon API](https://api.lolicon.app/)，非常感谢它的开发者\n\n## 明日方舟抽卡模拟\n\n插件名：ArknightsGacha\n\n### 数据获取\n\n干员列表来自 [BiliGame Wiki](https://wiki.biligame.com/arknights/%E5%B9%B2%E5%91%98%E6%95%B0%E6%8D%AE%E8%A1%A8)  \n把获取的网页用 xpath 一翻，数据就来了\n\n> 什么？为什么不是 PRTS ？\n\n~~因为 B 站他直接把数据丢网页源代码里了，大好人属于是~~\n\n根据干员的获取途径生成中坚和常驻两个池子  \n~~限定池子理论上也能做，但是群友急了于是先这样了~~\n\n能够通过指令让 Mirai 酱立即更新干员数据\n\n### 运行逻辑\n\n插件初始化时会从本地加载保存的干员数据  \n加载完毕后生成两个字典（代表中坚和标准两个池子），键为星级，值为对应的干员列表  \n\n每次请求抽卡时定义一个初始概率表：\n```python\n{\n    3: 0.4,\n    4: 0.5,\n    5: 0.08,\n    6: 0.02,\n}\n```\n很明显 键是星级，值是概率  \n\n抽卡会传入一个`combo`值，代表连续抽了多少抽没出 6 星。这个值可以经由群员的QQ号查到，用以实现 “若连续 50 发未出 6 星，下次 6 星概率增加 2%，直到第 100 发时必出 6 星” 的设定  \n抽卡函数会根据上述逻辑对初始概率表进行修改，然后通过带权重的随机来确定抽到的星级，最后用初始化时生成的字典来得到具体抽到的干员数据，返回给负责交互的部分\n\n`combo`值由负责交互的那一坨保管，每当抽到 6 星时这个值就重设为`0`\n在收到干员数据之后负责交互的那部分便生成文本，回复给群友\n\n## B 站动态转发\n\n插件名：BiliDynamicForwarder\n\n需要配合`BiliLogin`插件食用\n\n### 运行逻辑\n\n每 5 分钟请求一遍监听对象们的历史动态，与上一次请求的数据比对，找出新发布的进行发送  \n~~↑ emm我的“找出新发布的动态”这个部分似乎还有点问题，时不时就会把历史的某一条动态刨出来发了~~\n\n如果动态内容命中了黑关键词，那么它将不会被发送；  \n但是如果同时又命中了白关键词，那么它还是会被发送。\n\n这个插件的交互部分主要就是设置监听对象，逻辑还挺简单的，难写的原因是没有现成的鉴权和指令系统  \n其余部分都是主动发送了没什么好说的  \n\n自动维护一个用 B 站 uid 查昵称的字典，用来方便添加移除监听对象\n\n### 关于接口\n\n来自易姐的 [`bilibili-API-collect`](https://socialsisteryi.github.io/bilibili-API-collect/) ，非常感谢 ta  \n函数封装由我实现，弄得一坨\n\n~~emm注意到动态获取接口已经有了新的、更优雅的替代方案，但是我懒~~\n\n## 萌属性抽取\n\n插件名：MoeAttriLottery\n\n之前写好这个插件的时候还有些沾沾自喜，然后看了别人家的机器人才发现，这其实是几年前就玩过时了的东西w  \n~~果然是你能想得到的东西，别人早就想到了~~\n\n### 数据源\n\n由我整理自萌娘百科-[萌属性](https://zh.moegirl.org.cn/%E8%90%8C%E5%B1%9E%E6%80%A7)\n\n### 运行逻辑\n\n非常简单的带权重的随机抽取而已，一天仅能抽一次\n\n拥有权重机制，比如我能把年龄属性中的“萝莉”调到`10`，其他全为`1`😋  \n\n拥有主副属性机制，当抽到的主属性在副属性中有键时，会再抽一个副属性出来  \n比如抽到了渐变色瞳，还可以再抽到一个红->蓝渐变的细分支  \n\n## B站登录\n\n插件名：BiliLogin\n\n因为最近B站对获取动态的接口加了风控，非登录情况下的请求难度大幅提升，于是加紧写了这个插件用于登录\n\n登录后cookies会自动留在bot框架中，B站动态转发插件可以直接使用\n\n仅能通过管理员私聊进行扫码登录，不知道时间久了会不会出问题\n\n---\n\nemm 大概就是这样，以后应该还会继续维护 Mirai 酱的，有种养女儿的快感 😋\n\n","source":"_posts/Try-to-introduce-my-MiraiChan.md","raw":"---\ntitle: '尝试介绍一下我的 Mirai 酱'\ndate: 2024-02-08 10:00:00\ntags: [Python, onebot, QQ, shamrock]\ncategories: [Program]\n---\n\n<small><del>首先很抱歉先前那篇讲 BiliTools 的文章不更了，问就是太烂了讲不动一点</small></del>\n这次我想来讲一下我的 QQ 机器人，Mirai 酱\n\n事先声明，本文中的信息并不可靠，请不要盲目相信……\n\n# Mirai 酱的故事\n\n最初想要做一个自己的 QQ 机器人，应该是在某位群友在群里询问了关于机器人的事之后。  \n~~后来他拉着他的机器人`凯尔希`进了群，不过不知为何最后却似了。~~\n\n## 最初的 Mirai 酱\n\n翻了下我的程序存档，Mirai 酱最早是在 2022 年 4 月左右被我编写出来的，当时基于[`Ariadne`](https://github.com/GraiaProject/Ariadne)和[`mirai`](https://github.com/mamoe/mirai)。  \n> Mirai 酱之所以叫 Mirai 酱，正是因为她最开始基于的框架是`mirai` ~~（绝对不是因为我是个起名废物qwq）~~  \n\n这是 Mirai 酱的第一代，拥有 B站动态转发、随机涩图、天气查询、每日抽签、疫情查询（在之后移除） 功能。（其实当然可以写更多，只是我没点子了）  \n\n后来不知道什么时候，`mirai`框架似乎似了，Mirai 酱也被我忘记了一段时间。直到……  \n我找到了`go-cqhttp`这个框架。\n> 在找引用链接的时候我发现`mirai`框架原来还活着，而且社区也跟进了签名服务器插件的开发（但框架换了就是换了，也没有换回去这种说法了）\n\n## 重生的 Mirai 酱\n\nMirai 酱第二代的完成大约是在 2023 年 6 月 12 日左右，基于[`pycqBot`](https://github.com/FengLiuFeseliud/pycqBot)和[`go-cqhttp`](https://github.com/Mrs4s/go-cqhttp)。在 8 月 24 日左右追加了`unidbg-fetch-qsign`来进行签名认证。  \n这一代的 Mirai 酱功能没有增加，甚至还减少了一个天气查询功能。~~（天气查询真没人用罢，交互还难写）~~  \n~~不过群友们在 Mirai 酱复活赛打赢之后还是很高兴，甚至发起了电~~\n\n## 现在的 Mirai 酱\n\nMirai 酱第三代的大致完成大致是在 2024 年 2 月 8 日零点左右  \n这一代的 Mirai 酱新增了方舟模拟抽卡的插件，并且每个插件都可以单独为某个群开启或关闭。  \n\n这次的框架迁移是因为`go-cqhttp`的停止维护（详见：[QQBot的未来以及迁移建议](https://github.com/Mrs4s/go-cqhttp/issues/2471)）。尽管 Mirai 酱还没因为这个出现什么问题，我还是根据他们的建议将 Mirai 酱迁移到了[`OpenShamrock`](https://github.com/whitechi73/OpenShamrock)框架。  \n\n然后我就发现虽然`go-cqhttp`和`shamrock`都是遵循[`onebot`](https://github.com/botuniverse/onebot)标准的，但是`pycqBot`在与`shamrock`交互的时候始终有莫名其妙的问题。于是我就仿照`pycqBot`专门为`shamrock`写了一个简易框架（有直接使用`pycqBot`中的一些代码，比如`cqcode`的实现），已经能够满足 Mirai 酱的需求了。不过因为实在是太简易了，以至于插件写起来与`pycqBot`相比有亿点麻烦（恼）  \nemm 就当作是 Python 练习了罢（？）  \n~~：你说得对，但是这就是重复造轮子的沙贝操作（全恼）~~\n\n`shamrock`被我部署在了我的小主机上的 PVE 里，依靠`BlissOS`运行。（参考：[PVE下安装BlissOS11](https://www.bilibili.com/video/BV1Mj411e7V9/)）  \n> 因为 tx 的作品实在是太“精致”了，为了 QQ 能够比较稳定地运行，我不得不给 BlissOS  开了 6GB 的 RAM\n\n主要的 Python 程序被我部署在了 PVE 中的另一台 Debian 12 上 ~~目前挂了一天一夜还没有出问题~~  \n\n# 关于简易框架\n\n> 十分甚至九分感谢`pycqBot`项目，提供了思路和具体实现供我~~照搬~~参考  \n\n<del><small>所以说这个简易框架，应该算是`mini-pycqBot`？（大雾）</small></del>\n\n## 通信方式\n\n和`pycqBot`一样，都是\n- 用`websocket`接收框架的事件上报\n- 用`http`发送指令到框架\n\n额外支持了cookies的长期储存，但是保存方式是pickle（逃\n\n~~其实也尝试着写了json保存，但是不行，B站的接口不认。大概是我漏了什么细节罢~~\n\n## 各部分关系\n\n```yaml\nlemonyBot:\n- __init__.py\n- base.py:          # 通信基础\n    - SocketBase    # 提供 WebSocket 通信方法\n    - HttpBase      # 提供 HTTP 通信方法\n- apps.py:\n    - SocketApp     # 封装了消息上报的接收（基本抄自 pycqBot）\n    - HttpApp       # 封装了接口（基本抄自 shamrock 文档）\n- bot.py:\n    - Bot           # 将 ws 和 http 部分结合到一起\n- objects.py:\n    - Plugin        # 插件对象的父类\n- cqcode.py         # 照搬自 pycqBot\n```\n\n<pre class=\"mermaid\">\nflowchart LR\nSocketBase --> SocketApp --> Bot\nHttpBase --> HttpApp --> Bot\nPlugin\n</pre>\n\n## 插件系统的实现\n\n使用`Bot.load_plugin()`加载一个插件实例之后，这个实例会被保存在`Bot._plugins`列表中  \n\n每当`SocketApp`收到消息上报时，它会根据消息的类型挨个去尝试调用插件们的对应方法，如果插件定义了对应的方法，它就会把消息包传给这个方法。  \n（消息类型的名字的生成照抄了`pycqBot`）\n\n当插件想要发送指令时，它只需要调用自身对应名字的方法即可。这些方法在`Plugin`父类中被批量预先定义（且分为普通和异步版本）\n这些方法对`Bot.call_api()`进行了封装，这样他们就只需要传入参数，而不用传入方法名了\n\n## 如何使用\n\n<small><del>老实说，真的会有人来用这个框架吗……</del></small>  \n就当是写给自己看的了，免得以后想搓新插件的时候又忘了\n\n### 简单的使用\n\n入口模块至少应该长这个样子：\n```python\n# 框架主体应当被最先导入\nimport lemonyBot\n# 导入各个插件类\nfrom plugins.MyPlugin import MyPlugin\n\n# 实例化Bot，记得改成自己的参数\nbot = lemonyBot.Bot(**{\n    \"ws_host\": \"127.0.0.1:1145\",\n    \"http_host\": \"127.0.0.1:1919\",\n    \"authkey\": \"aughhhhhhhhhhhhhh\",\n})\n# 设置管理员QQ号（选）\nbot.set_config(admins=[114514])\n# 挨个加载插件（的实例）\nbot.load_plugin(MyPlugin(bot))\n# 启动\nbot.start()\n```\n~~连我自己都觉得麻烦了~~  \n往后可能会优化一下导入方法，写成像`pycqBot`那样的：\n```python\nbot.plugin_load([\n    \"MyPlugin\"\n    ])\n```\n真的方便吧我靠 ~~再看看我这个简直就是原神~~\n\n> 上面设置的管理员不同于群里的管理员，而是 Bot 的管理员。\n> 插件可以通过这个来校验一些只有 Bot 主人才能有的权限。\n> （当然一个插件里都没写的话这个东西也就没用了）\n\n### 插件开发\n\n一个插件至少应该长这个样子：\n```python\n# 导入必需的模板\nfrom lemonyBot import Plugin, cqcode, Bot\n\n# 定义插件类，父类必须为 Plugin\nclass MyPlugin(Plugin):\n    def __init__(self, bot: Bot):\n        super().__init__(bot)\n        self.bot: Bot\n        # 在这后面加一些自己的初始化操作比如加载涩图数据\n    \n    # 定义用于接受上报事件的方法，参数为一个 dict\n    # 在 bot 收到这个类型的消息时会被自动调用\n    # event 的详细内容自己去查 shamrock 之类的文档\n    def message_group_normal(self, event: dict):\n        # 这里是对消息的过滤，emm就是设定回复触发的条件\n        # 按照自己的需求来，自由度是真的大罢\n        if event[\"message\"].lower().strip() == \"ciallo\":\n            # 调用预定义的方法，这里是普通版，没有返回值\n            # 要检查消息的发送结果请使用异步版方法\n            # ↑ 比如：self.send_group_msg_async()\n            # 异步版的返回值自己去查对应文档（这里是shamrock）\n            # 方法只接受一个字典参数，以后可能会加一个 **kwargs 调用方法\n            self.send_group_msg_func(\n                # 这个字典的键值就是接口的参数\n                # 具体参数需要你去查 shamrock 之类的文档\n                {\n                    \"group_id\": event[\"group_id\"],\n                    # 使用 cqcode 添加各种特殊消息 比如回复、图片\n                    # cqcode 模块的使用方法详见 pycqBot 的文档\n                    # 关于 cqcode 可以去看 go-cqhttp 文档\n                    # cqcode 是字符串，可以直接与正文拼接\n                    \"message\": cqcode.reply(msg_id=event[\"message_id\"])\n                    + \"Ciallo～(∠・ω< )⌒☆\",\n                    \"auto_escape\": False,\n                }\n            )\n        # 达到了对群里发出的每一条 ciallo 都回复一个 Ciallo～(∠・ω< )⌒☆ 的效果\n```\n普通版方法和异步版方法的名字只差一个后缀，是`_func`还是`_async`  \n可以使用`self.bot.add_task()`来借助简易框架内置的给`aiohttp`用的事件循环运行自己的协程  \n（异步自己去学，我讲不清楚的w）\n\n通过`self.admins`可以得到 Bot 的管理员们的QQ，以此来实现鉴权之类的操作  \n插件有需要网络请求的部分可以搞依赖注入，来使用`self.bot.request`这个写好的网络请求\n\n可供参考的资料：\n- [山姆摇滚文档](https://whitechi73.github.io/OpenShamrock/)\n- [go-cqhttp文档](https://docs.go-cqhttp.org/cqcode/)\n- [pycqBot文档](https://fengliufeseliud.github.io/pycqBot/)\n\n## 缺陷\n\n如你所见，这个简易框架：\n1. 没有定义消息类之类的简化处理流程之类的东西，而是直接让开发者处理事件字典\n2. 没有把接口的参数之类的写到程序里，而是要你自己去查文档\n3. 没有快捷的回复功能，必须自己手动生成`cqcode`来加到回复消息里（应该算是第一条的一部分）\n4. 没有像[这个](https://graia.readthedocs.io/ariadne/feature/base-parser/)一样的方便的消息筛选系统、鉴权系统，全都要开发者自己写\n5. 没有统一的插件启用禁用系统，各个插件是割裂的\n6. 还有很多……\n\n~~笑嘻了，我消息筛选用正则表达式用到似~~\n\n总之就是非常的简陋就是了，你要什么得自己来，一点都不开箱即用。\n\n不过反正都是自用的就是了 <small><del>我怎么写也没人能管我（小声）</del></small>\n\n# 关于 Mirai 酱的插件们\n\n## 涩图插件\n\n插件名：EroPicSender\n\n### 运行逻辑\n\n<pre class=\"mermaid\">\nflowchart TB\n\naskforsetu[/群友找Mirai酱要涩图/] --> checkperm\ncheckperm{检查插件开关} -- 关 -->reject\nreject[拒绝]\ncheckperm -- 开 --> checkcd\ncheckcd{检查冷却时间} -- 到了 --> getsetudata\ncheckcd -- 没到 --> reject\ngetsetudata[获得涩图数据] --> download[下载涩图本体] --> checktag\nchecktag{检查涩图标签\\n（R18之类的）} -- 能发 --> sendwithimg[发送图片] --> withdraw\nsendwithimg --> checkassets\nchecktag -- 不能发 --> sendwithoutimg[仅发送文字描述] --> checkassets\nwithdraw[等待1分钟后撤回涩图]\n\ncache[(涩图缓存)] -.-> getsetudata\ncheckassets{检查涩图缓存} -- 不足 --> 获取一包新的涩图 -.-> cache\ncheckassets -- 充足 --> over[什么都不做]\ncheckassets -.- cache\n\ninit[/插件初始化/] --> loadcache\nloadcache[从文件加载保存的缓存] --> checkassets\nloadcache -.-> cache\n\n</pre> \n\n（尝试用 mermaid 做了流程图，但是一坨） \n\n- 管理员可以无视插件开关要涩图  \n- 涩图下载失败也会发送提示\n- 涩图发送失败会改为仅发送文字描述  \n- 涩图发送成功后会在两分钟后撤回\n- 程序退出时会保存缓存到文件\n\n### 图源\n\n来自 [Lolicon API](https://api.lolicon.app/)，非常感谢它的开发者\n\n## 明日方舟抽卡模拟\n\n插件名：ArknightsGacha\n\n### 数据获取\n\n干员列表来自 [BiliGame Wiki](https://wiki.biligame.com/arknights/%E5%B9%B2%E5%91%98%E6%95%B0%E6%8D%AE%E8%A1%A8)  \n把获取的网页用 xpath 一翻，数据就来了\n\n> 什么？为什么不是 PRTS ？\n\n~~因为 B 站他直接把数据丢网页源代码里了，大好人属于是~~\n\n根据干员的获取途径生成中坚和常驻两个池子  \n~~限定池子理论上也能做，但是群友急了于是先这样了~~\n\n能够通过指令让 Mirai 酱立即更新干员数据\n\n### 运行逻辑\n\n插件初始化时会从本地加载保存的干员数据  \n加载完毕后生成两个字典（代表中坚和标准两个池子），键为星级，值为对应的干员列表  \n\n每次请求抽卡时定义一个初始概率表：\n```python\n{\n    3: 0.4,\n    4: 0.5,\n    5: 0.08,\n    6: 0.02,\n}\n```\n很明显 键是星级，值是概率  \n\n抽卡会传入一个`combo`值，代表连续抽了多少抽没出 6 星。这个值可以经由群员的QQ号查到，用以实现 “若连续 50 发未出 6 星，下次 6 星概率增加 2%，直到第 100 发时必出 6 星” 的设定  \n抽卡函数会根据上述逻辑对初始概率表进行修改，然后通过带权重的随机来确定抽到的星级，最后用初始化时生成的字典来得到具体抽到的干员数据，返回给负责交互的部分\n\n`combo`值由负责交互的那一坨保管，每当抽到 6 星时这个值就重设为`0`\n在收到干员数据之后负责交互的那部分便生成文本，回复给群友\n\n## B 站动态转发\n\n插件名：BiliDynamicForwarder\n\n需要配合`BiliLogin`插件食用\n\n### 运行逻辑\n\n每 5 分钟请求一遍监听对象们的历史动态，与上一次请求的数据比对，找出新发布的进行发送  \n~~↑ emm我的“找出新发布的动态”这个部分似乎还有点问题，时不时就会把历史的某一条动态刨出来发了~~\n\n如果动态内容命中了黑关键词，那么它将不会被发送；  \n但是如果同时又命中了白关键词，那么它还是会被发送。\n\n这个插件的交互部分主要就是设置监听对象，逻辑还挺简单的，难写的原因是没有现成的鉴权和指令系统  \n其余部分都是主动发送了没什么好说的  \n\n自动维护一个用 B 站 uid 查昵称的字典，用来方便添加移除监听对象\n\n### 关于接口\n\n来自易姐的 [`bilibili-API-collect`](https://socialsisteryi.github.io/bilibili-API-collect/) ，非常感谢 ta  \n函数封装由我实现，弄得一坨\n\n~~emm注意到动态获取接口已经有了新的、更优雅的替代方案，但是我懒~~\n\n## 萌属性抽取\n\n插件名：MoeAttriLottery\n\n之前写好这个插件的时候还有些沾沾自喜，然后看了别人家的机器人才发现，这其实是几年前就玩过时了的东西w  \n~~果然是你能想得到的东西，别人早就想到了~~\n\n### 数据源\n\n由我整理自萌娘百科-[萌属性](https://zh.moegirl.org.cn/%E8%90%8C%E5%B1%9E%E6%80%A7)\n\n### 运行逻辑\n\n非常简单的带权重的随机抽取而已，一天仅能抽一次\n\n拥有权重机制，比如我能把年龄属性中的“萝莉”调到`10`，其他全为`1`😋  \n\n拥有主副属性机制，当抽到的主属性在副属性中有键时，会再抽一个副属性出来  \n比如抽到了渐变色瞳，还可以再抽到一个红->蓝渐变的细分支  \n\n## B站登录\n\n插件名：BiliLogin\n\n因为最近B站对获取动态的接口加了风控，非登录情况下的请求难度大幅提升，于是加紧写了这个插件用于登录\n\n登录后cookies会自动留在bot框架中，B站动态转发插件可以直接使用\n\n仅能通过管理员私聊进行扫码登录，不知道时间久了会不会出问题\n\n---\n\nemm 大概就是这样，以后应该还会继续维护 Mirai 酱的，有种养女儿的快感 😋\n\n","slug":"Try-to-introduce-my-MiraiChan","published":1,"updated":"2024-04-05T11:09:43.571Z","_id":"clscnryal0000rso19pqe6rb9","comments":1,"layout":"post","photos":[],"content":"<p><small><del>首先很抱歉先前那篇讲 BiliTools 的文章不更了，问就是太烂了讲不动一点</small></del><br>这次我想来讲一下我的 QQ 机器人，Mirai 酱</p>\n<p>事先声明，本文中的信息并不可靠，请不要盲目相信……</p>\n<h1 id=\"Mirai-酱的故事\"><a href=\"#Mirai-酱的故事\" class=\"headerlink\" title=\"Mirai 酱的故事\"></a>Mirai 酱的故事</h1><p>最初想要做一个自己的 QQ 机器人，应该是在某位群友在群里询问了关于机器人的事之后。<br><del>后来他拉着他的机器人<code>凯尔希</code>进了群，不过不知为何最后却似了。</del></p>\n<h2 id=\"最初的-Mirai-酱\"><a href=\"#最初的-Mirai-酱\" class=\"headerlink\" title=\"最初的 Mirai 酱\"></a>最初的 Mirai 酱</h2><p>翻了下我的程序存档，Mirai 酱最早是在 2022 年 4 月左右被我编写出来的，当时基于<a href=\"https://github.com/GraiaProject/Ariadne\"><code>Ariadne</code></a>和<a href=\"https://github.com/mamoe/mirai\"><code>mirai</code></a>。  </p>\n<blockquote>\n<p>Mirai 酱之所以叫 Mirai 酱，正是因为她最开始基于的框架是<code>mirai</code> <del>（绝对不是因为我是个起名废物qwq）</del>  </p>\n</blockquote>\n<p>这是 Mirai 酱的第一代，拥有 B站动态转发、随机涩图、天气查询、每日抽签、疫情查询（在之后移除） 功能。（其实当然可以写更多，只是我没点子了）  </p>\n<p>后来不知道什么时候，<code>mirai</code>框架似乎似了，Mirai 酱也被我忘记了一段时间。直到……<br>我找到了<code>go-cqhttp</code>这个框架。</p>\n<blockquote>\n<p>在找引用链接的时候我发现<code>mirai</code>框架原来还活着，而且社区也跟进了签名服务器插件的开发（但框架换了就是换了，也没有换回去这种说法了）</p>\n</blockquote>\n<h2 id=\"重生的-Mirai-酱\"><a href=\"#重生的-Mirai-酱\" class=\"headerlink\" title=\"重生的 Mirai 酱\"></a>重生的 Mirai 酱</h2><p>Mirai 酱第二代的完成大约是在 2023 年 6 月 12 日左右，基于<a href=\"https://github.com/FengLiuFeseliud/pycqBot\"><code>pycqBot</code></a>和<a href=\"https://github.com/Mrs4s/go-cqhttp\"><code>go-cqhttp</code></a>。在 8 月 24 日左右追加了<code>unidbg-fetch-qsign</code>来进行签名认证。<br>这一代的 Mirai 酱功能没有增加，甚至还减少了一个天气查询功能。<del>（天气查询真没人用罢，交互还难写）</del><br><del>不过群友们在 Mirai 酱复活赛打赢之后还是很高兴，甚至发起了电</del></p>\n<h2 id=\"现在的-Mirai-酱\"><a href=\"#现在的-Mirai-酱\" class=\"headerlink\" title=\"现在的 Mirai 酱\"></a>现在的 Mirai 酱</h2><p>Mirai 酱第三代的大致完成大致是在 2024 年 2 月 8 日零点左右<br>这一代的 Mirai 酱新增了方舟模拟抽卡的插件，并且每个插件都可以单独为某个群开启或关闭。  </p>\n<p>这次的框架迁移是因为<code>go-cqhttp</code>的停止维护（详见：<a href=\"https://github.com/Mrs4s/go-cqhttp/issues/2471\">QQBot的未来以及迁移建议</a>）。尽管 Mirai 酱还没因为这个出现什么问题，我还是根据他们的建议将 Mirai 酱迁移到了<a href=\"https://github.com/whitechi73/OpenShamrock\"><code>OpenShamrock</code></a>框架。  </p>\n<p>然后我就发现虽然<code>go-cqhttp</code>和<code>shamrock</code>都是遵循<a href=\"https://github.com/botuniverse/onebot\"><code>onebot</code></a>标准的，但是<code>pycqBot</code>在与<code>shamrock</code>交互的时候始终有莫名其妙的问题。于是我就仿照<code>pycqBot</code>专门为<code>shamrock</code>写了一个简易框架（有直接使用<code>pycqBot</code>中的一些代码，比如<code>cqcode</code>的实现），已经能够满足 Mirai 酱的需求了。不过因为实在是太简易了，以至于插件写起来与<code>pycqBot</code>相比有亿点麻烦（恼）<br>emm 就当作是 Python 练习了罢（？）<br><del>：你说得对，但是这就是重复造轮子的沙贝操作（全恼）</del></p>\n<p><code>shamrock</code>被我部署在了我的小主机上的 PVE 里，依靠<code>BlissOS</code>运行。（参考：<a href=\"https://www.bilibili.com/video/BV1Mj411e7V9/\">PVE下安装BlissOS11</a>）  </p>\n<blockquote>\n<p>因为 tx 的作品实在是太“精致”了，为了 QQ 能够比较稳定地运行，我不得不给 BlissOS  开了 6GB 的 RAM</p>\n</blockquote>\n<p>主要的 Python 程序被我部署在了 PVE 中的另一台 Debian 12 上 <del>目前挂了一天一夜还没有出问题</del>  </p>\n<h1 id=\"关于简易框架\"><a href=\"#关于简易框架\" class=\"headerlink\" title=\"关于简易框架\"></a>关于简易框架</h1><blockquote>\n<p>十分甚至九分感谢<code>pycqBot</code>项目，提供了思路和具体实现供我<del>照搬</del>参考  </p>\n</blockquote>\n<p><del><small>所以说这个简易框架，应该算是<code>mini-pycqBot</code>？（大雾）</small></del></p>\n<h2 id=\"通信方式\"><a href=\"#通信方式\" class=\"headerlink\" title=\"通信方式\"></a>通信方式</h2><p>和<code>pycqBot</code>一样，都是</p>\n<ul>\n<li>用<code>websocket</code>接收框架的事件上报</li>\n<li>用<code>http</code>发送指令到框架</li>\n</ul>\n<p>额外支持了cookies的长期储存，但是保存方式是pickle（逃</p>\n<p><del>其实也尝试着写了json保存，但是不行，B站的接口不认。大概是我漏了什么细节罢</del></p>\n<h2 id=\"各部分关系\"><a href=\"#各部分关系\" class=\"headerlink\" title=\"各部分关系\"></a>各部分关系</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">lemonyBot:</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">__init__.py</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">base.py:</span>          <span class=\"hljs-comment\"># 通信基础</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">SocketBase</span>    <span class=\"hljs-comment\"># 提供 WebSocket 通信方法</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">HttpBase</span>      <span class=\"hljs-comment\"># 提供 HTTP 通信方法</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">apps.py:</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">SocketApp</span>     <span class=\"hljs-comment\"># 封装了消息上报的接收（基本抄自 pycqBot）</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">HttpApp</span>       <span class=\"hljs-comment\"># 封装了接口（基本抄自 shamrock 文档）</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">bot.py:</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Bot</span>           <span class=\"hljs-comment\"># 将 ws 和 http 部分结合到一起</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">objects.py:</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Plugin</span>        <span class=\"hljs-comment\"># 插件对象的父类</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">cqcode.py</span>         <span class=\"hljs-comment\"># 照搬自 pycqBot</span><br></code></pre></td></tr></table></figure>\n\n<pre class=\"mermaid\">\nflowchart LR\nSocketBase --> SocketApp --> Bot\nHttpBase --> HttpApp --> Bot\nPlugin\n</pre>\n\n<h2 id=\"插件系统的实现\"><a href=\"#插件系统的实现\" class=\"headerlink\" title=\"插件系统的实现\"></a>插件系统的实现</h2><p>使用<code>Bot.load_plugin()</code>加载一个插件实例之后，这个实例会被保存在<code>Bot._plugins</code>列表中  </p>\n<p>每当<code>SocketApp</code>收到消息上报时，它会根据消息的类型挨个去尝试调用插件们的对应方法，如果插件定义了对应的方法，它就会把消息包传给这个方法。<br>（消息类型的名字的生成照抄了<code>pycqBot</code>）</p>\n<p>当插件想要发送指令时，它只需要调用自身对应名字的方法即可。这些方法在<code>Plugin</code>父类中被批量预先定义（且分为普通和异步版本）<br>这些方法对<code>Bot.call_api()</code>进行了封装，这样他们就只需要传入参数，而不用传入方法名了</p>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p><small><del>老实说，真的会有人来用这个框架吗……</del></small><br>就当是写给自己看的了，免得以后想搓新插件的时候又忘了</p>\n<h3 id=\"简单的使用\"><a href=\"#简单的使用\" class=\"headerlink\" title=\"简单的使用\"></a>简单的使用</h3><p>入口模块至少应该长这个样子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 框架主体应当被最先导入</span><br><span class=\"hljs-keyword\">import</span> lemonyBot<br><span class=\"hljs-comment\"># 导入各个插件类</span><br><span class=\"hljs-keyword\">from</span> plugins.MyPlugin <span class=\"hljs-keyword\">import</span> MyPlugin<br><br><span class=\"hljs-comment\"># 实例化Bot，记得改成自己的参数</span><br>bot = lemonyBot.Bot(**&#123;<br>    <span class=\"hljs-string\">&quot;ws_host&quot;</span>: <span class=\"hljs-string\">&quot;127.0.0.1:1145&quot;</span>,<br>    <span class=\"hljs-string\">&quot;http_host&quot;</span>: <span class=\"hljs-string\">&quot;127.0.0.1:1919&quot;</span>,<br>    <span class=\"hljs-string\">&quot;authkey&quot;</span>: <span class=\"hljs-string\">&quot;aughhhhhhhhhhhhhh&quot;</span>,<br>&#125;)<br><span class=\"hljs-comment\"># 设置管理员QQ号（选）</span><br>bot.set_config(admins=[<span class=\"hljs-number\">114514</span>])<br><span class=\"hljs-comment\"># 挨个加载插件（的实例）</span><br>bot.load_plugin(MyPlugin(bot))<br><span class=\"hljs-comment\"># 启动</span><br>bot.start()<br></code></pre></td></tr></table></figure>\n<p><del>连我自己都觉得麻烦了</del><br>往后可能会优化一下导入方法，写成像<code>pycqBot</code>那样的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">bot.plugin_load([<br>    <span class=\"hljs-string\">&quot;MyPlugin&quot;</span><br>    ])<br></code></pre></td></tr></table></figure>\n<p>真的方便吧我靠 <del>再看看我这个简直就是原神</del></p>\n<blockquote>\n<p>上面设置的管理员不同于群里的管理员，而是 Bot 的管理员。<br>插件可以通过这个来校验一些只有 Bot 主人才能有的权限。<br>（当然一个插件里都没写的话这个东西也就没用了）</p>\n</blockquote>\n<h3 id=\"插件开发\"><a href=\"#插件开发\" class=\"headerlink\" title=\"插件开发\"></a>插件开发</h3><p>一个插件至少应该长这个样子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 导入必需的模板</span><br><span class=\"hljs-keyword\">from</span> lemonyBot <span class=\"hljs-keyword\">import</span> Plugin, cqcode, Bot<br><br><span class=\"hljs-comment\"># 定义插件类，父类必须为 Plugin</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyPlugin</span>(<span class=\"hljs-title class_ inherited__\">Plugin</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, bot: Bot</span>):<br>        <span class=\"hljs-built_in\">super</span>().__init__(bot)<br>        self.bot: Bot<br>        <span class=\"hljs-comment\"># 在这后面加一些自己的初始化操作比如加载涩图数据</span><br>    <br>    <span class=\"hljs-comment\"># 定义用于接受上报事件的方法，参数为一个 dict</span><br>    <span class=\"hljs-comment\"># 在 bot 收到这个类型的消息时会被自动调用</span><br>    <span class=\"hljs-comment\"># event 的详细内容自己去查 shamrock 之类的文档</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">message_group_normal</span>(<span class=\"hljs-params\">self, event: <span class=\"hljs-built_in\">dict</span></span>):<br>        <span class=\"hljs-comment\"># 这里是对消息的过滤，emm就是设定回复触发的条件</span><br>        <span class=\"hljs-comment\"># 按照自己的需求来，自由度是真的大罢</span><br>        <span class=\"hljs-keyword\">if</span> event[<span class=\"hljs-string\">&quot;message&quot;</span>].lower().strip() == <span class=\"hljs-string\">&quot;ciallo&quot;</span>:<br>            <span class=\"hljs-comment\"># 调用预定义的方法，这里是普通版，没有返回值</span><br>            <span class=\"hljs-comment\"># 要检查消息的发送结果请使用异步版方法</span><br>            <span class=\"hljs-comment\"># ↑ 比如：self.send_group_msg_async()</span><br>            <span class=\"hljs-comment\"># 异步版的返回值自己去查对应文档（这里是shamrock）</span><br>            <span class=\"hljs-comment\"># 方法只接受一个字典参数，以后可能会加一个 **kwargs 调用方法</span><br>            self.send_group_msg_func(<br>                <span class=\"hljs-comment\"># 这个字典的键值就是接口的参数</span><br>                <span class=\"hljs-comment\"># 具体参数需要你去查 shamrock 之类的文档</span><br>                &#123;<br>                    <span class=\"hljs-string\">&quot;group_id&quot;</span>: event[<span class=\"hljs-string\">&quot;group_id&quot;</span>],<br>                    <span class=\"hljs-comment\"># 使用 cqcode 添加各种特殊消息 比如回复、图片</span><br>                    <span class=\"hljs-comment\"># cqcode 模块的使用方法详见 pycqBot 的文档</span><br>                    <span class=\"hljs-comment\"># 关于 cqcode 可以去看 go-cqhttp 文档</span><br>                    <span class=\"hljs-comment\"># cqcode 是字符串，可以直接与正文拼接</span><br>                    <span class=\"hljs-string\">&quot;message&quot;</span>: cqcode.reply(msg_id=event[<span class=\"hljs-string\">&quot;message_id&quot;</span>])<br>                    + <span class=\"hljs-string\">&quot;Ciallo～(∠・ω&lt; )⌒☆&quot;</span>,<br>                    <span class=\"hljs-string\">&quot;auto_escape&quot;</span>: <span class=\"hljs-literal\">False</span>,<br>                &#125;<br>            )<br>        <span class=\"hljs-comment\"># 达到了对群里发出的每一条 ciallo 都回复一个 Ciallo～(∠・ω&lt; )⌒☆ 的效果</span><br></code></pre></td></tr></table></figure>\n<p>普通版方法和异步版方法的名字只差一个后缀，是<code>_func</code>还是<code>_async</code><br>可以使用<code>self.bot.add_task()</code>来借助简易框架内置的给<code>aiohttp</code>用的事件循环运行自己的协程<br>（异步自己去学，我讲不清楚的w）</p>\n<p>通过<code>self.admins</code>可以得到 Bot 的管理员们的QQ，以此来实现鉴权之类的操作<br>插件有需要网络请求的部分可以搞依赖注入，来使用<code>self.bot.request</code>这个写好的网络请求</p>\n<p>可供参考的资料：</p>\n<ul>\n<li><a href=\"https://whitechi73.github.io/OpenShamrock/\">山姆摇滚文档</a></li>\n<li><a href=\"https://docs.go-cqhttp.org/cqcode/\">go-cqhttp文档</a></li>\n<li><a href=\"https://fengliufeseliud.github.io/pycqBot/\">pycqBot文档</a></li>\n</ul>\n<h2 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h2><p>如你所见，这个简易框架：</p>\n<ol>\n<li>没有定义消息类之类的简化处理流程之类的东西，而是直接让开发者处理事件字典</li>\n<li>没有把接口的参数之类的写到程序里，而是要你自己去查文档</li>\n<li>没有快捷的回复功能，必须自己手动生成<code>cqcode</code>来加到回复消息里（应该算是第一条的一部分）</li>\n<li>没有像<a href=\"https://graia.readthedocs.io/ariadne/feature/base-parser/\">这个</a>一样的方便的消息筛选系统、鉴权系统，全都要开发者自己写</li>\n<li>没有统一的插件启用禁用系统，各个插件是割裂的</li>\n<li>还有很多……</li>\n</ol>\n<p><del>笑嘻了，我消息筛选用正则表达式用到似</del></p>\n<p>总之就是非常的简陋就是了，你要什么得自己来，一点都不开箱即用。</p>\n<p>不过反正都是自用的就是了 <small><del>我怎么写也没人能管我（小声）</del></small></p>\n<h1 id=\"关于-Mirai-酱的插件们\"><a href=\"#关于-Mirai-酱的插件们\" class=\"headerlink\" title=\"关于 Mirai 酱的插件们\"></a>关于 Mirai 酱的插件们</h1><h2 id=\"涩图插件\"><a href=\"#涩图插件\" class=\"headerlink\" title=\"涩图插件\"></a>涩图插件</h2><p>插件名：EroPicSender</p>\n<h3 id=\"运行逻辑\"><a href=\"#运行逻辑\" class=\"headerlink\" title=\"运行逻辑\"></a>运行逻辑</h3><pre class=\"mermaid\">\nflowchart TB\n\naskforsetu[/群友找Mirai酱要涩图/] --> checkperm\ncheckperm{检查插件开关} -- 关 -->reject\nreject[拒绝]\ncheckperm -- 开 --> checkcd\ncheckcd{检查冷却时间} -- 到了 --> getsetudata\ncheckcd -- 没到 --> reject\ngetsetudata[获得涩图数据] --> download[下载涩图本体] --> checktag\nchecktag{检查涩图标签\\n（R18之类的）} -- 能发 --> sendwithimg[发送图片] --> withdraw\nsendwithimg --> checkassets\nchecktag -- 不能发 --> sendwithoutimg[仅发送文字描述] --> checkassets\nwithdraw[等待1分钟后撤回涩图]\n\ncache[(涩图缓存)] -.-> getsetudata\ncheckassets{检查涩图缓存} -- 不足 --> 获取一包新的涩图 -.-> cache\ncheckassets -- 充足 --> over[什么都不做]\ncheckassets -.- cache\n\ninit[/插件初始化/] --> loadcache\nloadcache[从文件加载保存的缓存] --> checkassets\nloadcache -.-> cache\n\n</pre> \n\n<p>（尝试用 mermaid 做了流程图，但是一坨） </p>\n<ul>\n<li>管理员可以无视插件开关要涩图  </li>\n<li>涩图下载失败也会发送提示</li>\n<li>涩图发送失败会改为仅发送文字描述  </li>\n<li>涩图发送成功后会在两分钟后撤回</li>\n<li>程序退出时会保存缓存到文件</li>\n</ul>\n<h3 id=\"图源\"><a href=\"#图源\" class=\"headerlink\" title=\"图源\"></a>图源</h3><p>来自 <a href=\"https://api.lolicon.app/\">Lolicon API</a>，非常感谢它的开发者</p>\n<h2 id=\"明日方舟抽卡模拟\"><a href=\"#明日方舟抽卡模拟\" class=\"headerlink\" title=\"明日方舟抽卡模拟\"></a>明日方舟抽卡模拟</h2><p>插件名：ArknightsGacha</p>\n<h3 id=\"数据获取\"><a href=\"#数据获取\" class=\"headerlink\" title=\"数据获取\"></a>数据获取</h3><p>干员列表来自 <a href=\"https://wiki.biligame.com/arknights/%E5%B9%B2%E5%91%98%E6%95%B0%E6%8D%AE%E8%A1%A8\">BiliGame Wiki</a><br>把获取的网页用 xpath 一翻，数据就来了</p>\n<blockquote>\n<p>什么？为什么不是 PRTS ？</p>\n</blockquote>\n<p><del>因为 B 站他直接把数据丢网页源代码里了，大好人属于是</del></p>\n<p>根据干员的获取途径生成中坚和常驻两个池子<br><del>限定池子理论上也能做，但是群友急了于是先这样了</del></p>\n<p>能够通过指令让 Mirai 酱立即更新干员数据</p>\n<h3 id=\"运行逻辑-1\"><a href=\"#运行逻辑-1\" class=\"headerlink\" title=\"运行逻辑\"></a>运行逻辑</h3><p>插件初始化时会从本地加载保存的干员数据<br>加载完毕后生成两个字典（代表中坚和标准两个池子），键为星级，值为对应的干员列表  </p>\n<p>每次请求抽卡时定义一个初始概率表：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">&#123;<br>    <span class=\"hljs-number\">3</span>: <span class=\"hljs-number\">0.4</span>,<br>    <span class=\"hljs-number\">4</span>: <span class=\"hljs-number\">0.5</span>,<br>    <span class=\"hljs-number\">5</span>: <span class=\"hljs-number\">0.08</span>,<br>    <span class=\"hljs-number\">6</span>: <span class=\"hljs-number\">0.02</span>,<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>很明显 键是星级，值是概率  </p>\n<p>抽卡会传入一个<code>combo</code>值，代表连续抽了多少抽没出 6 星。这个值可以经由群员的QQ号查到，用以实现 “若连续 50 发未出 6 星，下次 6 星概率增加 2%，直到第 100 发时必出 6 星” 的设定<br>抽卡函数会根据上述逻辑对初始概率表进行修改，然后通过带权重的随机来确定抽到的星级，最后用初始化时生成的字典来得到具体抽到的干员数据，返回给负责交互的部分</p>\n<p><code>combo</code>值由负责交互的那一坨保管，每当抽到 6 星时这个值就重设为<code>0</code><br>在收到干员数据之后负责交互的那部分便生成文本，回复给群友</p>\n<h2 id=\"B-站动态转发\"><a href=\"#B-站动态转发\" class=\"headerlink\" title=\"B 站动态转发\"></a>B 站动态转发</h2><p>插件名：BiliDynamicForwarder</p>\n<p>需要配合<code>BiliLogin</code>插件食用</p>\n<h3 id=\"运行逻辑-2\"><a href=\"#运行逻辑-2\" class=\"headerlink\" title=\"运行逻辑\"></a>运行逻辑</h3><p>每 5 分钟请求一遍监听对象们的历史动态，与上一次请求的数据比对，找出新发布的进行发送<br><del>↑ emm我的“找出新发布的动态”这个部分似乎还有点问题，时不时就会把历史的某一条动态刨出来发了</del></p>\n<p>如果动态内容命中了黑关键词，那么它将不会被发送；<br>但是如果同时又命中了白关键词，那么它还是会被发送。</p>\n<p>这个插件的交互部分主要就是设置监听对象，逻辑还挺简单的，难写的原因是没有现成的鉴权和指令系统<br>其余部分都是主动发送了没什么好说的  </p>\n<p>自动维护一个用 B 站 uid 查昵称的字典，用来方便添加移除监听对象</p>\n<h3 id=\"关于接口\"><a href=\"#关于接口\" class=\"headerlink\" title=\"关于接口\"></a>关于接口</h3><p>来自易姐的 <a href=\"https://socialsisteryi.github.io/bilibili-API-collect/\"><code>bilibili-API-collect</code></a> ，非常感谢 ta<br>函数封装由我实现，弄得一坨</p>\n<p><del>emm注意到动态获取接口已经有了新的、更优雅的替代方案，但是我懒</del></p>\n<h2 id=\"萌属性抽取\"><a href=\"#萌属性抽取\" class=\"headerlink\" title=\"萌属性抽取\"></a>萌属性抽取</h2><p>插件名：MoeAttriLottery</p>\n<p>之前写好这个插件的时候还有些沾沾自喜，然后看了别人家的机器人才发现，这其实是几年前就玩过时了的东西w<br><del>果然是你能想得到的东西，别人早就想到了</del></p>\n<h3 id=\"数据源\"><a href=\"#数据源\" class=\"headerlink\" title=\"数据源\"></a>数据源</h3><p>由我整理自萌娘百科-<a href=\"https://zh.moegirl.org.cn/%E8%90%8C%E5%B1%9E%E6%80%A7\">萌属性</a></p>\n<h3 id=\"运行逻辑-3\"><a href=\"#运行逻辑-3\" class=\"headerlink\" title=\"运行逻辑\"></a>运行逻辑</h3><p>非常简单的带权重的随机抽取而已，一天仅能抽一次</p>\n<p>拥有权重机制，比如我能把年龄属性中的“萝莉”调到<code>10</code>，其他全为<code>1</code>😋  </p>\n<p>拥有主副属性机制，当抽到的主属性在副属性中有键时，会再抽一个副属性出来<br>比如抽到了渐变色瞳，还可以再抽到一个红-&gt;蓝渐变的细分支  </p>\n<h2 id=\"B站登录\"><a href=\"#B站登录\" class=\"headerlink\" title=\"B站登录\"></a>B站登录</h2><p>插件名：BiliLogin</p>\n<p>因为最近B站对获取动态的接口加了风控，非登录情况下的请求难度大幅提升，于是加紧写了这个插件用于登录</p>\n<p>登录后cookies会自动留在bot框架中，B站动态转发插件可以直接使用</p>\n<p>仅能通过管理员私聊进行扫码登录，不知道时间久了会不会出问题</p>\n<hr>\n<p>emm 大概就是这样，以后应该还会继续维护 Mirai 酱的，有种养女儿的快感 😋</p>\n","excerpt":"","more":"<p><small><del>首先很抱歉先前那篇讲 BiliTools 的文章不更了，问就是太烂了讲不动一点</small></del><br>这次我想来讲一下我的 QQ 机器人，Mirai 酱</p>\n<p>事先声明，本文中的信息并不可靠，请不要盲目相信……</p>\n<h1 id=\"Mirai-酱的故事\"><a href=\"#Mirai-酱的故事\" class=\"headerlink\" title=\"Mirai 酱的故事\"></a>Mirai 酱的故事</h1><p>最初想要做一个自己的 QQ 机器人，应该是在某位群友在群里询问了关于机器人的事之后。<br><del>后来他拉着他的机器人<code>凯尔希</code>进了群，不过不知为何最后却似了。</del></p>\n<h2 id=\"最初的-Mirai-酱\"><a href=\"#最初的-Mirai-酱\" class=\"headerlink\" title=\"最初的 Mirai 酱\"></a>最初的 Mirai 酱</h2><p>翻了下我的程序存档，Mirai 酱最早是在 2022 年 4 月左右被我编写出来的，当时基于<a href=\"https://github.com/GraiaProject/Ariadne\"><code>Ariadne</code></a>和<a href=\"https://github.com/mamoe/mirai\"><code>mirai</code></a>。  </p>\n<blockquote>\n<p>Mirai 酱之所以叫 Mirai 酱，正是因为她最开始基于的框架是<code>mirai</code> <del>（绝对不是因为我是个起名废物qwq）</del>  </p>\n</blockquote>\n<p>这是 Mirai 酱的第一代，拥有 B站动态转发、随机涩图、天气查询、每日抽签、疫情查询（在之后移除） 功能。（其实当然可以写更多，只是我没点子了）  </p>\n<p>后来不知道什么时候，<code>mirai</code>框架似乎似了，Mirai 酱也被我忘记了一段时间。直到……<br>我找到了<code>go-cqhttp</code>这个框架。</p>\n<blockquote>\n<p>在找引用链接的时候我发现<code>mirai</code>框架原来还活着，而且社区也跟进了签名服务器插件的开发（但框架换了就是换了，也没有换回去这种说法了）</p>\n</blockquote>\n<h2 id=\"重生的-Mirai-酱\"><a href=\"#重生的-Mirai-酱\" class=\"headerlink\" title=\"重生的 Mirai 酱\"></a>重生的 Mirai 酱</h2><p>Mirai 酱第二代的完成大约是在 2023 年 6 月 12 日左右，基于<a href=\"https://github.com/FengLiuFeseliud/pycqBot\"><code>pycqBot</code></a>和<a href=\"https://github.com/Mrs4s/go-cqhttp\"><code>go-cqhttp</code></a>。在 8 月 24 日左右追加了<code>unidbg-fetch-qsign</code>来进行签名认证。<br>这一代的 Mirai 酱功能没有增加，甚至还减少了一个天气查询功能。<del>（天气查询真没人用罢，交互还难写）</del><br><del>不过群友们在 Mirai 酱复活赛打赢之后还是很高兴，甚至发起了电</del></p>\n<h2 id=\"现在的-Mirai-酱\"><a href=\"#现在的-Mirai-酱\" class=\"headerlink\" title=\"现在的 Mirai 酱\"></a>现在的 Mirai 酱</h2><p>Mirai 酱第三代的大致完成大致是在 2024 年 2 月 8 日零点左右<br>这一代的 Mirai 酱新增了方舟模拟抽卡的插件，并且每个插件都可以单独为某个群开启或关闭。  </p>\n<p>这次的框架迁移是因为<code>go-cqhttp</code>的停止维护（详见：<a href=\"https://github.com/Mrs4s/go-cqhttp/issues/2471\">QQBot的未来以及迁移建议</a>）。尽管 Mirai 酱还没因为这个出现什么问题，我还是根据他们的建议将 Mirai 酱迁移到了<a href=\"https://github.com/whitechi73/OpenShamrock\"><code>OpenShamrock</code></a>框架。  </p>\n<p>然后我就发现虽然<code>go-cqhttp</code>和<code>shamrock</code>都是遵循<a href=\"https://github.com/botuniverse/onebot\"><code>onebot</code></a>标准的，但是<code>pycqBot</code>在与<code>shamrock</code>交互的时候始终有莫名其妙的问题。于是我就仿照<code>pycqBot</code>专门为<code>shamrock</code>写了一个简易框架（有直接使用<code>pycqBot</code>中的一些代码，比如<code>cqcode</code>的实现），已经能够满足 Mirai 酱的需求了。不过因为实在是太简易了，以至于插件写起来与<code>pycqBot</code>相比有亿点麻烦（恼）<br>emm 就当作是 Python 练习了罢（？）<br><del>：你说得对，但是这就是重复造轮子的沙贝操作（全恼）</del></p>\n<p><code>shamrock</code>被我部署在了我的小主机上的 PVE 里，依靠<code>BlissOS</code>运行。（参考：<a href=\"https://www.bilibili.com/video/BV1Mj411e7V9/\">PVE下安装BlissOS11</a>）  </p>\n<blockquote>\n<p>因为 tx 的作品实在是太“精致”了，为了 QQ 能够比较稳定地运行，我不得不给 BlissOS  开了 6GB 的 RAM</p>\n</blockquote>\n<p>主要的 Python 程序被我部署在了 PVE 中的另一台 Debian 12 上 <del>目前挂了一天一夜还没有出问题</del>  </p>\n<h1 id=\"关于简易框架\"><a href=\"#关于简易框架\" class=\"headerlink\" title=\"关于简易框架\"></a>关于简易框架</h1><blockquote>\n<p>十分甚至九分感谢<code>pycqBot</code>项目，提供了思路和具体实现供我<del>照搬</del>参考  </p>\n</blockquote>\n<p><del><small>所以说这个简易框架，应该算是<code>mini-pycqBot</code>？（大雾）</small></del></p>\n<h2 id=\"通信方式\"><a href=\"#通信方式\" class=\"headerlink\" title=\"通信方式\"></a>通信方式</h2><p>和<code>pycqBot</code>一样，都是</p>\n<ul>\n<li>用<code>websocket</code>接收框架的事件上报</li>\n<li>用<code>http</code>发送指令到框架</li>\n</ul>\n<p>额外支持了cookies的长期储存，但是保存方式是pickle（逃</p>\n<p><del>其实也尝试着写了json保存，但是不行，B站的接口不认。大概是我漏了什么细节罢</del></p>\n<h2 id=\"各部分关系\"><a href=\"#各部分关系\" class=\"headerlink\" title=\"各部分关系\"></a>各部分关系</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">lemonyBot:</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">__init__.py</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">base.py:</span>          <span class=\"hljs-comment\"># 通信基础</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">SocketBase</span>    <span class=\"hljs-comment\"># 提供 WebSocket 通信方法</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">HttpBase</span>      <span class=\"hljs-comment\"># 提供 HTTP 通信方法</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">apps.py:</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">SocketApp</span>     <span class=\"hljs-comment\"># 封装了消息上报的接收（基本抄自 pycqBot）</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">HttpApp</span>       <span class=\"hljs-comment\"># 封装了接口（基本抄自 shamrock 文档）</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">bot.py:</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Bot</span>           <span class=\"hljs-comment\"># 将 ws 和 http 部分结合到一起</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">objects.py:</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Plugin</span>        <span class=\"hljs-comment\"># 插件对象的父类</span><br><span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">cqcode.py</span>         <span class=\"hljs-comment\"># 照搬自 pycqBot</span><br></code></pre></td></tr></table></figure>\n\n<pre class=\"mermaid\">\nflowchart LR\nSocketBase --> SocketApp --> Bot\nHttpBase --> HttpApp --> Bot\nPlugin\n</pre>\n\n<h2 id=\"插件系统的实现\"><a href=\"#插件系统的实现\" class=\"headerlink\" title=\"插件系统的实现\"></a>插件系统的实现</h2><p>使用<code>Bot.load_plugin()</code>加载一个插件实例之后，这个实例会被保存在<code>Bot._plugins</code>列表中  </p>\n<p>每当<code>SocketApp</code>收到消息上报时，它会根据消息的类型挨个去尝试调用插件们的对应方法，如果插件定义了对应的方法，它就会把消息包传给这个方法。<br>（消息类型的名字的生成照抄了<code>pycqBot</code>）</p>\n<p>当插件想要发送指令时，它只需要调用自身对应名字的方法即可。这些方法在<code>Plugin</code>父类中被批量预先定义（且分为普通和异步版本）<br>这些方法对<code>Bot.call_api()</code>进行了封装，这样他们就只需要传入参数，而不用传入方法名了</p>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p><small><del>老实说，真的会有人来用这个框架吗……</del></small><br>就当是写给自己看的了，免得以后想搓新插件的时候又忘了</p>\n<h3 id=\"简单的使用\"><a href=\"#简单的使用\" class=\"headerlink\" title=\"简单的使用\"></a>简单的使用</h3><p>入口模块至少应该长这个样子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 框架主体应当被最先导入</span><br><span class=\"hljs-keyword\">import</span> lemonyBot<br><span class=\"hljs-comment\"># 导入各个插件类</span><br><span class=\"hljs-keyword\">from</span> plugins.MyPlugin <span class=\"hljs-keyword\">import</span> MyPlugin<br><br><span class=\"hljs-comment\"># 实例化Bot，记得改成自己的参数</span><br>bot = lemonyBot.Bot(**&#123;<br>    <span class=\"hljs-string\">&quot;ws_host&quot;</span>: <span class=\"hljs-string\">&quot;127.0.0.1:1145&quot;</span>,<br>    <span class=\"hljs-string\">&quot;http_host&quot;</span>: <span class=\"hljs-string\">&quot;127.0.0.1:1919&quot;</span>,<br>    <span class=\"hljs-string\">&quot;authkey&quot;</span>: <span class=\"hljs-string\">&quot;aughhhhhhhhhhhhhh&quot;</span>,<br>&#125;)<br><span class=\"hljs-comment\"># 设置管理员QQ号（选）</span><br>bot.set_config(admins=[<span class=\"hljs-number\">114514</span>])<br><span class=\"hljs-comment\"># 挨个加载插件（的实例）</span><br>bot.load_plugin(MyPlugin(bot))<br><span class=\"hljs-comment\"># 启动</span><br>bot.start()<br></code></pre></td></tr></table></figure>\n<p><del>连我自己都觉得麻烦了</del><br>往后可能会优化一下导入方法，写成像<code>pycqBot</code>那样的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">bot.plugin_load([<br>    <span class=\"hljs-string\">&quot;MyPlugin&quot;</span><br>    ])<br></code></pre></td></tr></table></figure>\n<p>真的方便吧我靠 <del>再看看我这个简直就是原神</del></p>\n<blockquote>\n<p>上面设置的管理员不同于群里的管理员，而是 Bot 的管理员。<br>插件可以通过这个来校验一些只有 Bot 主人才能有的权限。<br>（当然一个插件里都没写的话这个东西也就没用了）</p>\n</blockquote>\n<h3 id=\"插件开发\"><a href=\"#插件开发\" class=\"headerlink\" title=\"插件开发\"></a>插件开发</h3><p>一个插件至少应该长这个样子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 导入必需的模板</span><br><span class=\"hljs-keyword\">from</span> lemonyBot <span class=\"hljs-keyword\">import</span> Plugin, cqcode, Bot<br><br><span class=\"hljs-comment\"># 定义插件类，父类必须为 Plugin</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyPlugin</span>(<span class=\"hljs-title class_ inherited__\">Plugin</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, bot: Bot</span>):<br>        <span class=\"hljs-built_in\">super</span>().__init__(bot)<br>        self.bot: Bot<br>        <span class=\"hljs-comment\"># 在这后面加一些自己的初始化操作比如加载涩图数据</span><br>    <br>    <span class=\"hljs-comment\"># 定义用于接受上报事件的方法，参数为一个 dict</span><br>    <span class=\"hljs-comment\"># 在 bot 收到这个类型的消息时会被自动调用</span><br>    <span class=\"hljs-comment\"># event 的详细内容自己去查 shamrock 之类的文档</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">message_group_normal</span>(<span class=\"hljs-params\">self, event: <span class=\"hljs-built_in\">dict</span></span>):<br>        <span class=\"hljs-comment\"># 这里是对消息的过滤，emm就是设定回复触发的条件</span><br>        <span class=\"hljs-comment\"># 按照自己的需求来，自由度是真的大罢</span><br>        <span class=\"hljs-keyword\">if</span> event[<span class=\"hljs-string\">&quot;message&quot;</span>].lower().strip() == <span class=\"hljs-string\">&quot;ciallo&quot;</span>:<br>            <span class=\"hljs-comment\"># 调用预定义的方法，这里是普通版，没有返回值</span><br>            <span class=\"hljs-comment\"># 要检查消息的发送结果请使用异步版方法</span><br>            <span class=\"hljs-comment\"># ↑ 比如：self.send_group_msg_async()</span><br>            <span class=\"hljs-comment\"># 异步版的返回值自己去查对应文档（这里是shamrock）</span><br>            <span class=\"hljs-comment\"># 方法只接受一个字典参数，以后可能会加一个 **kwargs 调用方法</span><br>            self.send_group_msg_func(<br>                <span class=\"hljs-comment\"># 这个字典的键值就是接口的参数</span><br>                <span class=\"hljs-comment\"># 具体参数需要你去查 shamrock 之类的文档</span><br>                &#123;<br>                    <span class=\"hljs-string\">&quot;group_id&quot;</span>: event[<span class=\"hljs-string\">&quot;group_id&quot;</span>],<br>                    <span class=\"hljs-comment\"># 使用 cqcode 添加各种特殊消息 比如回复、图片</span><br>                    <span class=\"hljs-comment\"># cqcode 模块的使用方法详见 pycqBot 的文档</span><br>                    <span class=\"hljs-comment\"># 关于 cqcode 可以去看 go-cqhttp 文档</span><br>                    <span class=\"hljs-comment\"># cqcode 是字符串，可以直接与正文拼接</span><br>                    <span class=\"hljs-string\">&quot;message&quot;</span>: cqcode.reply(msg_id=event[<span class=\"hljs-string\">&quot;message_id&quot;</span>])<br>                    + <span class=\"hljs-string\">&quot;Ciallo～(∠・ω&lt; )⌒☆&quot;</span>,<br>                    <span class=\"hljs-string\">&quot;auto_escape&quot;</span>: <span class=\"hljs-literal\">False</span>,<br>                &#125;<br>            )<br>        <span class=\"hljs-comment\"># 达到了对群里发出的每一条 ciallo 都回复一个 Ciallo～(∠・ω&lt; )⌒☆ 的效果</span><br></code></pre></td></tr></table></figure>\n<p>普通版方法和异步版方法的名字只差一个后缀，是<code>_func</code>还是<code>_async</code><br>可以使用<code>self.bot.add_task()</code>来借助简易框架内置的给<code>aiohttp</code>用的事件循环运行自己的协程<br>（异步自己去学，我讲不清楚的w）</p>\n<p>通过<code>self.admins</code>可以得到 Bot 的管理员们的QQ，以此来实现鉴权之类的操作<br>插件有需要网络请求的部分可以搞依赖注入，来使用<code>self.bot.request</code>这个写好的网络请求</p>\n<p>可供参考的资料：</p>\n<ul>\n<li><a href=\"https://whitechi73.github.io/OpenShamrock/\">山姆摇滚文档</a></li>\n<li><a href=\"https://docs.go-cqhttp.org/cqcode/\">go-cqhttp文档</a></li>\n<li><a href=\"https://fengliufeseliud.github.io/pycqBot/\">pycqBot文档</a></li>\n</ul>\n<h2 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h2><p>如你所见，这个简易框架：</p>\n<ol>\n<li>没有定义消息类之类的简化处理流程之类的东西，而是直接让开发者处理事件字典</li>\n<li>没有把接口的参数之类的写到程序里，而是要你自己去查文档</li>\n<li>没有快捷的回复功能，必须自己手动生成<code>cqcode</code>来加到回复消息里（应该算是第一条的一部分）</li>\n<li>没有像<a href=\"https://graia.readthedocs.io/ariadne/feature/base-parser/\">这个</a>一样的方便的消息筛选系统、鉴权系统，全都要开发者自己写</li>\n<li>没有统一的插件启用禁用系统，各个插件是割裂的</li>\n<li>还有很多……</li>\n</ol>\n<p><del>笑嘻了，我消息筛选用正则表达式用到似</del></p>\n<p>总之就是非常的简陋就是了，你要什么得自己来，一点都不开箱即用。</p>\n<p>不过反正都是自用的就是了 <small><del>我怎么写也没人能管我（小声）</del></small></p>\n<h1 id=\"关于-Mirai-酱的插件们\"><a href=\"#关于-Mirai-酱的插件们\" class=\"headerlink\" title=\"关于 Mirai 酱的插件们\"></a>关于 Mirai 酱的插件们</h1><h2 id=\"涩图插件\"><a href=\"#涩图插件\" class=\"headerlink\" title=\"涩图插件\"></a>涩图插件</h2><p>插件名：EroPicSender</p>\n<h3 id=\"运行逻辑\"><a href=\"#运行逻辑\" class=\"headerlink\" title=\"运行逻辑\"></a>运行逻辑</h3><pre class=\"mermaid\">\nflowchart TB\n\naskforsetu[/群友找Mirai酱要涩图/] --> checkperm\ncheckperm{检查插件开关} -- 关 -->reject\nreject[拒绝]\ncheckperm -- 开 --> checkcd\ncheckcd{检查冷却时间} -- 到了 --> getsetudata\ncheckcd -- 没到 --> reject\ngetsetudata[获得涩图数据] --> download[下载涩图本体] --> checktag\nchecktag{检查涩图标签\\n（R18之类的）} -- 能发 --> sendwithimg[发送图片] --> withdraw\nsendwithimg --> checkassets\nchecktag -- 不能发 --> sendwithoutimg[仅发送文字描述] --> checkassets\nwithdraw[等待1分钟后撤回涩图]\n\ncache[(涩图缓存)] -.-> getsetudata\ncheckassets{检查涩图缓存} -- 不足 --> 获取一包新的涩图 -.-> cache\ncheckassets -- 充足 --> over[什么都不做]\ncheckassets -.- cache\n\ninit[/插件初始化/] --> loadcache\nloadcache[从文件加载保存的缓存] --> checkassets\nloadcache -.-> cache\n\n</pre> \n\n<p>（尝试用 mermaid 做了流程图，但是一坨） </p>\n<ul>\n<li>管理员可以无视插件开关要涩图  </li>\n<li>涩图下载失败也会发送提示</li>\n<li>涩图发送失败会改为仅发送文字描述  </li>\n<li>涩图发送成功后会在两分钟后撤回</li>\n<li>程序退出时会保存缓存到文件</li>\n</ul>\n<h3 id=\"图源\"><a href=\"#图源\" class=\"headerlink\" title=\"图源\"></a>图源</h3><p>来自 <a href=\"https://api.lolicon.app/\">Lolicon API</a>，非常感谢它的开发者</p>\n<h2 id=\"明日方舟抽卡模拟\"><a href=\"#明日方舟抽卡模拟\" class=\"headerlink\" title=\"明日方舟抽卡模拟\"></a>明日方舟抽卡模拟</h2><p>插件名：ArknightsGacha</p>\n<h3 id=\"数据获取\"><a href=\"#数据获取\" class=\"headerlink\" title=\"数据获取\"></a>数据获取</h3><p>干员列表来自 <a href=\"https://wiki.biligame.com/arknights/%E5%B9%B2%E5%91%98%E6%95%B0%E6%8D%AE%E8%A1%A8\">BiliGame Wiki</a><br>把获取的网页用 xpath 一翻，数据就来了</p>\n<blockquote>\n<p>什么？为什么不是 PRTS ？</p>\n</blockquote>\n<p><del>因为 B 站他直接把数据丢网页源代码里了，大好人属于是</del></p>\n<p>根据干员的获取途径生成中坚和常驻两个池子<br><del>限定池子理论上也能做，但是群友急了于是先这样了</del></p>\n<p>能够通过指令让 Mirai 酱立即更新干员数据</p>\n<h3 id=\"运行逻辑-1\"><a href=\"#运行逻辑-1\" class=\"headerlink\" title=\"运行逻辑\"></a>运行逻辑</h3><p>插件初始化时会从本地加载保存的干员数据<br>加载完毕后生成两个字典（代表中坚和标准两个池子），键为星级，值为对应的干员列表  </p>\n<p>每次请求抽卡时定义一个初始概率表：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">&#123;<br>    <span class=\"hljs-number\">3</span>: <span class=\"hljs-number\">0.4</span>,<br>    <span class=\"hljs-number\">4</span>: <span class=\"hljs-number\">0.5</span>,<br>    <span class=\"hljs-number\">5</span>: <span class=\"hljs-number\">0.08</span>,<br>    <span class=\"hljs-number\">6</span>: <span class=\"hljs-number\">0.02</span>,<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>很明显 键是星级，值是概率  </p>\n<p>抽卡会传入一个<code>combo</code>值，代表连续抽了多少抽没出 6 星。这个值可以经由群员的QQ号查到，用以实现 “若连续 50 发未出 6 星，下次 6 星概率增加 2%，直到第 100 发时必出 6 星” 的设定<br>抽卡函数会根据上述逻辑对初始概率表进行修改，然后通过带权重的随机来确定抽到的星级，最后用初始化时生成的字典来得到具体抽到的干员数据，返回给负责交互的部分</p>\n<p><code>combo</code>值由负责交互的那一坨保管，每当抽到 6 星时这个值就重设为<code>0</code><br>在收到干员数据之后负责交互的那部分便生成文本，回复给群友</p>\n<h2 id=\"B-站动态转发\"><a href=\"#B-站动态转发\" class=\"headerlink\" title=\"B 站动态转发\"></a>B 站动态转发</h2><p>插件名：BiliDynamicForwarder</p>\n<p>需要配合<code>BiliLogin</code>插件食用</p>\n<h3 id=\"运行逻辑-2\"><a href=\"#运行逻辑-2\" class=\"headerlink\" title=\"运行逻辑\"></a>运行逻辑</h3><p>每 5 分钟请求一遍监听对象们的历史动态，与上一次请求的数据比对，找出新发布的进行发送<br><del>↑ emm我的“找出新发布的动态”这个部分似乎还有点问题，时不时就会把历史的某一条动态刨出来发了</del></p>\n<p>如果动态内容命中了黑关键词，那么它将不会被发送；<br>但是如果同时又命中了白关键词，那么它还是会被发送。</p>\n<p>这个插件的交互部分主要就是设置监听对象，逻辑还挺简单的，难写的原因是没有现成的鉴权和指令系统<br>其余部分都是主动发送了没什么好说的  </p>\n<p>自动维护一个用 B 站 uid 查昵称的字典，用来方便添加移除监听对象</p>\n<h3 id=\"关于接口\"><a href=\"#关于接口\" class=\"headerlink\" title=\"关于接口\"></a>关于接口</h3><p>来自易姐的 <a href=\"https://socialsisteryi.github.io/bilibili-API-collect/\"><code>bilibili-API-collect</code></a> ，非常感谢 ta<br>函数封装由我实现，弄得一坨</p>\n<p><del>emm注意到动态获取接口已经有了新的、更优雅的替代方案，但是我懒</del></p>\n<h2 id=\"萌属性抽取\"><a href=\"#萌属性抽取\" class=\"headerlink\" title=\"萌属性抽取\"></a>萌属性抽取</h2><p>插件名：MoeAttriLottery</p>\n<p>之前写好这个插件的时候还有些沾沾自喜，然后看了别人家的机器人才发现，这其实是几年前就玩过时了的东西w<br><del>果然是你能想得到的东西，别人早就想到了</del></p>\n<h3 id=\"数据源\"><a href=\"#数据源\" class=\"headerlink\" title=\"数据源\"></a>数据源</h3><p>由我整理自萌娘百科-<a href=\"https://zh.moegirl.org.cn/%E8%90%8C%E5%B1%9E%E6%80%A7\">萌属性</a></p>\n<h3 id=\"运行逻辑-3\"><a href=\"#运行逻辑-3\" class=\"headerlink\" title=\"运行逻辑\"></a>运行逻辑</h3><p>非常简单的带权重的随机抽取而已，一天仅能抽一次</p>\n<p>拥有权重机制，比如我能把年龄属性中的“萝莉”调到<code>10</code>，其他全为<code>1</code>😋  </p>\n<p>拥有主副属性机制，当抽到的主属性在副属性中有键时，会再抽一个副属性出来<br>比如抽到了渐变色瞳，还可以再抽到一个红-&gt;蓝渐变的细分支  </p>\n<h2 id=\"B站登录\"><a href=\"#B站登录\" class=\"headerlink\" title=\"B站登录\"></a>B站登录</h2><p>插件名：BiliLogin</p>\n<p>因为最近B站对获取动态的接口加了风控，非登录情况下的请求难度大幅提升，于是加紧写了这个插件用于登录</p>\n<p>登录后cookies会自动留在bot框架中，B站动态转发插件可以直接使用</p>\n<p>仅能通过管理员私聊进行扫码登录，不知道时间久了会不会出问题</p>\n<hr>\n<p>emm 大概就是这样，以后应该还会继续维护 Mirai 酱的，有种养女儿的快感 😋</p>\n"},{"title":"离散数学-图的最短路径","date":"2024-06-03T14:07:00.000Z","_content":"\n# 离散数学-图的最短路径算法\n\n*此文档用于离散数学课上的主题展示*\n\n## Dijkstra 算法\n\n/ˈdaɪkstrə/\n\n### 介绍\n\nDijkstra 算法是一种在加权图中寻找节点间最短路径的算法，加权图可以表示道路网络等。该算法由计算机科学家 Edsger W. Dijkstra 于 1956 年提出，并于三年后发表。它及其变体被称为均匀成本搜索，是更普遍的最佳优先搜索思想的一个实例。\n\n>  *从 Rotterdam 到 Groningen 的最短路线是什么？我花了大概 20 分钟时间设计了这个寻找最短路径的算法。一天早上我正和我年轻的未婚妻在 Amsterdam 逛街，觉得有点累了，我们就坐在咖啡厅的露台上喝了一杯咖啡，我在想是否能够解决这个问题，然后，我设计出了这个最短路径算法。我说过，这是一个 20 分钟的设计。事实上，三年之后的 1959 年它才被发布，现在看来依然很不错，其原因之一是我当时设计的时候没有纸和笔，从而不得不极力避免所有可避免的复杂性。最终，令我惊讶的是，这个算法成为了我成名的基石之一。*\n>\n>  *——引自[《An interview with Edsger W. Dijkstra》](https://dl.acm.org/doi/pdf/10.1145/1787234.1787249)*\n\n属于动态规划、贪心算法\n\n如果是二叉堆实现，时间复杂度为 `O((V + E) log V)` （`V`是节点数，`E`是边数）\n\n### 适用条件\n\n   - 适用于带权有向图和带权无向图。\n   - 要求所有边的权值为非负数。\n\n> 如果图中有负权重的边，这个算法就无法正常工作。\n>\n> 一旦一个节点被标记为“已访问”，当前访问它的路径就被标记为访问它的最短路径。如果存在负权重，则可能在之后的计算中得到总权重更小的路径，从而影响之前的结果。\n\n### 内容\n\n![File:Dijkstra Animation.gif](/assets/blogs/discrete_math_graphs_algos/Dijkstra_Animation.gif)\n\n<small><del>维基上扒的图不知道能不能载出来</del></small>\n\n从起始节点开始，逐步扩展到所有节点，每次选择当前已知的最短路径进行扩展。\n\n#### 准备工作\n\n选定一个*起始节点*\n\n创建一个列表 来记录距离：\n\n- *起始节点*到它自己的距离为`0`\n\n- 到其它节点的距离未确定，记为`+∞`\n\n> Python 中的无穷：`float(\"inf\")`\n>\n> （正负号加在`inf`前面）\n\n创建一个列表 来记录有哪些节点尚未被访问\n\n创建一个优先队列 来存储节点及其当前已知的最短距离（开始时包含起始节点）\n\n创建一个列表 用来记录*前驱节点*用来回溯路径\n\n#### 开始喵\n\n##### 循环，直到 (优先队列为空) or (已找到目标节点的最短路径)\n\n从优先队列中取出距离最小的节点（*当前节点*）\n\n对当前节点的所有邻接节点：\n\n- 计算从起始节点经过当前节点到达该邻接节点的距离（*候选距离*）\n- 如果候选距离小于该邻接节点当前已知的距离，则更新该邻接节点的距离为*候选距离*，并将该邻接节点及其新距离添加到优先队列中。\n- 如果需要回溯路径，则在更新距离的同时，记录每个节点的前驱节点\n\n将*当前节点*标记为已处理\n\n#### 回溯\n\n从目标节点回溯到起始节点，得到完整的最短路径\n\n### 代码\n\n嗯 这部分交给 *S.K.Y.* 罢（\n\n## Bellman-Ford 算法\n\n### 介绍\n\nBellman-Ford 算法比 Dijkstra 算法慢一些，但通用性更强。\n\n> 该算法由 Alfonso Shimbel（1955 年）首次提出，但却以 Richard Bellman 和 Lester Ford Jr. 的名字命名，他们分别于 1958 年和 1956 年发表了该算法。\n>\n> 爱德华-摩尔（Edward F. Moore）也于 1959 年发表了该算法的变体，因此有时也被称为 Bellman-Ford-Moore 算法。\n\n时间复杂度略高（最坏时`O(|V||E|`)），但可以继续优化\n\n### 适用条件\n\n比 Dijkstra 多支持了负数权值\n\n### 内容\n\n![File:Bellman–Ford algorithm example.gif](/assets/blogs/discrete_math_graphs_algos/Bellman–Ford_algorithm_example.gif)\n\n<small><del>嗯同样是从维基上扒的，不知道能不能加载ww</del></small>\n\n#### 准备工作\n\n选定起始节点和目标节点\n\n创建距离列表，存储起始节点到每个节点的最短距离\n\n- 起始节点到自己是`0`\n- 到其他节点都暂时记为`+∞`\n\n创建前驱节点列表\n\n#### ~~你的边有些~~松弛\n\n对于图中的每一条边 `(u, v, w)` （`u`和`v`是边的两个端点，`w`是边的权重）\n\n- 如果`dist[u] + w < dist[v]`，则更新`dist[v] = dist[u] + w` （`dist`是距离列表），并将v的前驱节点设为`u`\n\n重复 `|V|-1` 次（`|V|`是节点的数量）\n\n#### 检查负权环\n\n再松弛一次，如果还存在满足`dist[u] + w < dist[v]`的边，说明存在负权环，无法找到最短路径\n\n#### 回溯\n\n根据前驱节点列表从目标节点回溯到起始节点，得到最短路径\n\n### Extension\n\n*松弛操作*（Relaxation）是许多最短路径算法中的一个关键步骤，它用于更新从起点到某个节点的当前已知最短距离。松弛操作检查一条边，如果通过该边可以找到更短的路径，就更新目标节点的最短距离。\n\n假设有一条从节点 `u` 到节点 `v` 的边，边的权重为 `w(u, v)`，当前已知的从起点到 `u` 的最短距离为 `d[u]`，到 `v` 的最短距离为 `d[v]`：\n\n1. 计算通过 `u` 到达 `v` 的距离，即 `d[u] + w(u, v)`。\n2. 如果 `d[u] + w(u, v) < d[v]`，则更新 `d[v]` 为 `d[u] + w(u, v)`。\n\n这种操作的目的是确保每个节点的距离是最短的。","source":"_posts/Discrete_math_shortest_path_algorithms.md","raw":"---\ntitle: 离散数学-图的最短路径\ndate: 2024-6-3 22:07:00\ntags: [Discrete Math, Algorithm]\ncategories: [Algorithm]\n---\n\n# 离散数学-图的最短路径算法\n\n*此文档用于离散数学课上的主题展示*\n\n## Dijkstra 算法\n\n/ˈdaɪkstrə/\n\n### 介绍\n\nDijkstra 算法是一种在加权图中寻找节点间最短路径的算法，加权图可以表示道路网络等。该算法由计算机科学家 Edsger W. Dijkstra 于 1956 年提出，并于三年后发表。它及其变体被称为均匀成本搜索，是更普遍的最佳优先搜索思想的一个实例。\n\n>  *从 Rotterdam 到 Groningen 的最短路线是什么？我花了大概 20 分钟时间设计了这个寻找最短路径的算法。一天早上我正和我年轻的未婚妻在 Amsterdam 逛街，觉得有点累了，我们就坐在咖啡厅的露台上喝了一杯咖啡，我在想是否能够解决这个问题，然后，我设计出了这个最短路径算法。我说过，这是一个 20 分钟的设计。事实上，三年之后的 1959 年它才被发布，现在看来依然很不错，其原因之一是我当时设计的时候没有纸和笔，从而不得不极力避免所有可避免的复杂性。最终，令我惊讶的是，这个算法成为了我成名的基石之一。*\n>\n>  *——引自[《An interview with Edsger W. Dijkstra》](https://dl.acm.org/doi/pdf/10.1145/1787234.1787249)*\n\n属于动态规划、贪心算法\n\n如果是二叉堆实现，时间复杂度为 `O((V + E) log V)` （`V`是节点数，`E`是边数）\n\n### 适用条件\n\n   - 适用于带权有向图和带权无向图。\n   - 要求所有边的权值为非负数。\n\n> 如果图中有负权重的边，这个算法就无法正常工作。\n>\n> 一旦一个节点被标记为“已访问”，当前访问它的路径就被标记为访问它的最短路径。如果存在负权重，则可能在之后的计算中得到总权重更小的路径，从而影响之前的结果。\n\n### 内容\n\n![File:Dijkstra Animation.gif](/assets/blogs/discrete_math_graphs_algos/Dijkstra_Animation.gif)\n\n<small><del>维基上扒的图不知道能不能载出来</del></small>\n\n从起始节点开始，逐步扩展到所有节点，每次选择当前已知的最短路径进行扩展。\n\n#### 准备工作\n\n选定一个*起始节点*\n\n创建一个列表 来记录距离：\n\n- *起始节点*到它自己的距离为`0`\n\n- 到其它节点的距离未确定，记为`+∞`\n\n> Python 中的无穷：`float(\"inf\")`\n>\n> （正负号加在`inf`前面）\n\n创建一个列表 来记录有哪些节点尚未被访问\n\n创建一个优先队列 来存储节点及其当前已知的最短距离（开始时包含起始节点）\n\n创建一个列表 用来记录*前驱节点*用来回溯路径\n\n#### 开始喵\n\n##### 循环，直到 (优先队列为空) or (已找到目标节点的最短路径)\n\n从优先队列中取出距离最小的节点（*当前节点*）\n\n对当前节点的所有邻接节点：\n\n- 计算从起始节点经过当前节点到达该邻接节点的距离（*候选距离*）\n- 如果候选距离小于该邻接节点当前已知的距离，则更新该邻接节点的距离为*候选距离*，并将该邻接节点及其新距离添加到优先队列中。\n- 如果需要回溯路径，则在更新距离的同时，记录每个节点的前驱节点\n\n将*当前节点*标记为已处理\n\n#### 回溯\n\n从目标节点回溯到起始节点，得到完整的最短路径\n\n### 代码\n\n嗯 这部分交给 *S.K.Y.* 罢（\n\n## Bellman-Ford 算法\n\n### 介绍\n\nBellman-Ford 算法比 Dijkstra 算法慢一些，但通用性更强。\n\n> 该算法由 Alfonso Shimbel（1955 年）首次提出，但却以 Richard Bellman 和 Lester Ford Jr. 的名字命名，他们分别于 1958 年和 1956 年发表了该算法。\n>\n> 爱德华-摩尔（Edward F. Moore）也于 1959 年发表了该算法的变体，因此有时也被称为 Bellman-Ford-Moore 算法。\n\n时间复杂度略高（最坏时`O(|V||E|`)），但可以继续优化\n\n### 适用条件\n\n比 Dijkstra 多支持了负数权值\n\n### 内容\n\n![File:Bellman–Ford algorithm example.gif](/assets/blogs/discrete_math_graphs_algos/Bellman–Ford_algorithm_example.gif)\n\n<small><del>嗯同样是从维基上扒的，不知道能不能加载ww</del></small>\n\n#### 准备工作\n\n选定起始节点和目标节点\n\n创建距离列表，存储起始节点到每个节点的最短距离\n\n- 起始节点到自己是`0`\n- 到其他节点都暂时记为`+∞`\n\n创建前驱节点列表\n\n#### ~~你的边有些~~松弛\n\n对于图中的每一条边 `(u, v, w)` （`u`和`v`是边的两个端点，`w`是边的权重）\n\n- 如果`dist[u] + w < dist[v]`，则更新`dist[v] = dist[u] + w` （`dist`是距离列表），并将v的前驱节点设为`u`\n\n重复 `|V|-1` 次（`|V|`是节点的数量）\n\n#### 检查负权环\n\n再松弛一次，如果还存在满足`dist[u] + w < dist[v]`的边，说明存在负权环，无法找到最短路径\n\n#### 回溯\n\n根据前驱节点列表从目标节点回溯到起始节点，得到最短路径\n\n### Extension\n\n*松弛操作*（Relaxation）是许多最短路径算法中的一个关键步骤，它用于更新从起点到某个节点的当前已知最短距离。松弛操作检查一条边，如果通过该边可以找到更短的路径，就更新目标节点的最短距离。\n\n假设有一条从节点 `u` 到节点 `v` 的边，边的权重为 `w(u, v)`，当前已知的从起点到 `u` 的最短距离为 `d[u]`，到 `v` 的最短距离为 `d[v]`：\n\n1. 计算通过 `u` 到达 `v` 的距离，即 `d[u] + w(u, v)`。\n2. 如果 `d[u] + w(u, v) < d[v]`，则更新 `d[v]` 为 `d[u] + w(u, v)`。\n\n这种操作的目的是确保每个节点的距离是最短的。","slug":"Discrete_math_shortest_path_algorithms","published":1,"updated":"2024-06-03T14:08:27.369Z","_id":"clwz1gok80000lco19itfd4or","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"离散数学-图的最短路径算法\"><a href=\"#离散数学-图的最短路径算法\" class=\"headerlink\" title=\"离散数学-图的最短路径算法\"></a>离散数学-图的最短路径算法</h1><p><em>此文档用于离散数学课上的主题展示</em></p>\n<h2 id=\"Dijkstra-算法\"><a href=\"#Dijkstra-算法\" class=\"headerlink\" title=\"Dijkstra 算法\"></a>Dijkstra 算法</h2><p>&#x2F;ˈdaɪkstrə&#x2F;</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Dijkstra 算法是一种在加权图中寻找节点间最短路径的算法，加权图可以表示道路网络等。该算法由计算机科学家 Edsger W. Dijkstra 于 1956 年提出，并于三年后发表。它及其变体被称为均匀成本搜索，是更普遍的最佳优先搜索思想的一个实例。</p>\n<blockquote>\n<p> <em>从 Rotterdam 到 Groningen 的最短路线是什么？我花了大概 20 分钟时间设计了这个寻找最短路径的算法。一天早上我正和我年轻的未婚妻在 Amsterdam 逛街，觉得有点累了，我们就坐在咖啡厅的露台上喝了一杯咖啡，我在想是否能够解决这个问题，然后，我设计出了这个最短路径算法。我说过，这是一个 20 分钟的设计。事实上，三年之后的 1959 年它才被发布，现在看来依然很不错，其原因之一是我当时设计的时候没有纸和笔，从而不得不极力避免所有可避免的复杂性。最终，令我惊讶的是，这个算法成为了我成名的基石之一。</em></p>\n<p> <em>——引自<a href=\"https://dl.acm.org/doi/pdf/10.1145/1787234.1787249\">《An interview with Edsger W. Dijkstra》</a></em></p>\n</blockquote>\n<p>属于动态规划、贪心算法</p>\n<p>如果是二叉堆实现，时间复杂度为 <code>O((V + E) log V)</code> （<code>V</code>是节点数，<code>E</code>是边数）</p>\n<h3 id=\"适用条件\"><a href=\"#适用条件\" class=\"headerlink\" title=\"适用条件\"></a>适用条件</h3><ul>\n<li>适用于带权有向图和带权无向图。</li>\n<li>要求所有边的权值为非负数。</li>\n</ul>\n<blockquote>\n<p>如果图中有负权重的边，这个算法就无法正常工作。</p>\n<p>一旦一个节点被标记为“已访问”，当前访问它的路径就被标记为访问它的最短路径。如果存在负权重，则可能在之后的计算中得到总权重更小的路径，从而影响之前的结果。</p>\n</blockquote>\n<h3 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h3><p><img onerror=\"imgOnError(this);\" data-fancybox=\"gallery\" src=\"/assets/blogs/discrete_math_graphs_algos/Dijkstra_Animation.gif\" alt=\"File:Dijkstra Animation.gif\" data-caption=\"File:Dijkstra Animation.gif\" loading=\"lazy\"></p>\n<p><small><del>维基上扒的图不知道能不能载出来</del></small></p>\n<p>从起始节点开始，逐步扩展到所有节点，每次选择当前已知的最短路径进行扩展。</p>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>选定一个<em>起始节点</em></p>\n<p>创建一个列表 来记录距离：</p>\n<ul>\n<li><p><em>起始节点</em>到它自己的距离为<code>0</code></p>\n</li>\n<li><p>到其它节点的距离未确定，记为<code>+∞</code></p>\n</li>\n</ul>\n<blockquote>\n<p>Python 中的无穷：<code>float(&quot;inf&quot;)</code></p>\n<p>（正负号加在<code>inf</code>前面）</p>\n</blockquote>\n<p>创建一个列表 来记录有哪些节点尚未被访问</p>\n<p>创建一个优先队列 来存储节点及其当前已知的最短距离（开始时包含起始节点）</p>\n<p>创建一个列表 用来记录<em>前驱节点</em>用来回溯路径</p>\n<h4 id=\"开始喵\"><a href=\"#开始喵\" class=\"headerlink\" title=\"开始喵\"></a>开始喵</h4><h5 id=\"循环，直到-优先队列为空-or-已找到目标节点的最短路径\"><a href=\"#循环，直到-优先队列为空-or-已找到目标节点的最短路径\" class=\"headerlink\" title=\"循环，直到 (优先队列为空) or (已找到目标节点的最短路径)\"></a>循环，直到 (优先队列为空) or (已找到目标节点的最短路径)</h5><p>从优先队列中取出距离最小的节点（<em>当前节点</em>）</p>\n<p>对当前节点的所有邻接节点：</p>\n<ul>\n<li>计算从起始节点经过当前节点到达该邻接节点的距离（<em>候选距离</em>）</li>\n<li>如果候选距离小于该邻接节点当前已知的距离，则更新该邻接节点的距离为<em>候选距离</em>，并将该邻接节点及其新距离添加到优先队列中。</li>\n<li>如果需要回溯路径，则在更新距离的同时，记录每个节点的前驱节点</li>\n</ul>\n<p>将<em>当前节点</em>标记为已处理</p>\n<h4 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h4><p>从目标节点回溯到起始节点，得到完整的最短路径</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>嗯 这部分交给 <em>S.K.Y.</em> 罢（</p>\n<h2 id=\"Bellman-Ford-算法\"><a href=\"#Bellman-Ford-算法\" class=\"headerlink\" title=\"Bellman-Ford 算法\"></a>Bellman-Ford 算法</h2><h3 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Bellman-Ford 算法比 Dijkstra 算法慢一些，但通用性更强。</p>\n<blockquote>\n<p>该算法由 Alfonso Shimbel（1955 年）首次提出，但却以 Richard Bellman 和 Lester Ford Jr. 的名字命名，他们分别于 1958 年和 1956 年发表了该算法。</p>\n<p>爱德华-摩尔（Edward F. Moore）也于 1959 年发表了该算法的变体，因此有时也被称为 Bellman-Ford-Moore 算法。</p>\n</blockquote>\n<p>时间复杂度略高（最坏时<code>O(|V||E|</code>)），但可以继续优化</p>\n<h3 id=\"适用条件-1\"><a href=\"#适用条件-1\" class=\"headerlink\" title=\"适用条件\"></a>适用条件</h3><p>比 Dijkstra 多支持了负数权值</p>\n<h3 id=\"内容-1\"><a href=\"#内容-1\" class=\"headerlink\" title=\"内容\"></a>内容</h3><p><img onerror=\"imgOnError(this);\" data-fancybox=\"gallery\" src=\"/assets/blogs/discrete_math_graphs_algos/Bellman%E2%80%93Ford_algorithm_example.gif\" alt=\"File:Bellman–Ford algorithm example.gif\" data-caption=\"File:Bellman–Ford algorithm example.gif\" loading=\"lazy\"></p>\n<p><small><del>嗯同样是从维基上扒的，不知道能不能加载ww</del></small></p>\n<h4 id=\"准备工作-1\"><a href=\"#准备工作-1\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>选定起始节点和目标节点</p>\n<p>创建距离列表，存储起始节点到每个节点的最短距离</p>\n<ul>\n<li>起始节点到自己是<code>0</code></li>\n<li>到其他节点都暂时记为<code>+∞</code></li>\n</ul>\n<p>创建前驱节点列表</p>\n<h4 id=\"你的边有些松弛\"><a href=\"#你的边有些松弛\" class=\"headerlink\" title=\"你的边有些松弛\"></a><del>你的边有些</del>松弛</h4><p>对于图中的每一条边 <code>(u, v, w)</code> （<code>u</code>和<code>v</code>是边的两个端点，<code>w</code>是边的权重）</p>\n<ul>\n<li>如果<code>dist[u] + w &lt; dist[v]</code>，则更新<code>dist[v] = dist[u] + w</code> （<code>dist</code>是距离列表），并将v的前驱节点设为<code>u</code></li>\n</ul>\n<p>重复 <code>|V|-1</code> 次（<code>|V|</code>是节点的数量）</p>\n<h4 id=\"检查负权环\"><a href=\"#检查负权环\" class=\"headerlink\" title=\"检查负权环\"></a>检查负权环</h4><p>再松弛一次，如果还存在满足<code>dist[u] + w &lt; dist[v]</code>的边，说明存在负权环，无法找到最短路径</p>\n<h4 id=\"回溯-1\"><a href=\"#回溯-1\" class=\"headerlink\" title=\"回溯\"></a>回溯</h4><p>根据前驱节点列表从目标节点回溯到起始节点，得到最短路径</p>\n<h3 id=\"Extension\"><a href=\"#Extension\" class=\"headerlink\" title=\"Extension\"></a>Extension</h3><p><em>松弛操作</em>（Relaxation）是许多最短路径算法中的一个关键步骤，它用于更新从起点到某个节点的当前已知最短距离。松弛操作检查一条边，如果通过该边可以找到更短的路径，就更新目标节点的最短距离。</p>\n<p>假设有一条从节点 <code>u</code> 到节点 <code>v</code> 的边，边的权重为 <code>w(u, v)</code>，当前已知的从起点到 <code>u</code> 的最短距离为 <code>d[u]</code>，到 <code>v</code> 的最短距离为 <code>d[v]</code>：</p>\n<ol>\n<li>计算通过 <code>u</code> 到达 <code>v</code> 的距离，即 <code>d[u] + w(u, v)</code>。</li>\n<li>如果 <code>d[u] + w(u, v) &lt; d[v]</code>，则更新 <code>d[v]</code> 为 <code>d[u] + w(u, v)</code>。</li>\n</ol>\n<p>这种操作的目的是确保每个节点的距离是最短的。</p>\n","excerpt":"","more":"<h1 id=\"离散数学-图的最短路径算法\"><a href=\"#离散数学-图的最短路径算法\" class=\"headerlink\" title=\"离散数学-图的最短路径算法\"></a>离散数学-图的最短路径算法</h1><p><em>此文档用于离散数学课上的主题展示</em></p>\n<h2 id=\"Dijkstra-算法\"><a href=\"#Dijkstra-算法\" class=\"headerlink\" title=\"Dijkstra 算法\"></a>Dijkstra 算法</h2><p>&#x2F;ˈdaɪkstrə&#x2F;</p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Dijkstra 算法是一种在加权图中寻找节点间最短路径的算法，加权图可以表示道路网络等。该算法由计算机科学家 Edsger W. Dijkstra 于 1956 年提出，并于三年后发表。它及其变体被称为均匀成本搜索，是更普遍的最佳优先搜索思想的一个实例。</p>\n<blockquote>\n<p> <em>从 Rotterdam 到 Groningen 的最短路线是什么？我花了大概 20 分钟时间设计了这个寻找最短路径的算法。一天早上我正和我年轻的未婚妻在 Amsterdam 逛街，觉得有点累了，我们就坐在咖啡厅的露台上喝了一杯咖啡，我在想是否能够解决这个问题，然后，我设计出了这个最短路径算法。我说过，这是一个 20 分钟的设计。事实上，三年之后的 1959 年它才被发布，现在看来依然很不错，其原因之一是我当时设计的时候没有纸和笔，从而不得不极力避免所有可避免的复杂性。最终，令我惊讶的是，这个算法成为了我成名的基石之一。</em></p>\n<p> <em>——引自<a href=\"https://dl.acm.org/doi/pdf/10.1145/1787234.1787249\">《An interview with Edsger W. Dijkstra》</a></em></p>\n</blockquote>\n<p>属于动态规划、贪心算法</p>\n<p>如果是二叉堆实现，时间复杂度为 <code>O((V + E) log V)</code> （<code>V</code>是节点数，<code>E</code>是边数）</p>\n<h3 id=\"适用条件\"><a href=\"#适用条件\" class=\"headerlink\" title=\"适用条件\"></a>适用条件</h3><ul>\n<li>适用于带权有向图和带权无向图。</li>\n<li>要求所有边的权值为非负数。</li>\n</ul>\n<blockquote>\n<p>如果图中有负权重的边，这个算法就无法正常工作。</p>\n<p>一旦一个节点被标记为“已访问”，当前访问它的路径就被标记为访问它的最短路径。如果存在负权重，则可能在之后的计算中得到总权重更小的路径，从而影响之前的结果。</p>\n</blockquote>\n<h3 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h3><p><img src=\"/assets/blogs/discrete_math_graphs_algos/Dijkstra_Animation.gif\" alt=\"File:Dijkstra Animation.gif\"></p>\n<p><small><del>维基上扒的图不知道能不能载出来</del></small></p>\n<p>从起始节点开始，逐步扩展到所有节点，每次选择当前已知的最短路径进行扩展。</p>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>选定一个<em>起始节点</em></p>\n<p>创建一个列表 来记录距离：</p>\n<ul>\n<li><p><em>起始节点</em>到它自己的距离为<code>0</code></p>\n</li>\n<li><p>到其它节点的距离未确定，记为<code>+∞</code></p>\n</li>\n</ul>\n<blockquote>\n<p>Python 中的无穷：<code>float(&quot;inf&quot;)</code></p>\n<p>（正负号加在<code>inf</code>前面）</p>\n</blockquote>\n<p>创建一个列表 来记录有哪些节点尚未被访问</p>\n<p>创建一个优先队列 来存储节点及其当前已知的最短距离（开始时包含起始节点）</p>\n<p>创建一个列表 用来记录<em>前驱节点</em>用来回溯路径</p>\n<h4 id=\"开始喵\"><a href=\"#开始喵\" class=\"headerlink\" title=\"开始喵\"></a>开始喵</h4><h5 id=\"循环，直到-优先队列为空-or-已找到目标节点的最短路径\"><a href=\"#循环，直到-优先队列为空-or-已找到目标节点的最短路径\" class=\"headerlink\" title=\"循环，直到 (优先队列为空) or (已找到目标节点的最短路径)\"></a>循环，直到 (优先队列为空) or (已找到目标节点的最短路径)</h5><p>从优先队列中取出距离最小的节点（<em>当前节点</em>）</p>\n<p>对当前节点的所有邻接节点：</p>\n<ul>\n<li>计算从起始节点经过当前节点到达该邻接节点的距离（<em>候选距离</em>）</li>\n<li>如果候选距离小于该邻接节点当前已知的距离，则更新该邻接节点的距离为<em>候选距离</em>，并将该邻接节点及其新距离添加到优先队列中。</li>\n<li>如果需要回溯路径，则在更新距离的同时，记录每个节点的前驱节点</li>\n</ul>\n<p>将<em>当前节点</em>标记为已处理</p>\n<h4 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h4><p>从目标节点回溯到起始节点，得到完整的最短路径</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>嗯 这部分交给 <em>S.K.Y.</em> 罢（</p>\n<h2 id=\"Bellman-Ford-算法\"><a href=\"#Bellman-Ford-算法\" class=\"headerlink\" title=\"Bellman-Ford 算法\"></a>Bellman-Ford 算法</h2><h3 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Bellman-Ford 算法比 Dijkstra 算法慢一些，但通用性更强。</p>\n<blockquote>\n<p>该算法由 Alfonso Shimbel（1955 年）首次提出，但却以 Richard Bellman 和 Lester Ford Jr. 的名字命名，他们分别于 1958 年和 1956 年发表了该算法。</p>\n<p>爱德华-摩尔（Edward F. Moore）也于 1959 年发表了该算法的变体，因此有时也被称为 Bellman-Ford-Moore 算法。</p>\n</blockquote>\n<p>时间复杂度略高（最坏时<code>O(|V||E|</code>)），但可以继续优化</p>\n<h3 id=\"适用条件-1\"><a href=\"#适用条件-1\" class=\"headerlink\" title=\"适用条件\"></a>适用条件</h3><p>比 Dijkstra 多支持了负数权值</p>\n<h3 id=\"内容-1\"><a href=\"#内容-1\" class=\"headerlink\" title=\"内容\"></a>内容</h3><p><img src=\"/assets/blogs/discrete_math_graphs_algos/Bellman%E2%80%93Ford_algorithm_example.gif\" alt=\"File:Bellman–Ford algorithm example.gif\"></p>\n<p><small><del>嗯同样是从维基上扒的，不知道能不能加载ww</del></small></p>\n<h4 id=\"准备工作-1\"><a href=\"#准备工作-1\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>选定起始节点和目标节点</p>\n<p>创建距离列表，存储起始节点到每个节点的最短距离</p>\n<ul>\n<li>起始节点到自己是<code>0</code></li>\n<li>到其他节点都暂时记为<code>+∞</code></li>\n</ul>\n<p>创建前驱节点列表</p>\n<h4 id=\"你的边有些松弛\"><a href=\"#你的边有些松弛\" class=\"headerlink\" title=\"你的边有些松弛\"></a><del>你的边有些</del>松弛</h4><p>对于图中的每一条边 <code>(u, v, w)</code> （<code>u</code>和<code>v</code>是边的两个端点，<code>w</code>是边的权重）</p>\n<ul>\n<li>如果<code>dist[u] + w &lt; dist[v]</code>，则更新<code>dist[v] = dist[u] + w</code> （<code>dist</code>是距离列表），并将v的前驱节点设为<code>u</code></li>\n</ul>\n<p>重复 <code>|V|-1</code> 次（<code>|V|</code>是节点的数量）</p>\n<h4 id=\"检查负权环\"><a href=\"#检查负权环\" class=\"headerlink\" title=\"检查负权环\"></a>检查负权环</h4><p>再松弛一次，如果还存在满足<code>dist[u] + w &lt; dist[v]</code>的边，说明存在负权环，无法找到最短路径</p>\n<h4 id=\"回溯-1\"><a href=\"#回溯-1\" class=\"headerlink\" title=\"回溯\"></a>回溯</h4><p>根据前驱节点列表从目标节点回溯到起始节点，得到最短路径</p>\n<h3 id=\"Extension\"><a href=\"#Extension\" class=\"headerlink\" title=\"Extension\"></a>Extension</h3><p><em>松弛操作</em>（Relaxation）是许多最短路径算法中的一个关键步骤，它用于更新从起点到某个节点的当前已知最短距离。松弛操作检查一条边，如果通过该边可以找到更短的路径，就更新目标节点的最短距离。</p>\n<p>假设有一条从节点 <code>u</code> 到节点 <code>v</code> 的边，边的权重为 <code>w(u, v)</code>，当前已知的从起点到 <code>u</code> 的最短距离为 <code>d[u]</code>，到 <code>v</code> 的最短距离为 <code>d[v]</code>：</p>\n<ol>\n<li>计算通过 <code>u</code> 到达 <code>v</code> 的距离，即 <code>d[u] + w(u, v)</code>。</li>\n<li>如果 <code>d[u] + w(u, v) &lt; d[v]</code>，则更新 <code>d[v]</code> 为 <code>d[u] + w(u, v)</code>。</li>\n</ol>\n<p>这种操作的目的是确保每个节点的距离是最短的。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clqntcox80004z4o189cqaq0g","category_id":"clqqfd3uf0003jco1azbe5r3n","_id":"clqqfd3ug0008jco19l7846hm"},{"post_id":"clqr0xnb10000fko1c0z74w7c","category_id":"clqqfd3ue0001jco1dyik3wnc","_id":"clqr0xnb60002fko134l707df"},{"post_id":"clscnryal0000rso19pqe6rb9","category_id":"clqqfd3ue0001jco1dyik3wnc","_id":"clscnryaq0002rso1495kf6xh"},{"post_id":"clwz1gok80000lco19itfd4or","category_id":"clwz1pgx3000038o1a6xhea18","_id":"clwz1pgx4000338o1ekbpbk94"}],"PostTag":[{"post_id":"clqntcox80004z4o189cqaq0g","tag_id":"clqqbbgkl0000w0o1h28geruu","_id":"clqqbbgkn0002w0o18q5k6g9z"},{"post_id":"clqntcox80004z4o189cqaq0g","tag_id":"clqqbbgkm0001w0o10vjcd3zx","_id":"clqqbbgkn0003w0o17h32bjkj"},{"post_id":"clqr0xnb10000fko1c0z74w7c","tag_id":"clqqfd3ue0002jco17f1fhsq7","_id":"clqr0xnb60003fko1gi6ua7le"},{"post_id":"clqr0xnb10000fko1c0z74w7c","tag_id":"clqqfd3uf0004jco1g46rbvgg","_id":"clqr0xnb60004fko13v6s2bi0"},{"post_id":"clqr0xnb10000fko1c0z74w7c","tag_id":"clqr0xnb50001fko1ctri9ct6","_id":"clqr0xnb60005fko16bx00jhk"},{"post_id":"clscnryal0000rso19pqe6rb9","tag_id":"clqqfd3uf0004jco1g46rbvgg","_id":"clscnryar0005rso142j7cm7l"},{"post_id":"clscnryal0000rso19pqe6rb9","tag_id":"clscnryap0001rso13h9v2xm9","_id":"clscnryar0006rso19eetgq31"},{"post_id":"clscnryal0000rso19pqe6rb9","tag_id":"clscnryaq0003rso14tq47fae","_id":"clscnryar0007rso1b4je24id"},{"post_id":"clscnryal0000rso19pqe6rb9","tag_id":"clscnryaq0004rso1amqv5y0b","_id":"clscnryar0008rso196cucs90"},{"post_id":"clwz1gok80000lco19itfd4or","tag_id":"clwz1pgx4000238o1h3eeca5f","_id":"clwz1pgx4000538o183vmbnt7"},{"post_id":"clwz1gok80000lco19itfd4or","tag_id":"clwz1q1wn000638o1248y88ky","_id":"clwz1q1wn000738o19v526een"}],"Tag":[{"name":"Test","_id":"clqqbbgkl0000w0o1h28geruu"},{"name":"Cheshire Cat","_id":"clqqbbgkm0001w0o10vjcd3zx"},{"name":"Tag","_id":"clqqbcz720001tco14zer8nc0"},{"name":"Tag Test","_id":"clqqbdztp0001doo197nrajti"},{"name":"Bilibili","_id":"clqqfd3ue0002jco17f1fhsq7"},{"name":"Python","_id":"clqqfd3uf0004jco1g46rbvgg"},{"name":"Tkinter","_id":"clqr0xnb50001fko1ctri9ct6"},{"name":"onebot","_id":"clscnryap0001rso13h9v2xm9"},{"name":"QQ","_id":"clscnryaq0003rso14tq47fae"},{"name":"shamrock","_id":"clscnryaq0004rso1amqv5y0b"},{"name":"Math","_id":"clwz1pgx3000138o10n0fgzfe"},{"name":"Algorithm","_id":"clwz1pgx4000238o1h3eeca5f"},{"name":"Discrete Math","_id":"clwz1q1wn000638o1248y88ky"}]}}