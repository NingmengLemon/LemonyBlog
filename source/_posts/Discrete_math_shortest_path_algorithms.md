---
title: 离散数学-图的最短路径
date: 2024-6-3 22:07:00
tags: [Discrete Math, Algorithm]
categories: [Algorithm]
---

# 离散数学-图的最短路径算法

*此文档用于离散数学课上的主题展示*

## Dijkstra 算法

/ˈdaɪkstrə/

### 介绍

Dijkstra 算法是一种在加权图中寻找节点间最短路径的算法，加权图可以表示道路网络等。该算法由计算机科学家 Edsger W. Dijkstra 于 1956 年提出，并于三年后发表。它及其变体被称为均匀成本搜索，是更普遍的最佳优先搜索思想的一个实例。

>  *从 Rotterdam 到 Groningen 的最短路线是什么？我花了大概 20 分钟时间设计了这个寻找最短路径的算法。一天早上我正和我年轻的未婚妻在 Amsterdam 逛街，觉得有点累了，我们就坐在咖啡厅的露台上喝了一杯咖啡，我在想是否能够解决这个问题，然后，我设计出了这个最短路径算法。我说过，这是一个 20 分钟的设计。事实上，三年之后的 1959 年它才被发布，现在看来依然很不错，其原因之一是我当时设计的时候没有纸和笔，从而不得不极力避免所有可避免的复杂性。最终，令我惊讶的是，这个算法成为了我成名的基石之一。*
>
>  *——引自[《An interview with Edsger W. Dijkstra》](https://dl.acm.org/doi/pdf/10.1145/1787234.1787249)*

属于动态规划、贪心算法

如果是二叉堆实现，时间复杂度为 `O((V + E) log V)` （`V`是节点数，`E`是边数）

### 适用条件

   - 适用于带权有向图和带权无向图。
   - 要求所有边的权值为非负数。

> 如果图中有负权重的边，这个算法就无法正常工作。
>
> 一旦一个节点被标记为“已访问”，当前访问它的路径就被标记为访问它的最短路径。如果存在负权重，则可能在之后的计算中得到总权重更小的路径，从而影响之前的结果。

### 内容

![File:Dijkstra Animation.gif](/assets/blogs/discrete_math_graphs_algos/Dijkstra_Animation.gif)

<small><del>维基上扒的图不知道能不能载出来</del></small>

从起始节点开始，逐步扩展到所有节点，每次选择当前已知的最短路径进行扩展。

#### 准备工作

选定一个*起始节点*

创建一个列表 来记录距离：

- *起始节点*到它自己的距离为`0`

- 到其它节点的距离未确定，记为`+∞`

> Python 中的无穷：`float("inf")`
>
> （正负号加在`inf`前面）

创建一个列表 来记录有哪些节点尚未被访问

创建一个优先队列 来存储节点及其当前已知的最短距离（开始时包含起始节点）

创建一个列表 用来记录*前驱节点*用来回溯路径

#### 开始喵

##### 循环，直到 (优先队列为空) or (已找到目标节点的最短路径)

从优先队列中取出距离最小的节点（*当前节点*）

对当前节点的所有邻接节点：

- 计算从起始节点经过当前节点到达该邻接节点的距离（*候选距离*）
- 如果候选距离小于该邻接节点当前已知的距离，则更新该邻接节点的距离为*候选距离*，并将该邻接节点及其新距离添加到优先队列中。
- 如果需要回溯路径，则在更新距离的同时，记录每个节点的前驱节点

将*当前节点*标记为已处理

#### 回溯

从目标节点回溯到起始节点，得到完整的最短路径

### 代码

嗯 这部分交给 *S.K.Y.* 罢（

## Bellman-Ford 算法

### 介绍

Bellman-Ford 算法比 Dijkstra 算法慢一些，但通用性更强。

> 该算法由 Alfonso Shimbel（1955 年）首次提出，但却以 Richard Bellman 和 Lester Ford Jr. 的名字命名，他们分别于 1958 年和 1956 年发表了该算法。
>
> 爱德华-摩尔（Edward F. Moore）也于 1959 年发表了该算法的变体，因此有时也被称为 Bellman-Ford-Moore 算法。

时间复杂度略高（最坏时`O(|V||E|`)），但可以继续优化

### 适用条件

比 Dijkstra 多支持了负数权值

### 内容

![File:Bellman–Ford algorithm example.gif](/assets/blogs/discrete_math_graphs_algos/Bellman–Ford_algorithm_example.gif)

<small><del>嗯同样是从维基上扒的，不知道能不能加载ww</del></small>

#### 准备工作

选定起始节点和目标节点

创建距离列表，存储起始节点到每个节点的最短距离

- 起始节点到自己是`0`
- 到其他节点都暂时记为`+∞`

创建前驱节点列表

#### ~~你的边有些~~松弛

对于图中的每一条边 `(u, v, w)` （`u`和`v`是边的两个端点，`w`是边的权重）

- 如果`dist[u] + w < dist[v]`，则更新`dist[v] = dist[u] + w` （`dist`是距离列表），并将v的前驱节点设为`u`

重复 `|V|-1` 次（`|V|`是节点的数量）

#### 检查负权环

再松弛一次，如果还存在满足`dist[u] + w < dist[v]`的边，说明存在负权环，无法找到最短路径

#### 回溯

根据前驱节点列表从目标节点回溯到起始节点，得到最短路径

### Extension

*松弛操作*（Relaxation）是许多最短路径算法中的一个关键步骤，它用于更新从起点到某个节点的当前已知最短距离。松弛操作检查一条边，如果通过该边可以找到更短的路径，就更新目标节点的最短距离。

假设有一条从节点 `u` 到节点 `v` 的边，边的权重为 `w(u, v)`，当前已知的从起点到 `u` 的最短距离为 `d[u]`，到 `v` 的最短距离为 `d[v]`：

1. 计算通过 `u` 到达 `v` 的距离，即 `d[u] + w(u, v)`。
2. 如果 `d[u] + w(u, v) < d[v]`，则更新 `d[v]` 为 `d[u] + w(u, v)`。

这种操作的目的是确保每个节点的距离是最短的。